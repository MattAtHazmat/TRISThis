Disassembly Listing for TRISThisFWV1p0
Generated From:
/home/matt/Projects/TRISThis/TRISThisFWV1p0.X/dist/default/debug/TRISThisFWV1p0.X.debug.elf
Sep 24, 2013 5:21:56 PM

---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D0048E0  8FC20028   LW V0, 40(S8)
9D0048E4  AFC2002C   SW V0, 44(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D0048E8  8FC30028   LW V1, 40(S8)
9D0048EC  3C0204C4   LUI V0, 1220
9D0048F0  3442B401   ORI V0, V0, -19455
9D0048F4  0062102B   SLTU V0, V1, V0
9D0048F8  14400008   BNE V0, ZERO, 0x9D00491C
9D0048FC  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D004900  3C020008   LUI V0, 8
9D004904  AFC20030   SW V0, 48(S8)
118:                         pb_clock >>= 1;
9D004908  8FC2002C   LW V0, 44(S8)
9D00490C  00021042   SRL V0, V0, 1
9D004910  AFC2002C   SW V0, 44(S8)
9D004914  0B401248   J 0x9D004920
9D004918  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D00491C  AFC00030   SW ZERO, 48(S8)
9D004920  8FC20030   LW V0, 48(S8)
9D004924  AFC20034   SW V0, 52(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
9D004860  AFC00020   SW ZERO, 32(S8)
9D004864  0B401223   J 0x9D00488C
9D004868  00000000   NOP
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
9D00488C  8FC3001C   LW V1, 28(S8)
9D004890  3C0201C9   LUI V0, 457
9D004894  3442C381   ORI V0, V0, -15487
9D004898  0062102B   SLTU V0, V1, V0
9D00489C  1040FFF3   BEQ V0, ZERO, 0x9D00486C
9D0048A0  00000000   NOP
170:                     {
171:                         wait_states++;
9D00486C  8FC20020   LW V0, 32(S8)
9D004870  24420001   ADDIU V0, V0, 1
9D004874  AFC20020   SW V0, 32(S8)
172:                         sys_clock -= FLASH_SPEED_HZ;
9D004878  8FC3001C   LW V1, 28(S8)
9D00487C  3C02FE36   LUI V0, -458
9D004880  34423C80   ORI V0, V0, 15488
9D004884  00621021   ADDU V0, V1, V0
9D004888  AFC2001C   SW V0, 28(S8)
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
9D0048A4  0F40182F   JAL INTDisableInterrupts
9D0048A8  00000000   NOP
9D0048AC  AFC20024   SW V0, 36(S8)
176:                     mCheConfigure(wait_states);
9D0048B0  3C02BF88   LUI V0, -16504
9D0048B4  8FC30020   LW V1, 32(S8)
9D0048B8  AC434000   SW V1, 16384(V0)
177:                     INTRestoreInterrupts(int_status);
9D0048BC  8FC40024   LW A0, 36(S8)
9D0048C0  0F401805   JAL INTRestoreInterrupts
9D0048C4  00000000   NOP
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D00482C  0F40182F   JAL INTDisableInterrupts
9D004830  00000000   NOP
9D004834  AFC20018   SW V0, 24(S8)
342:                 
343:                     mBMXDisableDRMWaitState();
9D004838  3C02BF88   LUI V0, -16504
9D00483C  24030040   ADDIU V1, ZERO, 64
9D004840  AC432004   SW V1, 8196(V0)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
9D004844  8FC20014   LW V0, 20(S8)
9D004848  30420001   ANDI V0, V0, 1
9D00484C  304200FF   ANDI V0, V0, 255
9D004850  1040001D   BEQ V0, ZERO, 0x9D0048C8
9D004854  00000000   NOP
9D004858  8FC20010   LW V0, 16(S8)
9D00485C  AFC2001C   SW V0, 28(S8)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
9D0048C8  8FC20014   LW V0, 20(S8)
9D0048CC  30420002   ANDI V0, V0, 2
9D0048D0  10400065   BEQ V0, ZERO, 0x9D004A68
9D0048D4  00000000   NOP
9D0048D8  8FC20010   LW V0, 16(S8)
9D0048DC  AFC20028   SW V0, 40(S8)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
9D004A68  8FC20014   LW V0, 20(S8)
9D004A6C  30420004   ANDI V0, V0, 4
9D004A70  1040000C   BEQ V0, ZERO, 0x9D004AA4
9D004A74  00000000   NOP
358:                     {
359:                         cache_status = mCheGetCon();
9D004A78  3C02BF88   LUI V0, -16504
9D004A7C  8C424000   LW V0, 16384(V0)
9D004A80  AFC2004C   SW V0, 76(S8)
360:                         cache_status |= CHE_CONF_PF_ALL;
9D004A84  8FC2004C   LW V0, 76(S8)
9D004A88  34420030   ORI V0, V0, 48
9D004A8C  AFC2004C   SW V0, 76(S8)
361:                         mCheConfigure(cache_status);
9D004A90  3C02BF88   LUI V0, -16504
9D004A94  8FC3004C   LW V1, 76(S8)
9D004A98  AC434000   SW V1, 16384(V0)
362:                         CheKseg0CacheOn();
9D004A9C  0F401812   JAL CheKseg0CacheOn
9D004AA0  00000000   NOP
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
9D004AA4  8FC20010   LW V0, 16(S8)
9D004AA8  AFC20050   SW V0, 80(S8)
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D004AAC  3C02BF81   LUI V0, -16511
9D004AB0  8C42F000   LW V0, -4096(V0)
9D004AB4  7C420CC0   EXT V0, V0, 19, 2
9D004AB8  304200FF   ANDI V0, V0, 255
9D004ABC  8FC30050   LW V1, 80(S8)
9D004AC0  00431006   SRLV V0, V1, V0
9D004AC4  AFC20050   SW V0, 80(S8)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D004AC8  8FC40018   LW A0, 24(S8)
9D004ACC  0F401805   JAL INTRestoreInterrupts
9D004AD0  00000000   NOP
370:                 
371:                     return pb_clk;
9D004AD4  AFC00054   SW ZERO, 84(S8)
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/osc.h  ----------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D004928  0F40182F   JAL INTDisableInterrupts
9D00492C  00000000   NOP
9D004930  AFC20038   SW V0, 56(S8)
9D004978  AFC20040   SW V0, 64(S8)
9D00497C  3C02BF81   LUI V0, -16511
9D004980  AC40F230   SW ZERO, -3536(V0)
9D004984  3C02BF81   LUI V0, -16511
9D004988  3C03AA99   LUI V1, -21863
9D00498C  34636655   ORI V1, V1, 26197
9D004990  AC43F230   SW V1, -3536(V0)
9D004994  3C02BF81   LUI V0, -16511
9D004998  3C035566   LUI V1, 21862
9D00499C  346399AA   ORI V1, V1, -26198
9D0049A0  AC43F230   SW V1, -3536(V0)
9D004AD8  0F40182F   JAL INTDisableInterrupts
9D004ADC  00000000   NOP
9D004AE0  AFC20058   SW V0, 88(S8)
9D004B28  AFC20060   SW V0, 96(S8)
9D004B2C  3C02BF81   LUI V0, -16511
9D004B30  AC40F230   SW ZERO, -3536(V0)
9D004B34  3C02BF81   LUI V0, -16511
9D004B38  3C03AA99   LUI V1, -21863
9D004B3C  34636655   ORI V1, V1, 26197
9D004B40  AC43F230   SW V1, -3536(V0)
9D004B44  3C02BF81   LUI V0, -16511
9D004B48  3C035566   LUI V1, 21862
9D004B4C  346399AA   ORI V1, V1, -26198
9D004B50  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D0049A4  3C02BF81   LUI V0, -16511
9D0049A8  8C42F000   LW V0, -4096(V0)
9D0049AC  AFC20070   SW V0, 112(S8)
9D004B54  3C02BF81   LUI V0, -16511
9D004B58  8C42F000   LW V0, -4096(V0)
9D004B5C  AFC2006C   SW V0, 108(S8)
178:                 	oscBits.PBDIV=0;
9D0049B0  8FC20070   LW V0, 112(S8)
9D0049B4  7C02A4C4   INS V0, ZERO, 19, 2
9D0049B8  AFC20070   SW V0, 112(S8)
9D004B60  8FC2006C   LW V0, 108(S8)
9D004B64  7C02A4C4   INS V0, ZERO, 19, 2
9D004B68  AFC2006C   SW V0, 108(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D0049BC  8FC30070   LW V1, 112(S8)
9D0049C0  8FC20034   LW V0, 52(S8)
9D0049C4  00621025   OR V0, V1, V0
9D0049C8  AFC20070   SW V0, 112(S8)
9D004B6C  8FC3006C   LW V1, 108(S8)
9D004B70  8FC20054   LW V0, 84(S8)
9D004B74  00621025   OR V0, V1, V0
9D004B78  AFC2006C   SW V0, 108(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D0049CC  8FC30070   LW V1, 112(S8)
9D0049D0  3C02BF81   LUI V0, -16511
9D0049D4  AC43F000   SW V1, -4096(V0)
9D004B7C  8FC3006C   LW V1, 108(S8)
9D004B80  3C02BF81   LUI V0, -16511
9D004B84  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D0049D8  3C02BF81   LUI V0, -16511
9D0049DC  8C42F000   LW V0, -4096(V0)
9D0049E0  AFC20070   SW V0, 112(S8)
9D004B88  3C02BF81   LUI V0, -16511
9D004B8C  8C42F000   LW V0, -4096(V0)
9D004B90  AFC2006C   SW V0, 108(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D0049E4  3C02BF81   LUI V0, -16511
9D0049E8  3C033333   LUI V1, 13107
9D0049EC  34633333   ORI V1, V1, 13107
9D0049F0  AC43F230   SW V1, -3536(V0)
9D0049F4  8FC20040   LW V0, 64(S8)
9D0049F8  AFC20044   SW V0, 68(S8)
9D004A5C  8FC40038   LW A0, 56(S8)
9D004A60  0F401805   JAL INTRestoreInterrupts
9D004A64  00000000   NOP
9D004B94  3C02BF81   LUI V0, -16511
9D004B98  3C033333   LUI V1, 13107
9D004B9C  34633333   ORI V1, V1, 13107
9D004BA0  AC43F230   SW V1, -3536(V0)
9D004BA4  8FC20060   LW V0, 96(S8)
9D004BA8  AFC20064   SW V0, 100(S8)
9D004C0C  8FC40058   LW A0, 88(S8)
9D004C10  0F401805   JAL INTRestoreInterrupts
9D004C14  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/dma_5xx_6xx_7xx.h  ----------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Complier:        MPLAB C32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                  	#define _DMA_CHANNELS		// DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                  	typedef enum
56:                  	{
57:                  		DMA_CHANNEL0,
58:                  	#ifdef _DMAC1
59:                  		DMA_CHANNEL1,
60:                  	#ifdef _DMAC2
61:                  		DMA_CHANNEL2,
62:                  	#ifdef _DMAC3
63:                  		DMA_CHANNEL3,
64:                  	#ifdef _DMAC4
65:                  		DMA_CHANNEL4,
66:                  	#ifdef _DMAC5
67:                  		DMA_CHANNEL5,
68:                  	#ifdef _DMAC6
69:                  		DMA_CHANNEL6,
70:                  	#ifdef _DMAC7
71:                  		DMA_CHANNEL7,
72:                  	#endif	// _DMAC7
73:                  	#endif	// _DMAC6
74:                  	#endif	// _DMAC5
75:                  	#endif	// _DMAC4
76:                  	#endif	// _DMAC3
77:                  	#endif	// _DMAC2
78:                  	#endif	// _DMAC1
79:                  		//	add/remove DMA channel as needed here
80:                  
81:                  		DMA_CHANNELS	// number of current available channels
82:                  	}DmaChannel;
83:                  
84:                  
85:                  	// Relative Dma channels priority, between each other
86:                  	typedef enum
87:                  	{
88:                  		DMA_CHN_PRI0,
89:                  		DMA_CHN_PRI1,
90:                  		DMA_CHN_PRI2,
91:                  		DMA_CHN_PRI3
92:                  	}DmaChannelPri;
93:                  
94:                  
95:                  
96:                  	// high level definitions for the API functions
97:                  
98:                  	typedef enum
99:                  	{
100:                 		DMA_OPEN_DEFAULT = 0,							        // DMA default operation
101:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
102:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
103:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
104:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
105:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
106:                 		DMA_OPEN_MATCH	= 0x80000000,						    // DMA channel stops on match
107:                 	}DmaOpenFlags;	// flags for the channel open
108:                 
109:                 
110:                 	typedef enum
111:                 	{
112:                 		DMA_EV_ERR =			0x1,		// address error event
113:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
114:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
115:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
116:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
117:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
118:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
119:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
120:                 
121:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
122:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
123:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
124:                 
125:                 
126:                 	typedef enum
127:                 	{
128:                 		DMA_TXFER_OK,			// the transfer was performed successfully
129:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
130:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
131:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
132:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
133:                 		DMA_TXFER_TMO			// DMA transfer timeout
134:                 	}DmaTxferRes;		// DMA transfer result
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
139:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
140:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
141:                 	}DmaWaitMode;		// DMA transfer wait mode
142:                 
143:                 	typedef enum
144:                 	{
145:                 		DMA_CHKSUM_CRC,		// LFSR CRC
146:                 		DMA_CHKSUM_IP,		// IP Checksum
147:                 	}DmaChksumType;		// DMA SFM supported checksum types
148:                 
149:                 	typedef enum
150:                 	{
151:                 		DMA_BITO_MSb,		// MSb first (not reflected)
152:                 		DMA_BITO_LSb,		// LSb first (reflected)
153:                 	}DmaBitOrder;		// DMA SFM supported bit ordering
154:                 
155:                 	typedef enum
156:                 	{
157:                 		DMA_REORDER_NOT,	// no reordering, destination matches the source
158:                 		DMA_REORDER_ENDIAN,	// change endianess on word (32 bit) boundaries: LE<->BE
159:                 		DMA_REORDER_SWAP_HALF,	// swap half words (16 bit) within word (32 bit)		
160:                 		DMA_REORDER_SWAP_BYTE,	// swap bytes within half word (16 bit)				
161:                 	}DmaReorderMode;	// DMA SFM supported re-ordering modes
162:                 
163:                 
164:                 	/*********************************************************************
165:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
166:                 	 *
167:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
168:                 	 *
169:                 	 * Input:           chn    - channel to be configured in the DMA controller
170:                 	 *                  chPri  - the priority given to the channel, 0-3
171:                 	 *                  oFlags - orred flags specifying the open mode:
172:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
173:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
174:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
175:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
176:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
177:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
178:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
179:                 	 *
180:                 	 *
181:                 	 *
182:                 	 * Output:          None
183:                 	 *
184:                 	 * Side Effects:    None
185:                 	 *
186:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
187:                 	 *
188:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
189:                 	 *                  Use the low level functions to address special settings.
190:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
191:                 	 *                  After that the channel is configured.
192:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
193:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
194:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
195:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
196:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
197:                 	 *                  User has to call event channel functions to enable the event flags if needed.
198:                 	 *
199:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
200:                 	 ********************************************************************/
201:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
202:                 
203:                 	/*********************************************************************
204:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
205:                 	 *
206:                 	 * PreCondition:    None
207:                 	 *
208:                 	 * Input:			chn		- channel to be enabled
209:                 	 *
210:                 	 * Output:          None
211:                 	 *
212:                 	 * Side Effects:    None
213:                 	 *
214:                 	 * Overview:		The function enables a previously configured DMA channel.
215:                 	 *
216:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
217:                 	 *
218:                 	 * Example:			DmaChnEnable(DMA_CHANNEL3);
219:                 	 ********************************************************************/
220:                 	 void			DmaChnEnable(DmaChannel chn);
221:                 
222:                 	/*********************************************************************
223:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
224:                 	 *
225:                 	 * PreCondition:    None
226:                 	 *
227:                 	 * Input:			chn		- selected channel in the DMA controller
228:                 	 *
229:                 	 * Output:          None
230:                 	 *
231:                 	 * Side Effects:    None
232:                 	 *
233:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
234:                 	 *
235:                 	 * Note:            None.
236:                 	 *
237:                 	 * Example:			DmaChnDisable(DMA_CHANNEL3);
238:                 	 ********************************************************************/
239:                 	 void			DmaChnDisable(DmaChannel chn);
240:                 
241:                 	/*********************************************************************
242:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
243:                 	 *
244:                 	 * PreCondition:    chn		- valid DMA channel
245:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
246:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
247:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
248:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
249:                 	 *
250:                 	 * Input:			chn			- DMA channel number
251:                 	 * 								- vSrcAdd: source of the DMA transfer
252:                 	 * 								- vDstAdd: destination of the DMA transfer
253:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
254:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
255:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
256:                 	 *
257:                 	 * Output:          None
258:                 	 *
259:                 	 * Side Effects:    None
260:                 	 *
261:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
262:                 	 * 					the source and the destination addresses.
263:                 	 * 					the source and destination lengths
264:                 	 * 					and the number of bytes	transferred per event.
265:                 	 *
266:                 	 * Note:            The function clears the existing DMA channel event flags.
267:                 	 *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
268:                 	 *
269:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
270:                 	 ********************************************************************/
271:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
272:                 
273:                 
274:                 	/*********************************************************************
275:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
276:                 	 *
277:                 	 * PreCondition:    chn		- valid DMA channel
278:                 	 *
279:                 	 * Input:           chn		- DMA channel number
280:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
281:                 	 * Output:          None
282:                 	 *
283:                 	 * Side Effects:    None
284:                 	 *
285:                 	 * Overview:        The function is a helper to set directly the transfer source address.
286:                 	 *
287:                 	 * Note:            None.
288:                 	 *
289:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
290:                 	 ********************************************************************/
291:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
292:                 
293:                 	/*********************************************************************
294:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
295:                 	 *
296:                 	 * PreCondition:    chn		- valid DMA channel
297:                 	 *
298:                 	 * Input:			chn			- DMA channel number
299:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
300:                 	 * Output:          None
301:                 	 *
302:                 	 * Side Effects:    None
303:                 	 *
304:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
305:                 	 *
306:                 	 * Note:            None
307:                 	 *
308:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
309:                 	 ********************************************************************/
310:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
311:                 
312:                 	/*********************************************************************
313:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
314:                 	 *
315:                 	 * PreCondition:    chn	- valid DMA channel
316:                 	 *
317:                 	 * Input:			chn		- DMA channel number
318:                 	 * 					pattern	-  the match pattern
319:                 	 *
320:                 	 * Output:          None
321:                 	 *
322:                 	 * Side Effects:    None
323:                 	 *
324:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
325:                 	 *
326:                 	 * Note:            None.
327:                 	 *
328:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
329:                 	 ********************************************************************/
330:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
331:                 
332:                 	/*********************************************************************
333:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
334:                 	 *
335:                 	 * PreCondition:    chn	- valid DMA channel
336:                 	 *
337:                 	 * Input:			chn		- DMA channel number
338:                 	 *
339:                 	 * Output:          The channel match pattern.
340:                 	 *
341:                 	 * Side Effects:    None
342:                 	 *
343:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
344:                 	 *
345:                 	 * Note:            None.
346:                 	 *
347:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
348:                 	 ********************************************************************/
349:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
350:                 
351:                 	/*********************************************************************
352:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
353:                 	 *
354:                 	 * PreCondition:    chn	- valid DMA channel
355:                 	 *
356:                 	 * Input:			chn		- DMA channel number
357:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
358:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
359:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
360:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
361:                 	 * 								If 0, wait forever.
362:                 	 *
363:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
364:                 	 * 					an DmaTxferRes error code  otherwise
365:                 	 *
366:                 	 * Side Effects:    None
367:                 	 *
368:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
369:                 	 * 					The DMA channel is enabled.
370:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
371:                 	 * 					this event) the function will periodically query the DMA controller for the
372:                 	 * 					transfer completion status.
373:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
374:                      * 					the block transfer than the function will re-force the transfer for each cell.
375:                 	 *
376:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
377:                      *                  by hardware interrupt requests.
378:                      *                  This is because the transfers are software forced, theere is no
379:                      *                  wait for the occurrence of the hardware trigger. 
380:                 	 *
381:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
382:                 	 ********************************************************************/
383:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
384:                 
385:                 	/*********************************************************************
386:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
387:                 	 *
388:                 	 * PreCondition:    chn	- valid DMA channel
389:                 	 *
390:                 	 * Input:			chn		- DMA channel number
391:                 	 *
392:                 	 * Output:          None
393:                 	 *
394:                 	 * Side Effects:    None
395:                 	 *
396:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
397:                 	 *
398:                 	 * Note:            None.
399:                 	 *
400:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL3);
401:                 	 ********************************************************************/
402:                 	 void			DmaChnForceTxfer(DmaChannel chn);
403:                 
404:                 	/*********************************************************************
405:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
406:                 	 *
407:                 	 * PreCondition:    chn	- valid DMA channel
408:                 	 *
409:                 	 * Input:			chn		- DMA channel number
410:                 	 *
411:                 	 * Output:          None
412:                 	 *
413:                 	 * Side Effects:    None
414:                 	 *
415:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
416:                 	 *
417:                 	 * Note:            None.
418:                 	 *
419:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL3);
420:                 	 ********************************************************************/
421:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
422:                 
423:                 	// High level channel event and interrupt control functions
424:                 
425:                 	/*********************************************************************
426:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
427:                 	 *
428:                 	 * PreCondition:    chn	- valid DMA channel
429:                 	 *
430:                 	 * Input:			chn		- DMA channel number
431:                 	 * 					eFlags	- event flags with the following significance:
432:                 	 * 								- DMA_EV_ERR: address error event
433:                 	 * 								- DMA_EV_ABORT: transfer abort event
434:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
435:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
436:                 	 * 								- DMA_EV_DST_HALF: destination half event
437:                 	 * 								- DMA_EV_DST_FULL: destination full event
438:                 	 * 								- DMA_EV_SRC_HALF: source half event
439:                 	 * 								- DMA_EV_SRC_FULL: source full event
440:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
441:                 	 *
442:                 	 * Output:          None
443:                 	 *
444:                 	 * Side Effects:    None
445:                 	 *
446:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
447:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
448:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
449:                 	 *
450:                 	 * Note:            None.
451:                 	 *
452:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
453:                 	 ********************************************************************/
454:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
455:                 
456:                 	/*********************************************************************
457:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
458:                 	 *
459:                 	 * PreCondition:    chn	- valid DMA channel
460:                 	 *
461:                 	 * Input:			chn		- DMA channel number
462:                 	 * 					eFlags	- event flags with the following significance:
463:                 	 * 								- DMA_EV_ERR: address error event
464:                 	 * 								- DMA_EV_ABORT: transfer abort event
465:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
466:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
467:                 	 * 								- DMA_EV_DST_HALF: destination half event
468:                 	 * 								- DMA_EV_DST_FULL: destination full event
469:                 	 * 								- DMA_EV_SRC_HALF: source half event
470:                 	 * 								- DMA_EV_SRC_FULL: source full event
471:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
472:                 	 *
473:                 	 * Output:          None
474:                 	 *
475:                 	 * Side Effects:    None
476:                 	 *
477:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
478:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
479:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
480:                 	 *
481:                 	 * Note:            None.
482:                 	 *
483:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
484:                 	 ********************************************************************/
485:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
486:                 
487:                 	/*********************************************************************
488:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
489:                 	 *
490:                 	 * PreCondition:    chn	- valid DMA channel
491:                 	 *
492:                 	 * Input:			chn		- DMA channel number
493:                 	 * 					eFlags	- event flags with the following significance:
494:                 	 * 								- DMA_EV_ERR: address error event
495:                 	 * 								- DMA_EV_ABORT: transfer abort event
496:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
497:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
498:                 	 * 								- DMA_EV_DST_HALF: destination half event
499:                 	 * 								- DMA_EV_DST_FULL: destination full event
500:                 	 * 								- DMA_EV_SRC_HALF: source half event
501:                 	 * 								- DMA_EV_SRC_FULL: source full event
502:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
503:                 	 *
504:                 	 * Output:          None
505:                 	 *
506:                 	 * Side Effects:    None
507:                 	 *
508:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
509:                 	 * 					The channel event flags are forced to the eFlags value.
510:                 	 *
511:                 	 * Note:            None.
512:                 	 *
513:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
514:                 	 ********************************************************************/
515:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
516:                 
517:                 	/*********************************************************************
518:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
519:                 	 *
520:                 	 * PreCondition:    chn	- valid DMA channel
521:                 	 *
522:                 	 * Input:			chn		- DMA channel number
523:                 	 *
524:                 	 * Output:          - event flags with the following significance:
525:                 	 * 						- DMA_EV_ERR: address error event
526:                 	 * 						- DMA_EV_ABORT: transfer abort event
527:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
528:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
529:                 	 * 						- DMA_EV_DST_HALF: destination half event
530:                 	 * 						- DMA_EV_DST_FULL: destination full event
531:                 	 * 						- DMA_EV_SRC_HALF: source half event
532:                 	 * 						- DMA_EV_SRC_FULL: source full event
533:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
534:                 	 *
535:                 	 * Side Effects:    None
536:                 	 *
537:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
538:                 	 *
539:                 	 * Note:            None.
540:                 	 *
541:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
542:                 	 ********************************************************************/
543:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
544:                 
545:                 	/*********************************************************************
546:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
547:                 	 *
548:                 	 * PreCondition:    chn	- valid DMA channel
549:                 	 *
550:                 	 * Input:			chn		- DMA channel number
551:                 	 * 					eFlags	- event flags with the following significance:
552:                 	 * 								- DMA_EV_ERR: address error event
553:                 	 * 								- DMA_EV_ABORT: transfer abort event
554:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
555:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
556:                 	 * 								- DMA_EV_DST_HALF: destination half event
557:                 	 * 								- DMA_EV_DST_FULL: destination full event
558:                 	 * 								- DMA_EV_SRC_HALF: source half event
559:                 	 * 								- DMA_EV_SRC_FULL: source full event
560:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
561:                 	 *
562:                 	 * Output:          None
563:                 	 *
564:                 	 * Side Effects:    None
565:                 	 *
566:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
567:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
568:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
569:                 	 *
570:                 	 * Note:            None.
571:                 	 *
572:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
573:                 	 ********************************************************************/
574:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
575:                 
576:                 	/*********************************************************************
577:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
578:                 	 *
579:                 	 * PreCondition:    chn	- valid DMA channel
580:                 	 *
581:                 	 * Input:			chn		- DMA channel number
582:                 	 *
583:                 	 * Output:          event flags with the following significance:
584:                 	 * 						- DMA_EV_ERR: address error event
585:                 	 * 						- DMA_EV_ABORT: transfer abort event
586:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
587:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
588:                 	 * 						- DMA_EV_DST_HALF: destination half event
589:                 	 * 						- DMA_EV_DST_FULL: destination full event
590:                 	 * 						- DMA_EV_SRC_HALF: source half event
591:                 	 * 						- DMA_EV_SRC_FULL: source full event
592:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
593:                 	 *
594:                 	 * Side Effects:    None
595:                 	 *
596:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
597:                 	 *
598:                 	 * Note:            None.
599:                 	 *
600:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
601:                 	 ********************************************************************/
602:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
603:                 
604:                 
605:                 	// high level helpers for fast strcpy/memcpy transfers
606:                 
607:                 	/*********************************************************************
608:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
609:                 	 *
610:                 	 * PreCondition:    chn		- a valid DMA channel
611:                 	 * 					s1, s2	- valid memory pointers
612:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
613:                 	 *
614:                 	 * Input:			s1		- destination pointer
615:                 	 * 					s2		- source pointer
616:                 	 * 					n		- number of bytes to transfer
617:                 	 * 					chn		- the DMA channel to perform the transfer
618:                 	 * 					chPri	- the desired channel priority
619:                 	 *
620:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
621:                 	 * 					an DmaTxferRes error code  otherwise
622:                 	 *
623:                 	 * Side Effects:    None
624:                 	 *
625:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
626:                 	 * 			Then it copies one block of memory from source to destination.
627:                 	 *
628:                 	 *
629:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
630:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
631:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
632:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
633:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
634:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
635:                 	 *
636:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
637:                  	 ********************************************************************/
638:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
639:                 
640:                 	/*********************************************************************
641:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
642:                 	 *
643:                 	 * PreCondition:    chn		- a valid DMA channel
644:                 	 * 					s1, s2	- valid memory pointers
645:                 	 *
646:                 	 * Input:			s1		- destination pointer
647:                 	 * 					s2		- source pointer
648:                 	 * 					chn		- the DMA channel to perform the transfer
649:                 	 * 					chPri	- the desired channel priority
650:                 	 *
651:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
652:                 	 * 					an DmaTxferRes error code  otherwise
653:                 	 *
654:                 	 * Side Effects:    None
655:                 	 *
656:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
657:                 	 * 			Then it copies one zero terminated string from source to destination.
658:                 	 *
659:                 	 *
660:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
661:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
662:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
663:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
664:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
665:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
666:                 	 *
667:                 	 *
668:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
669:                 	 *********************************************************************/
670:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
671:                 
672:                 	/*********************************************************************
673:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
674:                 	 *
675:                 	 * PreCondition:    chn		- a valid DMA channel
676:                 	 * 				- s1, s2	- valid memory pointers
677:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
678:                 	 *
679:                 	 * Input:			s1		- destination pointer
680:                 	 * 					s2		- source pointer
681:                 	 * 					n	- max number of bytes to transfer
682:                 	 * 					chn		- the DMA channel to perform the transfer
683:                 	 * 					chPri	- the desired channel priority
684:                 	 *
685:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
686:                 	 * 					an DmaTxferRes error code  otherwise
687:                 	 *
688:                 	 * Side Effects:    None
689:                 	 *
690:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
691:                 	 * 			Then it copies one zero terminated string from source to destination.
692:                 	 * 			It copies no more than n characters from s2.
693:                 	 *
694:                 	 *
695:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
696:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
697:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
698:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
699:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
700:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
701:                 	 *
702:                 	 *
703:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
704:                 	 ********************************************************************/
705:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
706:                 
707:                 	/*********************************************************************
708:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
709:                 	 *
710:                 	 * PreCondition:    chn    - a valid DMA channel
711:                 	 *                  d, s   - valid memory pointer
712:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
713:                 	 *
714:                 	 * Input:           d     - address where to deposit the result
715:                 	 *                  s     - source buffer pointer
716:                 	 *                  n     - number of bytes in the pointer
717:                 	 *                  chn   - the DMA channel to use
718:                 	 *                  chPri - the desired channel priority
719:                 	 * 
720:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
721:                 	 *                  an DmaTxferRes error code  otherwise
722:                 	 *
723:                 	 * Side Effects:    None
724:                 	 *
725:                 	 * Overview:        The function is a helper that calculates the CRC of a memory block.
726:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
727:                 	 *
728:                 	 *
729:                 	 * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
730:                 	 *                  - No transfer is done, just the CRC is calculated.
731:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
732:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
733:                 	 *                  - The checksum type is switched to CRC.
734:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
735:                 	 *                  
736:                 	 * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
737:                 	 ********************************************************************/
738:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
739:                 
740:                 	/*********************************************************************
741:                 	 * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
742:                 	 *
743:                 	 * PreCondition:    chn    - a valid DMA channel
744:                 	 *                  d, s   - valid memory pointer
745:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
746:                 	 *
747:                 	 * Input:           d     - address where to deposit the result
748:                 	 *                  s     - source buffer pointer
749:                 	 *                  n     - number of bytes in the pointer
750:                 	 *                  chn   - the DMA channel to use
751:                 	 *                  chPri - the desired channel priority
752:                 	 * 
753:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
754:                 	 *                  an DmaTxferRes error code  otherwise
755:                 	 *
756:                 	 * Side Effects:    None
757:                 	 *
758:                 	 * Overview:        The function is a helper that calculates the IP checksum of a memory block.
759:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
760:                 	 *
761:                 	 *
762:                 	 * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
763:                 	 *                  - No transfer is done, just the checksum is calculated.
764:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
765:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
766:                 	 *                  - The checksum type is switched to IP checksum.
767:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
768:                 	 *                  
769:                 	 * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
770:                 	 ********************************************************************/
771:                 	 DmaTxferRes	DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
772:                 
773:                 	// High level Special Function Module (SFM) functions
774:                 
775:                 	/*********************************************************************
776:                 	 * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
777:                 	 *
778:                 	 * PreCondition:    cType, bitO, rMode - valid values
779:                 	 *
780:                 	 * Input:           cType - checksum type to be calculated: CRC or IP Checksum
781:                 	 *                  bitO  - the bit order to be used MSb or LSb first
782:                 	 *                  rMode - the reordering mode of the bytes when calculating the checksum 
783:                 	 *
784:                 	 * Output:          None
785:                 	 *
786:                 	 * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
787:                 	 *
788:                 	 * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
789:                 	 *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
790:                 	 *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first) 
791:                 	 *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
792:                 	 *                      All these values affect the way the checksum is calculated.
793:                 	 *
794:                 	 * Note:            None
795:                 	 *
796:                 	 * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
797:                 	 ********************************************************************/
798:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
799:                 	{
800:                 		DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
801:                 		DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
802:                 	}
803:                 
804:                 	/*********************************************************************
805:                 	 * Function:        void DmaSfmTxferReorder(int enable)
806:                 	 *
807:                 	 * PreCondition:    None
808:                 	 *
809:                 	 * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
810:                 	 *
811:                 	 * Output:          None
812:                 	 *
813:                 	 * Side Effects:    None
814:                 	 *
815:                 	 * Overview:        The function configures the data transfer re-ordering of the SFM module.
816:                 	 *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
817:                 	 *                  Otherwise the data is written to the destination un-modified.
818:                 	 *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
819:                 	 *                  
820:                 	 *
821:                 	 * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
822:                 	 *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
823:                 	 *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
824:                 	 *                    Un-aligned transfers are not supported (undefined behavior)!
825:                 	 *
826:                 	 * Example:         DmaSfmTxferReorder();
827:                 	 ********************************************************************/
828:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
829:                 	{
830:                 		DCRCCONCLR=_DCRCCON_WBO_MASK;
831:                 		DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
832:                 	}
833:                 
834:                 
835:                 	 /*********************************************************************
836:                 	 * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
837:                 	 *
838:                 	 * PreCondition:    pLen   - valid polynomial length within 1-32
839:                 	 *
840:                 	 * Input:           polynomial	- the layout of the CRC generator
841:                 	 *                  pLen        - the length of the CRC generator polynomial
842:                 	 *                  seed        - the initial seed of the CRC generator
843:                 	 *
844:                 	 * Output:          None
845:                 	 *
846:                 	 * Side Effects:    None
847:                 	 *
848:                 	 * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
849:                 	 *                  - the length of the CRC generator polynomial, pLen;
850:                 	 *                  - the function sets the layout of the shift stages that take place in the CRC generation.
851:                 	 *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
852:                 	 *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
853:                 	 *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
854:                 	 *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
855:                 	 *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
856:                 	 *                  - the function sets the seed of the CRC generator. This is the initial data present in the
857:                 	 *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
858:                 	 *
859:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
860:                 	 *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
861:                 	 *                    Upon the transfer completion the calculated CRC is stored at the destination address.
862:                 	 *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
863:                 	 *                    the CrcResult() function.
864:                 	 *                  - The CRC module should be configured before enabled.
865:                 	 *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
866:                 	 *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
867:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
868:                 	 *
869:                 	 * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
870:                 	 ********************************************************************/
871:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
872:                 	{
873:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
874:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
875:                 		DCRCDATA=seed;
876:                 		DCRCXOR=polynomial;
877:                 	}
878:                 	
879:                 	#define DmaCrcConfigure	DmaSfmCrcConfigure	// PIC32_3xx backward compatibility name
880:                 
881:                 
882:                 	/*********************************************************************
883:                 	 * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
884:                 	 *
885:                 	 * PreCondition:    chn	   - valid DMA channel
886:                 	 *
887:                 	 * Input:           chn         - the DMA channel to be attached to the checksum module.
888:                 	 *                  appendMode	- if TRUE the data passed to the checksum generator is not transferred to destination
889:                 	 *                                but it's written to the destination address when the block transfer is complete.
890:                 	 *                              - if FALSE the data is transferred normally while the checksum is calculated.
891:                 	 *                                The checksum will be available using the DmaSfmChecksum function.
892:                 	 *
893:                 	 * Output:          None
894:                 	 *
895:                 	 * Side Effects:    None
896:                 	 *
897:                 	 * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
898:                 	 *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
899:                 	 *                  is complete, the checksum result is available in the checksum data register.
900:                 	 *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
901:                 
902:                 	 *
903:                 	 * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
904:                 	 * 
905:                 	 * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
906:                 	 ********************************************************************/
907:                 	void			DmaSfmAttachChannel(DmaChannel chn, int appendMode);
908:                 	#define			CrcAttachChannel	DmaSfmAttachChannel		// PIC32_3xx backward compatibility name	
909:                 
910:                 	/*********************************************************************
911:                 	 * Function:        unsigned int DmaSfmChecksum(void)
912:                 	 *
913:                 	 * PreCondition:    None
914:                 	 *
915:                 	 * Input:			None
916:                 	 *
917:                 	 * Output:          the current value of the checksum generator.
918:                 	 *
919:                 	 * Side Effects:    None
920:                 	 *
921:                 	 * Overview:		The function returns the calculated checksum value.
922:                 	 *
923:                 	 * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
924:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
925:                 	 *
926:                 	 * Example:         unsigned int myChk=DmaSfmChecksum();
927:                 	 ********************************************************************/
928:                 	extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
929:                 	{
930:                 		return DCRCDATA;
931:                 	}
932:                 	#define		CrcResult	DmaSfmChecksum		// PIC32_3xx backward compatibility name
933:                 	#define		DmaCrcGetValue	DmaSfmChecksum		// PIC32_3xx backward compatibility name 
934:                 
935:                 
936:                 	/*********************************************************************
937:                 	 * Function:        void DmaSfmSetSeed(unsigned int seed)
938:                 	 *
939:                 	 * PreCondition:    None
940:                 	 *
941:                 	 * Input:           seed	- the initial seed of the checksum generator
942:                 	 *
943:                 	 * Output:          None
944:                 	 *
945:                 	 * Side Effects:    None
946:                 	 *
947:                 	 * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
948:                 	 *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
949:                 	 *
950:                 	 * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
951:                 	 *
952:                 	 * Example:         DmaSfmSetSeed(0xffffffff);
953:                 	 ********************************************************************/
954:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
955:                 	{
956:                 		DCRCDATA=seed;
957:                 	}
958:                 	#define		DmaCrcSetSeed	DmaSfmSetSeed		// PIC32_3xx backward compatibility name
959:                 
960:                 	 
961:                 /*********************  end of high level functions ****************************************/
962:                 
963:                 	// low level definitions for the API functions
964:                 
965:                 
966:                 	typedef struct
967:                 	{
968:                 		union
969:                 		{
970:                 			struct
971:                 			{
972:                 				unsigned int chn:	3;		// last active DMA channel
973:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
974:                 			};
975:                 			unsigned int	w;						// word access
976:                 		}lastAccess;
977:                 		void*	lastAddress;		// most recent DMA address
978:                 	}DmaStatus;			// DMA controller status
979:                 
980:                 	typedef enum
981:                 	{
982:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
983:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
984:                 		//
985:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
986:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
987:                 
988:                 
989:                 
990:                 
991:                 	typedef enum
992:                 	{
993:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
994:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
995:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
996:                         // the start and abort IRQ signals
997:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
998:                 
999:                 
1000:                        // compiler use only field
1001:                        _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1002:                	}DmaEvCtrlFlags;	/*DMA channel event control fields accessible as flags also
1003:                	                	  part of DmaEvCtrlFlags:
1004:                	                	*/
1005:                	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1006:                	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1007:                
1008:                	// DMA channel event control as a structure:
1009:                	#define	DmaEvCtrl	__DCH0ECONbits_t
1010:                
1011:                
1012:                
1013:                
1014:                	typedef enum
1015:                	{
1016:                		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
1017:                		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
1018:                		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
1019:                		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
1020:                		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
1021:                        // use the DMA_CTL_PRI() below for selecting the DMA
1022:                        // channel priority
1023:                	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
1024:                	// also part of DmaChnCtrlFlags:
1025:                	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1026:                
1027:                	// DMA channel control as a structure:
1028:                	#define	DmaChnCtrl  	__DCH0CONbits_t
1029:                
1030:                	typedef struct
1031:                	{
1032:                		void*	vSrcAdd;		// source of the DMA transfer, virtual
1033:                		void*	vDstAdd;		// destination of the DMA transfer, virtual
1034:                		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1035:                		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1036:                		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1037:                	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
1038:                
1039:                
1040:                	/********************** low level DMA channel functions *******************************/
1041:                
1042:                
1043:                
1044:                	// Global DMA controller functions
1045:                
1046:                	/*********************************************************************
1047:                	 * Function:        void DmaEnable(int enable)
1048:                	 *
1049:                	 * PreCondition:    None
1050:                	 *
1051:                	 * Input:           enable - boolean to enable/disable the DMA controller
1052:                	 *
1053:                	 * Output:          None
1054:                	 *
1055:                	 * Side Effects:    None
1056:                	 *
1057:                	 * Overview:       The function enables/disables the DMA controller.
1058:                	 *
1059:                	 * Note:           None.
1060:                	 *
1061:                	 * Example:        DmaEnable(1);
1062:                	 ********************************************************************/
1063:                	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1064:                	{
1065:                		if(enable)
1066:                		{
1067:                			DMACONSET=_DMACON_ON_MASK;
1068:                		}
1069:                		else
1070:                		{
1071:                			DMACONCLR=_DMACON_ON_MASK;
1072:                			while(DMACONbits.ON);		// wait to take effect
1073:                		}
1074:                	}
1075:                
1076:                	/*********************************************************************
1077:                	 * Function:        void DmaReset(void)
1078:                	 *
1079:                	 * PreCondition:    None
1080:                	 *
1081:                	 * Input:		None
1082:                	 *
1083:                	 * Output:          None
1084:                	 *
1085:                	 * Side Effects:    None
1086:                	 *
1087:                	 * Overview:        The function resets the DMA controller.
1088:                	 *
1089:                	 * Note:            None.
1090:                	 *
1091:                	 * Example:        DmaReset();
1092:                	 ********************************************************************/
1093:                	#define            DmaReset()	DmaEnable(0)
1094:                
1095:                
1096:                	/*********************************************************************
1097:                	 * Function:        int DmaSuspend(void)
1098:                	 *
1099:                	 * PreCondition:    None
1100:                	 *
1101:                	 * Input:		None
1102:                	 *
1103:                	 * Output:          true if the DMA was previously suspended, false otherwise
1104:                	 *
1105:                	 *
1106:                	 * Side Effects:    None
1107:                	 *
1108:                	 * Overview:        The function suspends the DMA controller.
1109:                	 *
1110:                	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1111:                	 *                  I.e. the function has to wait for the suspension to take place!
1112:                	 *
1113:                	 * Example:         int susp=DmaSuspend();
1114:                	 ********************************************************************/
1115:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1116:                	{
1117:                		int suspSt;
1118:                		if(!(suspSt=DMACONbits.SUSPEND))
9D004934  3C02BF88   LUI V0, -16504
9D004938  8C423000   LW V0, 12288(V0)
9D00493C  7C420300   EXT V0, V0, 12, 1
9D004940  304200FF   ANDI V0, V0, 255
9D004944  AFC2003C   SW V0, 60(S8)
9D004948  8FC2003C   LW V0, 60(S8)
9D00494C  14400009   BNE V0, ZERO, 0x9D004974
9D004950  00000000   NOP
9D004A08  3C02BF88   LUI V0, -16504
9D004A0C  8C423000   LW V0, 12288(V0)
9D004A10  7C420300   EXT V0, V0, 12, 1
9D004A14  304200FF   ANDI V0, V0, 255
9D004A18  AFC20048   SW V0, 72(S8)
9D004A1C  8FC20048   LW V0, 72(S8)
9D004A20  1440000E   BNE V0, ZERO, 0x9D004A5C
9D004A24  00000000   NOP
9D004AE4  3C02BF88   LUI V0, -16504
9D004AE8  8C423000   LW V0, 12288(V0)
9D004AEC  7C420300   EXT V0, V0, 12, 1
9D004AF0  304200FF   ANDI V0, V0, 255
9D004AF4  AFC2005C   SW V0, 92(S8)
9D004AF8  8FC2005C   LW V0, 92(S8)
9D004AFC  14400009   BNE V0, ZERO, 0x9D004B24
9D004B00  00000000   NOP
9D004BB8  3C02BF88   LUI V0, -16504
9D004BBC  8C423000   LW V0, 12288(V0)
9D004BC0  7C420300   EXT V0, V0, 12, 1
9D004BC4  304200FF   ANDI V0, V0, 255
9D004BC8  AFC20068   SW V0, 104(S8)
9D004BCC  8FC20068   LW V0, 104(S8)
9D004BD0  1440000E   BNE V0, ZERO, 0x9D004C0C
9D004BD4  00000000   NOP
1119:                		{
1120:                			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D004954  3C02BF88   LUI V0, -16504
9D004958  24031000   ADDIU V1, ZERO, 4096
9D00495C  AC433008   SW V1, 12296(V0)
9D004A28  3C02BF88   LUI V0, -16504
9D004A2C  24031000   ADDIU V1, ZERO, 4096
9D004A30  AC433008   SW V1, 12296(V0)
9D004B04  3C02BF88   LUI V0, -16504
9D004B08  24031000   ADDIU V1, ZERO, 4096
9D004B0C  AC433008   SW V1, 12296(V0)
9D004BD8  3C02BF88   LUI V0, -16504
9D004BDC  24031000   ADDIU V1, ZERO, 4096
9D004BE0  AC433008   SW V1, 12296(V0)
1121:                			while((DMACONbits.DMABUSY));	// wait to be actually suspended
9D004960  3C02BF88   LUI V0, -16504
9D004964  8C423000   LW V0, 12288(V0)
9D004968  30420800   ANDI V0, V0, 2048
9D00496C  1440FFFC   BNE V0, ZERO, 0x9D004960
9D004970  00000000   NOP
9D004A34  3C02BF88   LUI V0, -16504
9D004A38  8C423000   LW V0, 12288(V0)
9D004A3C  30420800   ANDI V0, V0, 2048
9D004A40  1440FFFC   BNE V0, ZERO, 0x9D004A34
9D004A44  00000000   NOP
9D004A48  0B401297   J 0x9D004A5C
9D004A4C  00000000   NOP
9D004B10  3C02BF88   LUI V0, -16504
9D004B14  8C423000   LW V0, 12288(V0)
9D004B18  30420800   ANDI V0, V0, 2048
9D004B1C  1440FFFC   BNE V0, ZERO, 0x9D004B10
9D004B20  00000000   NOP
9D004BE4  3C02BF88   LUI V0, -16504
9D004BE8  8C423000   LW V0, 12288(V0)
9D004BEC  30420800   ANDI V0, V0, 2048
9D004BF0  1440FFFC   BNE V0, ZERO, 0x9D004BE4
9D004BF4  00000000   NOP
9D004BF8  0B401303   J 0x9D004C0C
9D004BFC  00000000   NOP
1122:                		}
1123:                		return suspSt;
9D004974  8FC2003C   LW V0, 60(S8)
9D004B24  8FC2005C   LW V0, 92(S8)
1124:                	}
1125:                
1126:                
1127:                
1128:                	/*********************************************************************
1129:                	 * Function:        void DmaResume(int susp)
1130:                	 *
1131:                	 * PreCondition:    None
1132:                	 *
1133:                	 * Input:		the desired DMA suspended state.
1134:                	 *
1135:                	 * Output:          None
1136:                	 *
1137:                	 * Side Effects:    None
1138:                	 *
1139:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1140:                	 *
1141:                	 * Note:            None.
1142:                	 *
1143:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1144:                	 ********************************************************************/
1145:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1146:                	{
1147:                		if(susp)
9D0049FC  8FC20044   LW V0, 68(S8)
9D004A00  10400013   BEQ V0, ZERO, 0x9D004A50
9D004A04  00000000   NOP
9D004BAC  8FC20064   LW V0, 100(S8)
9D004BB0  10400013   BEQ V0, ZERO, 0x9D004C00
9D004BB4  00000000   NOP
1148:                		{
1149:                			DmaSuspend();
1150:                		}
1151:                		else
1152:                		{
1153:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D004A50  3C02BF88   LUI V0, -16504
9D004A54  24031000   ADDIU V1, ZERO, 4096
9D004A58  AC433004   SW V1, 12292(V0)
9D004C00  3C02BF88   LUI V0, -16504
9D004C04  24031000   ADDIU V1, ZERO, 4096
9D004C08  AC433004   SW V1, 12292(V0)
1154:                		}
1155:                	}
1156:                
1157:                	/*********************************************************************
1158:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1159:                	 *
1160:                	 * PreCondition:    pStat	- valid pointer
1161:                	 *
1162:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1163:                	 * 							status, carrying the following info:
1164:                	 * 								- chn:	the last active DMA channel
1165:                	 * 								- rdOp: the last DMA operation, read/write
1166:                	 * 								- lastAddress: the most recent DMA address
1167:                	 *
1168:                	 * Output:          None
1169:                	 *
1170:                	 * Side Effects:    None
1171:                	 *
1172:                	 * Overview:		The function updates the info for the current DMA controller status.
1173:                	 * 					It updates the last DMA: operation, channel used and address.
1174:                	 *
1175:                	 * Note:            None.
1176:                	 *
1177:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1178:                	 ********************************************************************/
1179:                	 void			DmaGetStatus(DmaStatus* pStat);
1180:                
1181:                	/*********************************************************************
1182:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1183:                	 *
1184:                	 * PreCondition:    None
1185:                	 *
1186:                	 * Input:           gFlags - flags to be set, having the following fields:
1187:                	 * 			- DMA_GFLG_SUSPEND: DMA controller operation suspend
1188:                	 * 			- DMA_GFLG_ON: DMA controller enabled/desabled
1189:                	 * 			- DMA_GFLG_ALL_FLAGS: all flags
1190:                	 *
1191:                	 * Output:          None
1192:                	 *
1193:                	 * Side Effects:    None
1194:                	 *
1195:                	 * Overview:        The function affects the global behavior of the DMA controller.
1196:                	 *                  It sets the specified flags. Any flag that is set in the gFlags will be
1197:                	 *                  enabled, the other flags won't be touched.
1198:                	 *
1199:                	 * Note:            None.
1200:                	 *
1201:                	 * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1202:                	 ********************************************************************/
1203:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1204:                	{
1205:                		DMACONSET=gFlags;
1206:                	}
1207:                
1208:                	/*********************************************************************
1209:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1210:                	 *
1211:                	 * PreCondition:    None
1212:                	 *
1213:                	 * Input:           gFlags - flags to be cleared, having the following fields:
1214:                	 *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1215:                	 *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1216:                	 *                               - DMA_GFLG_ALL_FLAGS: all flags
1217:                	 *
1218:                	 * Output:          None
1219:                	 *
1220:                	 * Side Effects:    None
1221:                	 *
1222:                	 * Overview:        The function affects the global behavior of the DMA controller.
1223:                	 *                  It clears the specified flags. Any flag that is set in the gFlags will be
1224:                	 *                  cleared, the other flags won't be touched.
1225:                	 *
1226:                	 * Note:            None.
1227:                	 *
1228:                	 * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1229:                	 ********************************************************************/
1230:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1231:                	{
1232:                		DMACONCLR=gFlags;
1233:                	}
1234:                
1235:                
1236:                	/*********************************************************************
1237:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1238:                	 *
1239:                	 * PreCondition:    None
1240:                	 *
1241:                	 * Input:           gFlags - flags to be set, having the following fields:
1242:                	 *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1243:                	 *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1244:                	 *                                 - DMA_GFLG_ALL_FLAGS: all flags
1245:                	 *
1246:                	 * Output:          None
1247:                	 *
1248:                	 * Side Effects:    None
1249:                	 *
1250:                	 * Overview:        The function affects the global behavior of the DMA controller.
1251:                	 *                  It forces the flags to have the specified gFlags value.
1252:                	 *
1253:                	 * Note:            None.
1254:                	 *
1255:                	 * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1256:                	 ********************************************************************/
1257:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1258:                	{
1259:                		DMACON=gFlags;
1260:                	}
1261:                
1262:                	/*********************************************************************
1263:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1264:                	 *
1265:                	 * PreCondition:    None
1266:                	 *
1267:                	 * Input:           None
1268:                	 *
1269:                	 * Output:          The current DMA controller flags settings.
1270:                	 *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1271:                	 *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1272:                	 *
1273:                	 * Side Effects:    None
1274:                	 *
1275:                	 * Overview:        The function returns the global flags of the DMA controller.
1276:                	 *
1277:                	 * Note:            None.
1278:                	 *
1279:                	 * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1280:                	 ********************************************************************/
1281:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1282:                	{
1283:                		return (DmaGlblFlags)DMACON;
1284:                	}
1285:                
1286:                
1287:                	/*********************************************************************
1288:                	 * Function:        int DmaGetMaxTxferSize(void)
1289:                	 *
1290:                	 * PreCondition:    None
1291:                	 *
1292:                	 * Input:           None
1293:                	 *
1294:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1295:                	 *
1296:                	 * Side Effects:    None
1297:                	 *
1298:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1299:                	 *
1300:                	 * Note:            Revision dependant.
1301:                	 *
1302:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1303:                	 ********************************************************************/
1304:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1305:                	{
1306:                		return 65536;
1307:                	}
1308:                
1309:                	// Direct Channel control functions
1310:                
1311:                	typedef enum
1312:                	{
1313:                		DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1314:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1315:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1316:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),		// DMA channel is chained to higher channel
1317:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,			// events detection enabled while channel off
1318:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,	            // DMA channel is enabled after open
1319:                		DMA_CONFIG_MATCH	= 0x80000000,                   // DMA channel stops on match
1320:                	}DmaConfigFlags;	// flags for the channel configuration
1321:                
1322:                
1323:                
1324:                	/*********************************************************************
1325:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1326:                	 *
1327:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1328:                	 *
1329:                	 * Input:           chn    - channel to be configured in the DMA controller
1330:                	 *                  chPri  - the priority given to the channel, 0-3
1331:                	 *                  cFlags - orred flags specifying the configuration:
1332:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1333:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1334:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1335:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1336:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1337:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1338:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1339:                	 *
1340:                	 *
1341:                	 *
1342:                	 * Output:          None
1343:                	 *
1344:                	 * Side Effects:    None
1345:                	 *
1346:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1347:                	 *
1348:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1349:                	 *                  The channel is just configured.
1350:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1351:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1352:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1353:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1354:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1355:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1356:                	 *
1357:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1358:                	 ********************************************************************/
1359:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1360:                
1361:                
1362:                	/*********************************************************************
1363:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1364:                	 *
1365:                	 * PreCondition:    chn	- valid DMA channel
1366:                	 *
1367:                	 * Input:			chn		- DMA channel number
1368:                	 *
1369:                	 * Output:          Current channel source pointer.
1370:                	 *
1371:                	 * Side Effects:    None
1372:                	 *
1373:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1374:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1375:                	 *
1376:                	 * Note:            None
1377:                	 *
1378:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1379:                	 ********************************************************************/
1380:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1381:                
1382:                	/*********************************************************************
1383:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1384:                	 *
1385:                	 * PreCondition:    chn	- valid DMA channel
1386:                	 *
1387:                	 * Input:			chn		- DMA channel number
1388:                	 *
1389:                	 * Output:          Current channel destination pointer.
1390:                	 *
1391:                	 * Side Effects:    None
1392:                	 *
1393:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1394:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1395:                	 *
1396:                	 * Note:            None
1397:                	 *
1398:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1399:                	 ********************************************************************/
1400:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1401:                
1402:                	/*********************************************************************
1403:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1404:                	 *
1405:                	 * PreCondition:    chn	- valid DMA channel
1406:                	 *
1407:                	 * Input:			chn		- DMA channel number
1408:                	 *
1409:                	 * Output:          Current channel transfer pointer.
1410:                	 *
1411:                	 * Side Effects:    None
1412:                	 *
1413:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1414:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1415:                	 *
1416:                	 * Note:            None
1417:                	 *
1418:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1419:                	 ********************************************************************/
1420:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1421:                
1422:                
1423:                
1424:                	/*********************************************************************
1425:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1426:                	 *
1427:                	 * PreCondition:    chn	- valid DMA channel
1428:                	 *
1429:                	 * Input:			chn			- DMA channel number
1430:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1431:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1432:                	 * 										- SIRQEN: enable/disable the start IRQ action
1433:                	 * 										- PATEN: enable/disable the pattern match and abort
1434:                	 * 									or any of the DmaEvCtrlFlags:
1435:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1436:                	 *
1437:                	 *
1438:                	 * Output:          None
1439:                	 *
1440:                	 * Side Effects:    None
1441:                	 *
1442:                	 * Overview:		The function sets the events that start and abort the transfer
1443:                	 * 					for the selected DMA channel.
1444:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1445:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1446:                	 *
1447:                	 * Note:            None.
1448:                	 *
1449:                	 * Example:			either:
1450:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1451:                	 * 					or:
1452:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1453:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1454:                	 *
1455:                	 ********************************************************************/
1456:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1457:                
1458:                
1459:                	/*********************************************************************
1460:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1461:                	 *
1462:                	 * PreCondition:    chn	- valid DMA channel
1463:                	 *
1464:                	 * Input:			chn			- DMA channel number
1465:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1466:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1467:                	 * 										- SIRQEN: enable/disable the start IRQ action
1468:                	 * 										- PATEN: enable/disable the pattern match and abort
1469:                	 * 									or any of the DmaEvCtrlFlags:
1470:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1471:                	 *
1472:                	 *
1473:                	 * Output:          None
1474:                	 *
1475:                	 * Side Effects:    None
1476:                	 *
1477:                	 * Overview:		The function clears the events that start and abort the transfer
1478:                	 * 					for the selected DMA channel.
1479:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1480:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1481:                	 *
1482:                	 * Note:            None.
1483:                	 *
1484:                	 * Example:			either:
1485:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1486:                	 * 					or:
1487:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1488:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1489:                	 *
1490:                	 ********************************************************************/
1491:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1492:                
1493:                
1494:                
1495:                	/*********************************************************************
1496:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1497:                	 *
1498:                	 * PreCondition:    chn	- valid DMA channel
1499:                	 *
1500:                	 * Input:			chn			- DMA channel number
1501:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1502:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1503:                	 * 										- SIRQEN: enable/disable the start IRQ action
1504:                	 * 										- PATEN: enable/disable the pattern match and abort
1505:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1506:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1507:                	 * 									or any of the DmaEvCtrlFlags:
1508:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1509:                	 *
1510:                	 *
1511:                	 * Output:          None
1512:                	 *
1513:                	 * Side Effects:    None
1514:                	 *
1515:                	 * Overview:		The function writes the events that start and abort the transfer
1516:                	 * 					for the selected DMA channel.
1517:                	 *
1518:                	 * Note:            None.
1519:                	 *
1520:                	 * Example:			either:
1521:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1522:                	 * 					or:
1523:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1524:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1525:                	 *
1526:                	 ********************************************************************/
1527:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1528:                
1529:                
1530:                
1531:                	/*********************************************************************
1532:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1533:                	 *
1534:                	 * PreCondition:    chn	- valid DMA channel
1535:                	 *
1536:                	 * Input:			chn			- DMA channel number
1537:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1538:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1539:                	 * 										- SIRQEN: enable/disable the start IRQ action
1540:                	 * 										- PATEN: enable/disable the pattern match and abort
1541:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1542:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1543:                	 * 									or any of the DmaEvCtrlFlags:
1544:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1545:                	 *
1546:                	 *
1547:                	 * Output:          None
1548:                	 *
1549:                	 * Side Effects:    None
1550:                	 *
1551:                	 * Overview:		The function sets the events that start and abort the transfer
1552:                	 * 					for the selected DMA channel.
1553:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1554:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1555:                	 *
1556:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1557:                	 *
1558:                	 * Example:			either:
1559:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1560:                	 * 					or:
1561:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1562:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1563:                	 *
1564:                	 ********************************************************************/
1565:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1566:                
1567:                
1568:                	/*********************************************************************
1569:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1570:                	 *
1571:                	 * PreCondition:    chn	- valid DMA channel
1572:                	 *
1573:                	 * Input:			chn		- DMA channel number
1574:                	 *
1575:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1576:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1577:                	 * 							- SIRQEN: enable/disable the start IRQ action
1578:                	 * 							- PATEN: enable/disable the pattern match and abort
1579:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1580:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1581:                	 * 						or any of the DmaEvCtrlFlags:
1582:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1583:                	 *
1584:                	 *
1585:                	 * Side Effects:    None
1586:                	 *
1587:                	 * Overview:		The function retrieves the events that start and abort the transfer
1588:                	 * 					for the selected DMA channel.
1589:                	 *
1590:                	 * Note:            None.
1591:                	 *
1592:                	 * Example:			either:
1593:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1594:                	 * 					or:
1595:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1596:                	 *
1597:                	 ********************************************************************/
1598:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1599:                
1600:                
1601:                	/*********************************************************************
1602:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1603:                	 *
1604:                	 * PreCondition:    chn	- valid DMA channel
1605:                	 *
1606:                	 * Input:			chn			- DMA channel number
1607:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1608:                	 * 										- autoEn: enable/disable the automatic mode
1609:                	 * 										- chainEn: enable/disable channel chaining
1610:                	 * 										- detectEn: enable/disable events detection when channel disabled
1611:                	 * 										- chEn: enable/disable channel functionality
1612:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1613:                	 * 									or any of the DmaChnCtrlFlags flags:
1614:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1615:                	 *
1616:                	 * Output:          None
1617:                	 *
1618:                	 * Side Effects:    None
1619:                	 *
1620:                	 * Overview:		The function sets the selected DMA channel control flags:
1621:                	 * 					the chaining or auto mode, and events detection.
1622:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1623:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1624:                	 *
1625:                	 * Note:            None.
1626:                	 *
1627:                	 * Example:			either:
1628:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1629:                	 * 					or:
1630:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1631:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1632:                	 *
1633:                	 ********************************************************************/
1634:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1635:                
1636:                	/*********************************************************************
1637:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1638:                	 *
1639:                	 * PreCondition:    chn	- valid DMA channel
1640:                	 *
1641:                	 * Input:			chn			- DMA channel number
1642:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1643:                	 * 										- autoEn: enable/disable the automatic mode
1644:                	 * 										- chainEn: enable/disable channel chaining
1645:                	 * 										- detectEn: enable/disable events detection when channel disabled
1646:                	 * 										- chEn: enable/disable channel functionality
1647:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1648:                	 * 									or any of the DmaChnCtrlFlags flags:
1649:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1650:                	 *
1651:                	 * Output:          None
1652:                	 *
1653:                	 * Side Effects:    None
1654:                	 *
1655:                	 * Overview:		The function clears the selected DMA channel control flags:
1656:                	 * 					the chaining or auto mode and events detection.
1657:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1658:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1659:                	 *
1660:                	 * Note:            None.
1661:                	 *
1662:                	 * Example:			either:
1663:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1664:                	 * 					or:
1665:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1666:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1667:                	 *
1668:                	 ********************************************************************/
1669:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1670:                
1671:                	/*********************************************************************
1672:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1673:                	 *
1674:                	 * PreCondition:    chn	- valid DMA channel
1675:                	 *
1676:                	 * Input:			chn			- DMA channel number
1677:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1678:                	 * 										- chPri: channel priority 0-3
1679:                	 * 										- autoEn: enable/disable the automatic mode
1680:                	 * 										- chainEn: enable/disable channel chaining
1681:                	 * 										- detectEn: enable/disable events detection when channel disabled
1682:                	 * 										- chEn: enable/disable channel functionality
1683:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1684:                	 * 									or any of the DmaChnCtrlFlags flags:
1685:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1686:                	 *
1687:                	 * Output:          None
1688:                	 *
1689:                	 * Side Effects:    None
1690:                	 *
1691:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1692:                	 * 					the channel priority, chaining mode or auto and events detection.
1693:                	 *
1694:                	 * Note:            None.
1695:                	 *
1696:                	 * Example:			either:
1697:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1698:                	 * 					or:
1699:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1700:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1701:                	 *
1702:                	 ********************************************************************/
1703:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1704:                
1705:                	/*********************************************************************
1706:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1707:                	 *
1708:                	 * PreCondition:    chn	- valid DMA channel
1709:                	 *
1710:                	 * Input:	    chn		- DMA channel number
1711:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1712:                	 * 						- chPri: channel priority 0-3
1713:                	 * 						- autoEn: enable/disable the automatic mode
1714:                	 * 						- chainEn: enable/disable channel chaining
1715:                	 * 						- detectEn: enable/disable events detection when channel disabled
1716:                	 * 						- chEn: enable/disable channel functionality
1717:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1718:                	 * 					or any of the DmaChnCtrlFlags flags:
1719:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1720:                	 *
1721:                	 * Output:          None
1722:                	 *
1723:                	 * Side Effects:    None
1724:                	 *
1725:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1726:                	 * 					the channel priority, chaining mode or auto and events detection.
1727:                	 *
1728:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1729:                	 *
1730:                	 * Example:         either:
1731:                	 *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1732:                	 *                  or:
1733:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1734:                	 * 			DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1735:                	 *
1736:                	 ********************************************************************/
1737:                	#define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1738:                
1739:                	/*********************************************************************
1740:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1741:                	 *
1742:                	 * PreCondition:    chn	- valid DMA channel
1743:                	 *
1744:                	 * Input:			chn			- DMA channel number
1745:                	 *
1746:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1747:                	 * 							- chPri: channel priority 0-3
1748:                	 * 							- autoEn: enable/disable the automatic mode
1749:                	 * 							- chainEn: enable/disable channel chaining
1750:                	 * 							- detectEn: enable/disable events detection when channel disabled
1751:                	 * 							- chEn: enable/disable channel functionality
1752:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1753:                	 *						or any of the DmaChnCtrlFlags flags:
1754:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1755:                	 *
1756:                	 * Side Effects:    None
1757:                	 *
1758:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1759:                	 * 					including the channel enable/disable status, the channel priority,
1760:                	 * 					chaining mode, auto mode and events detection.
1761:                	 *
1762:                	 * Note:            None.
1763:                	 *
1764:                	 * Example:			either:
1765:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1766:                	 * 					or:
1767:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1768:                	 *
1769:                	 ********************************************************************/
1770:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1771:                
1772:                
1773:                	/*********************************************************************
1774:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1775:                	 *
1776:                	 * PreCondition:    chn	- valid DMA channel
1777:                	 *
1778:                	 * Input:			chn		- DMA channel number
1779:                	 *
1780:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1781:                	 *
1782:                	 * Side Effects:    None
1783:                	 *
1784:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1785:                	 *
1786:                	 * Note:            None.
1787:                	 *
1788:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1789:                	 *
1790:                	 ********************************************************************/
1791:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1792:                
1793:                	/*********************************************************************
1794:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1795:                	 *
1796:                	 * PreCondition:    chn		- valid DMA channel
1797:                	 * 					pTxCtrl	- valid pointer
1798:                	 *
1799:                	 * Input:			chn			- DMA channel number
1800:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1801:                	 * 								- vSrcAdd: source of the DMA transfer
1802:                	 * 								- vDstAdd: destination of the DMA transfer
1803:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1804:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1805:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1806:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1807:                	 *
1808:                	 * Output:          None
1809:                	 *
1810:                	 * Side Effects:    None
1811:                	 *
1812:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1813:                	 * 					the source and the destination addresses.
1814:                	 * 					It also retrieves the source and destination lengths
1815:                	 * 					and the number of bytes	transferred per event.
1816:                	 *
1817:                	 * Note:            None
1818:                	 *
1819:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1820:                	 ********************************************************************/
1821:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1822:                
1823:                	// Low level checksum functions
1824:                
1825:                	/*********************************************************************
1826:                	 * Function:        void DmaSfmEnable(int enable)
1827:                	 *
1828:                	 * PreCondition:    None
1829:                	 *
1830:                	 * Input:           enable _ boolean to enable/disable the SFM functionality
1831:                	 *
1832:                	 * Output:          None
1833:                	 *
1834:                	 * Side Effects:    None
1835:                	 *
1836:                	 * Overview:        The function enables/diables the checksum module functionality.
1837:                	 *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1838:                	 *
1839:                	 * Note:            The SFM module should be properly configured before enabled.
1840:                	 *
1841:                	 * Example:         DmaSfmEnable(1);
1842:                	 ********************************************************************/
1843:                	extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1844:                	{
1845:                		if(enable)
1846:                		{
1847:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1848:                		}
1849:                		else
1850:                		{
1851:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1852:                		}
1853:                	}
1854:                	#define DmaCrcEnable	DmaSfmEnable		// PIC32_3xx backward compatibility
1855:                
1856:                
1857:                	/*********************************************************************
1858:                	 * Function:        int DmaSfmGetEnable(void)
1859:                	 *
1860:                	 * PreCondition:    None
1861:                	 *
1862:                	 * Input:			None
1863:                	 *
1864:                	 * Output:          TRUE, if the SFM module is enabled
1865:                	 * 		    FALSE otherwise
1866:                	 *
1867:                	 * Side Effects:    None
1868:                	 *
1869:                	 * Overview:		The function returns the SFM module enabling status.
1870:                	 *
1871:                	 * Note:            None
1872:                	 *
1873:                	 * Example:	    int isSfmEnabled=DmaSfmGetEnable();
1874:                	 ********************************************************************/
1875:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1876:                	{
1877:                		return DCRCCONbits.CRCEN!=0;
1878:                	}
1879:                	#define		DmaCrcGetEnable 	DmaSfmGetEnable		// PIC32_3xx backward compatibility
1880:                
1881:                
1882:                	/*********************************************************************
1883:                	 * Function:        void DmaSfmAppendEnable(int enable)
1884:                	 *
1885:                	 * PreCondition:    None
1886:                	 *
1887:                	 * Input:           enable _ boolean to enable/disable the SFM append mode
1888:                	 *
1889:                	 * Output:          None
1890:                	 *
1891:                	 * Side Effects:    None
1892:                	 *
1893:                	 * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1894:                	 *                  the source data but does not write it to the destination address. The data it's just passed
1895:                	 *                  to the checksum generator for CRC/IP checksum calculation.
1896:                	 *                  When the block transfer is completed, the checksum result is written to the
1897:                	 *                  DMA channel destination address.
1898:                	 *
1899:                	 * Note:            The SFM module should be properly configured before enabled.
1900:                	 *
1901:                	 * Example:         DmaSfmAppendModeEnable(TRUE);
1902:                	 ********************************************************************/
1903:                	extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1904:                	{
1905:                		if(enable)
1906:                		{
1907:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1908:                		}
1909:                		else
1910:                		{
1911:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1912:                		}
1913:                	}
1914:                	#define		DmaCrcAppendModeEnable	DmaSfmAppendEnable	// PIC32_3xx backward compatibility
1915:                
1916:                
1917:                	/*********************************************************************
1918:                	 * Function:        int DmaSfmGetAppendMode(void)
1919:                	 *
1920:                	 * PreCondition:    None
1921:                	 *
1922:                	 * Input:           None
1923:                	 *
1924:                	 * Output:          TRUE, if the SFM append mode is enabled
1925:                	 *                  FALSE otherwise
1926:                	 *
1927:                	 * Side Effects:    None
1928:                	 *
1929:                	 * Overview:        The function returns the SFM module enabling status.
1930:                	 *
1931:                	 * Note:            None
1932:                	 *
1933:                	 * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1934:                	 ********************************************************************/
1935:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1936:                	{
1937:                		return DCRCCONbits.CRCAPP!=0;
1938:                	}
1939:                	#define	DmaCrcGetAppendMode	DmaSfmGetAppendMode		// PIC32_3xx backward compatibility
1940:                
1941:                
1942:                	/*********************************************************************
1943:                	 * Function:        void DmaSfmSetAttach(DmaChannel chn)
1944:                	 *
1945:                	 * PreCondition:    chn		- valid DMA channel
1946:                	 *
1947:                	 * Input:           chn	- the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1948:                	 *
1949:                	 * Output:          None
1950:                	 *
1951:                	 * Side Effects:    None
1952:                	 *
1953:                	 * Overview:        The function directly attaches a DMA channel to the SFM module.
1954:                	 *
1955:                	 * Note:            None
1956:                	 *
1957:                	 * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1958:                	 ********************************************************************/
1959:                	extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1960:                	{
1961:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1962:                		DCRCCONSET=chn;
1963:                	}
1964:                	#define		DmaCrcSetAttach		DmaSfmSetAttach		// PIC32_3xx backward compatibility
1965:                
1966:                
1967:                	/*********************************************************************
1968:                	 * Function:        DmaChannel DmaSfmGetAttach(void)
1969:                	 *
1970:                	 * PreCondition:    None
1971:                	 *
1972:                	 * Input:           None
1973:                	 *
1974:                	 * Output:          the DMA channel that is currently attached to the CRC module
1975:                	 *
1976:                	 * Side Effects:    None
1977:                	 *
1978:                	 * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1979:                	 *
1980:                	 * Note:            None
1981:                	 *
1982:                	 * Example:         DmaChannel chn=DmaSfmGetAttach();
1983:                	 ********************************************************************/
1984:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1985:                	{
1986:                		return (DmaChannel)DCRCCONbits.CRCCH;
1987:                	}
1988:                	#define		DmaCrcGetAttach		DmaSfmGetAttach		// PIC32_3xx backward compatibility
1989:                
1990:                	/*********************************************************************
1991:                	 * Function:        void DmaCrcSetPLen(int pLen)
1992:                	 *
1993:                	 * PreCondition:    pLen - valid polynomial length within 1-32
1994:                	 *
1995:                	 * Input:           pLen	- the length of the CRC generator polynomial
1996:                	 *
1997:                	 * Output:          None
1998:                	 *
1999:                	 * Side Effects:    None
2000:                	 *
2001:                	 * Overview:        The length of the CRC generator polynomial is set as being pLen;
2002:                	 *
2003:                	 * Note:            None
2004:                	 *
2005:                	 * Example:         DmaCrcSetPLen(32);
2006:                	 ********************************************************************/
2007:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2008:                	{
2009:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
2010:                		DCRCCONSET=(pLen)-1;
2011:                	}
2012:                
2013:                	/*********************************************************************
2014:                	 * Function:        int DmaCrcGetPLen(void)
2015:                	 *
2016:                	 * PreCondition:    None
2017:                	 *
2018:                	 * Input:           None
2019:                	 *
2020:                	 * Output:          the length of the CRC generator polynomial
2021:                	 *
2022:                	 * Side Effects:    None
2023:                	 *
2024:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
2025:                	 *                  It's always a number between 1 and 32.
2026:                	 *
2027:                	 * Note:            None
2028:                	 *
2029:                	 * Example:         int polyLen=DmaCrcGetPLen();
2030:                	 ********************************************************************/
2031:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2032:                	{
2033:                		return	DCRCCONbits.PLEN+1; 
2034:                	}
2035:                
2036:                	/*********************************************************************
2037:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2038:                	 *
2039:                	 * PreCondition:    None
2040:                	 *
2041:                	 * Input:           feedback - the layout of the CRC generator
2042:                	 *
2043:                	 * Output:          None
2044:                	 *
2045:                	 * Side Effects:    None
2046:                	 *
2047:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2048:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2049:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2050:                	 *
2051:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2052:                	 *
2053:                	 * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2054:                	 ********************************************************************/
2055:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2056:                	{
2057:                		DCRCXOR=feedback;
2058:                	}
2059:                
2060:                
2061:                	/*********************************************************************
2062:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2063:                	 *
2064:                	 * PreCondition:    None
2065:                	 *
2066:                	 * Input:           None
2067:                	 *
2068:                	 * Output:          the current layout of the CRC generator
2069:                	 *
2070:                	 * Side Effects:    None
2071:                	 *
2072:                	 * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2073:                	 *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2074:                	 *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2075:                	 *
2076:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2077:                	 *
2078:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
2079:                	 ********************************************************************/
2080:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2081:                	{
2082:                		return DCRCXOR;
2083:                	}
2084:                
2085:                
2086:                
2087:                	// Channel test/debug and special functions
2088:                
2089:                	/*********************************************************************
2090:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2091:                	 *
2092:                	 * PreCondition:    chn	- valid DMA channel
2093:                	 *
2094:                	 * Input:			chn		- DMA channel number
2095:                	 * 					eFlags	- event flags with the following significance:
2096:                	 * 								- DMA_EV_ERR: address error event
2097:                	 * 								- DMA_EV_ABORT: transfer abort event
2098:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2099:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2100:                	 * 								- DMA_EV_DST_HALF: destination half event
2101:                	 * 								- DMA_EV_DST_FULL: destination full event
2102:                	 * 								- DMA_EV_SRC_HALF: source half event
2103:                	 * 								- DMA_EV_SRC_FULL: source full event
2104:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2105:                	 *
2106:                	 * Output:          None
2107:                	 *
2108:                	 * Side Effects:    None
2109:                	 *
2110:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2111:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2112:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2113:                	 *
2114:                	 * Note:            This is intended as a channel test function.
2115:                	 *
2116:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2117:                	 ********************************************************************/
2118:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2119:                
2120:                	/*********************************************************************
2121:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2122:                	 *
2123:                	 * PreCondition:    chn	- valid DMA channel
2124:                	 *
2125:                	 * Input:			chn		- DMA channel number
2126:                	 * 					eFlags	- event flags with the following significance:
2127:                	 * 								- DMA_EV_ERR: address error event
2128:                	 * 								- DMA_EV_ABORT: transfer abort event
2129:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2130:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2131:                	 * 								- DMA_EV_DST_HALF: destination half event
2132:                	 * 								- DMA_EV_DST_FULL: destination full event
2133:                	 * 								- DMA_EV_SRC_HALF: source half event
2134:                	 * 								- DMA_EV_SRC_FULL: source full event
2135:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2136:                	 *
2137:                	 * Output:          None
2138:                	 *
2139:                	 * Side Effects:    None
2140:                	 *
2141:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2142:                	 * 					The channel event flags are forced to the eFlags value.
2143:                	 *
2144:                	 * Note:            This is intended as a channel test function.
2145:                	 *
2146:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2147:                	 ********************************************************************/
2148:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2149:                
2150:                
2151:                	/********************************************************************
2152:                	 * Include legacy DMA functions
2153:                	 * New projects should not use them!
2154:                	 * Note that interrupt functions are no longer provided.
2155:                	 * The functions in the int.h should be used instead.
2156:                	 ********************************************************************/
2157:                	#ifndef _PLIB_DISABLE_LEGACY
2158:                		#include <peripheral/legacy/dma_legacy.h>
2159:                	#endif
2160:                
2161:                
2162:                #else
2163:                	#undef _DMA_CHANNELS		// no DMA channels
2164:                #endif	// _DMAC0
2165:                
2166:                #endif /*_DMA_H_*/
2167:                
2168:                
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/tick.c  ---------------------------------------
1:                   /******************************************************************************/
2:                   /*                                                                            */
3:                   /* File:   tick.c                                                             */
4:                   /* Author: Matt Bennett                                                       */
5:                   /*                                                                            */
6:                   /* Created on June 13, 2012                                                   */
7:                   /*                                                                            */
8:                   /******************************************************************************/
9:                   
10:                  
11:                  #include <common.h>
12:                  #include <peripheral/timer.h>
13:                  #include <tick.h>
14:                  
15:                  /******************************************************************************/
16:                  /* there are 31536000 seconds in a year. With a 64 bit ms counter, it will    */
17:                  /* take 584 million years for the counter to roll over.                       */
18:                  /******************************************************************************/
19:                  
20:                  TICK_TYPE tick;
21:                  
22:                  /******************************************************************************/
23:                  /* timer interrupt, provides an independent clock for real-time timing        */
24:                  /* purposes                                                                   */
25:                  /******************************************************************************/
26:                  
27:                  void __ISR(_TIMER_4_VECTOR,TICK_INT_PRIORITY_ISR) T4_Interrupt_Handler(void)
28:                  {
9D005220  415DE800   RDPGPR SP, SP
9D005224  401A7000   MFC0 K0, EPC
9D005228  401B6000   MFC0 K1, Status
9D00522C  27BDFF88   ADDIU SP, SP, -120
9D005230  AFBA0074   SW K0, 116(SP)
9D005234  401A6002   MFC0 K0, SRSCtl
9D005238  AFBB0070   SW K1, 112(SP)
9D00523C  AFBA006C   SW K0, 108(SP)
9D005240  7C1B7844   INS K1, ZERO, 1, 15
9D005244  377B1800   ORI K1, K1, 6144
9D005248  409B6000   MTC0 K1, Status
9D00524C  AFBF005C   SW RA, 92(SP)
9D005250  AFBE0058   SW S8, 88(SP)
9D005254  AFB90054   SW T9, 84(SP)
9D005258  AFB80050   SW T8, 80(SP)
9D00525C  AFAF004C   SW T7, 76(SP)
9D005260  AFAE0048   SW T6, 72(SP)
9D005264  AFAD0044   SW T5, 68(SP)
9D005268  AFAC0040   SW T4, 64(SP)
9D00526C  AFAB003C   SW T3, 60(SP)
9D005270  AFAA0038   SW T2, 56(SP)
9D005274  AFA90034   SW T1, 52(SP)
9D005278  AFA80030   SW T0, 48(SP)
9D00527C  AFA7002C   SW A3, 44(SP)
9D005280  AFA60028   SW A2, 40(SP)
9D005284  AFA50024   SW A1, 36(SP)
9D005288  AFA40020   SW A0, 32(SP)
9D00528C  AFA3001C   SW V1, 28(SP)
9D005290  AFA20018   SW V0, 24(SP)
9D005294  AFA10014   SW AT, 20(SP)
9D005298  00001012   MFLO V0, 0
9D00529C  AFA20064   SW V0, 100(SP)
9D0052A0  00001810   MFHI V1, 0
9D0052A4  AFA30060   SW V1, 96(SP)
9D0052A8  03A0F021   ADDU S8, SP, ZERO
29:                      INTClearFlag(INT_SOURCE_TIMER(TICK_TIMER));
9D0052AC  2404000B   ADDIU A0, ZERO, 11
9D0052B0  0F4017B8   JAL INTClearFlag
9D0052B4  00000000   NOP
30:                      tick++;
9D0052B8  8F848038   LW A0, -32712(GP)
9D0052BC  8F85803C   LW A1, -32708(GP)
9D0052C0  24060001   ADDIU A2, ZERO, 1
9D0052C4  00003821   ADDU A3, ZERO, ZERO
9D0052C8  00861021   ADDU V0, A0, A2
9D0052CC  0044402B   SLTU T0, V0, A0
9D0052D0  00A71821   ADDU V1, A1, A3
9D0052D4  01032021   ADDU A0, T0, V1
9D0052D8  00801821   ADDU V1, A0, ZERO
9D0052DC  AF828038   SW V0, -32712(GP)
9D0052E0  AF83803C   SW V1, -32708(GP)
31:                  }
9D0052E4  03C0E821   ADDU SP, S8, ZERO
9D0052E8  8FA20064   LW V0, 100(SP)
9D0052EC  00400013   MTLO V0, 0
9D0052F0  8FA30060   LW V1, 96(SP)
9D0052F4  00600011   MTHI V1, 0
9D0052F8  8FBF005C   LW RA, 92(SP)
9D0052FC  8FBE0058   LW S8, 88(SP)
9D005300  8FB90054   LW T9, 84(SP)
9D005304  8FB80050   LW T8, 80(SP)
9D005308  8FAF004C   LW T7, 76(SP)
9D00530C  8FAE0048   LW T6, 72(SP)
9D005310  8FAD0044   LW T5, 68(SP)
9D005314  8FAC0040   LW T4, 64(SP)
9D005318  8FAB003C   LW T3, 60(SP)
9D00531C  8FAA0038   LW T2, 56(SP)
9D005320  8FA90034   LW T1, 52(SP)
9D005324  8FA80030   LW T0, 48(SP)
9D005328  8FA7002C   LW A3, 44(SP)
9D00532C  8FA60028   LW A2, 40(SP)
9D005330  8FA50024   LW A1, 36(SP)
9D005334  8FA40020   LW A0, 32(SP)
9D005338  8FA3001C   LW V1, 28(SP)
9D00533C  8FA20018   LW V0, 24(SP)
9D005340  8FA10014   LW AT, 20(SP)
9D005344  41606000   DI ZERO
9D005348  000000C0   EHB
9D00534C  8FBA0074   LW K0, 116(SP)
9D005350  8FBB0070   LW K1, 112(SP)
9D005354  409A7000   MTC0 K0, EPC
9D005358  8FBA006C   LW K0, 108(SP)
9D00535C  27BD0078   ADDIU SP, SP, 120
9D005360  409A6002   MTC0 K0, SRSCtl
9D005364  41DDE800   WRPGPR SP, SP
9D005368  409B6000   MTC0 K1, Status
9D00536C  42000018   ERET
32:                  
33:                  /******************************************************************************/
34:                  /* UINT64 TickGet(void)                                                       */
35:                  /* interrupt safe accessor function for the tick variable                     */
36:                  /******************************************************************************/
37:                  
38:                  TICK_TYPE TickGet(void)
39:                  {
9D005370  27BDFFE0   ADDIU SP, SP, -32
9D005374  AFBF001C   SW RA, 28(SP)
9D005378  AFBE0018   SW S8, 24(SP)
9D00537C  03A0F021   ADDU S8, SP, ZERO
40:                      TICK_TYPE returnValue;
41:                      INTEnable(INT_SOURCE_TIMER(TICK_TIMER),INT_DISABLED);
9D005380  2404000B   ADDIU A0, ZERO, 11
9D005384  00002821   ADDU A1, ZERO, ZERO
9D005388  0F4016DD   JAL INTEnable
9D00538C  00000000   NOP
42:                      returnValue=tick;
9D005390  8F828038   LW V0, -32712(GP)
9D005394  8F83803C   LW V1, -32708(GP)
9D005398  AFC20010   SW V0, 16(S8)
9D00539C  AFC30014   SW V1, 20(S8)
43:                      INTEnable(INT_SOURCE_TIMER(TICK_TIMER),INT_ENABLED);
9D0053A0  2404000B   ADDIU A0, ZERO, 11
9D0053A4  24050001   ADDIU A1, ZERO, 1
9D0053A8  0F4016DD   JAL INTEnable
9D0053AC  00000000   NOP
44:                      return returnValue;
9D0053B0  8FC20010   LW V0, 16(S8)
9D0053B4  8FC30014   LW V1, 20(S8)
45:                  }
9D0053B8  03C0E821   ADDU SP, S8, ZERO
9D0053BC  8FBF001C   LW RA, 28(SP)
9D0053C0  8FBE0018   LW S8, 24(SP)
9D0053C4  27BD0020   ADDIU SP, SP, 32
9D0053C8  03E00008   JR RA
9D0053CC  00000000   NOP
46:                  
47:                  /******************************************************************************/
48:                  /* void TickInitialize(void)                                                  */
49:                  /******************************************************************************/
50:                  
51:                  void TickInitialize(void)
52:                  {
9D0053D0  27BDFFE8   ADDIU SP, SP, -24
9D0053D4  AFBF0014   SW RA, 20(SP)
9D0053D8  AFBE0010   SW S8, 16(SP)
9D0053DC  03A0F021   ADDU S8, SP, ZERO
53:                      OpenTimer4(
9D0053E0  3C02BF80   LUI V0, -16512
9D0053E4  24030010   ADDIU V1, ZERO, 16
9D0053E8  AC430C00   SW V1, 3072(V0)
9D0053EC  3C02BF80   LUI V0, -16512
9D0053F0  AC400C10   SW ZERO, 3088(V0)
9D0053F4  3C02BF80   LUI V0, -16512
9D0053F8  24032710   ADDIU V1, ZERO, 10000
9D0053FC  AC430C20   SW V1, 3104(V0)
9D005400  3C02BF80   LUI V0, -16512
9D005404  34038000   ORI V1, ZERO, -32768
9D005408  AC430C08   SW V1, 3080(V0)
54:                          T4_ON|
55:                          T4_IDLE_CON|
56:                          T4_GATE_OFF|
57:                          TICK_PRESCALER|
58:                          T4_32BIT_MODE_OFF|
59:                          T4_SOURCE_INT,
60:                          TICK_UPDATE_INTERVAL);
61:                      TMR4=0;
9D00540C  3C02BF80   LUI V0, -16512
9D005410  AC400C10   SW ZERO, 3088(V0)
62:                      tick=0;
9D005414  00001021   ADDU V0, ZERO, ZERO
9D005418  00001821   ADDU V1, ZERO, ZERO
9D00541C  AF828038   SW V0, -32712(GP)
9D005420  AF83803C   SW V1, -32708(GP)
63:                      //mTickClearInterruptFlag();
64:                      INTClearFlag(INT_SOURCE_TIMER(TICK_TIMER));
9D005424  2404000B   ADDIU A0, ZERO, 11
9D005428  0F4017B8   JAL INTClearFlag
9D00542C  00000000   NOP
65:                      INTSetVectorPriority(INT_VECTOR_TIMER(TICK_TIMER),TICK_INT_PRIORITY);
9D005430  2404000B   ADDIU A0, ZERO, 11
9D005434  24050006   ADDIU A1, ZERO, 6
9D005438  0F401753   JAL INTSetVectorPriority
9D00543C  00000000   NOP
66:                      INTSetVectorSubPriority(INT_VECTOR_I2C(TICK_TIMER),TICK_INT_SUB_PRIORITY);
9D005440  24040024   ADDIU A0, ZERO, 36
9D005444  24050002   ADDIU A1, ZERO, 2
9D005448  0F401761   JAL INTSetVectorSubPriority
9D00544C  00000000   NOP
67:                      INTEnable(INT_SOURCE_TIMER(TICK_TIMER),INT_ENABLED);
9D005450  2404000B   ADDIU A0, ZERO, 11
9D005454  24050001   ADDIU A1, ZERO, 1
9D005458  0F4016DD   JAL INTEnable
9D00545C  00000000   NOP
68:                      //ConfigIntTimer4(T4_INT_ON | TICK_INT_PRIORITY | T4_INT_SUB_PRIOR_1);
69:                  }
9D005460  03C0E821   ADDU SP, S8, ZERO
9D005464  8FBF0014   LW RA, 20(SP)
9D005468  8FBE0010   LW S8, 16(SP)
9D00546C  27BD0018   ADDIU SP, SP, 24
9D005470  03E00008   JR RA
9D005474  00000000   NOP
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/mainv1p0.c  -----------------------------------
1:                   /******************************************************************************/
2:                   /* File:   mainv1p0.c                                                         */
3:                   /* Author: Matt Bennett                                                       */
4:                   /*                                                                            */
5:                   /* Created on December 16, 2012, 3:51 PM                                      */
6:                   /* Updated August 2013                                                        */
7:                   /******************************************************************************/
8:                   
9:                   #include <common.h>
10:                  #include <system.h>
11:                  #include <osc.h>
12:                  #include <tick.h>
13:                  #include <LED.h>
14:                  #include <PAC1710.h>
15:                  #include <MCP4461.h>
16:                  #include <I2C_Bus_Master.h>
17:                  #include <TRISThis.h>
18:                  #include <configuration.h>
19:                  #include <mainv1p0.h>
20:                  
21:                  /******************************************************************************/
22:                  extern UINT16_VAL currentHolding;
23:                  extern UINT16_VAL voltageHolding;
24:                  /* file scope for DMCI */
25:                  INT16 monitorCurrentReadings[CURRENT_HISTORY_SIZE];
26:                  UINT16 monitorVoltageReadings[VOLTAGE_HISTORY_SIZE];
27:                  
28:                  /******************************************************************************/
29:                  
30:                  int main(void)
31:                  {
9D0045E8  27BDFFC0   ADDIU SP, SP, -64
9D0045EC  AFBF003C   SW RA, 60(SP)
9D0045F0  AFBE0038   SW S8, 56(SP)
9D0045F4  03A0F021   ADDU S8, SP, ZERO
32:                      /* variables local to main()                                              */
33:                      UINT8 dataRead;
34:                      TICK_TYPE timeoutTime;
35:                      I2CBUS_COMMAND_TYPE command;
36:                      UINT16_VAL vSource;
37:                      //INT16 readingHoldingSigned;
38:                      //UINT16 readingHoldingUnsigned;
39:                      /* local to main() and initialized*/
40:                      //int currentIndex=0;
41:                      //int voltageIndex=0;
42:                      #ifdef USE_DIGIPOT
43:                          BOOL digipotGet=TRUE;
9D0045F8  24020001   ADDIU V0, ZERO, 1
9D0045FC  0F4011FC   JAL InitializeSystem
44:                      #endif
45:                      /**************************************************************************/
46:                      InitializeSystem();
9D004600  AFC20010   SW V0, 16(S8)
47:                      if(!MasterI2CStartup())
9D004604  0F40031D   JAL MasterI2CStartup
9D004608  00000000   NOP
9D00460C  1440001B   BNE V0, ZERO, 0x9D00467C
9D004610  00000000   NOP
48:                      {
49:                          LED1_ON;
9D004614  3C02BF88   LUI V0, -16504
9D004618  24034000   ADDIU V1, ZERO, 16384
9D00461C  AC4360E4   SW V1, 24804(V0)
50:                          LED2_OFF;
9D004620  3C02BF88   LUI V0, -16504
9D004624  34038000   ORI V1, ZERO, -32768
9D004628  AC4360E8   SW V1, 24808(V0)
51:                          LED3_ON;
9D00462C  3C02BF88   LUI V0, -16504
9D004630  24030010   ADDIU V1, ZERO, 16
9D004634  AC436164   SW V1, 24932(V0)
52:                          LED4_OFF;
9D004638  3C02BF88   LUI V0, -16504
9D00463C  24030020   ADDIU V1, ZERO, 32
9D004640  AC436168   SW V1, 24936(V0)
53:                          LED5_ON;
9D004644  3C02BF88   LUI V0, -16504
9D004648  24030008   ADDIU V1, ZERO, 8
9D00464C  AC436164   SW V1, 24932(V0)
54:                          LED6_OFF;
9D004650  3C02BF88   LUI V0, -16504
9D004654  24030004   ADDIU V1, ZERO, 4
9D004658  AC436168   SW V1, 24936(V0)
55:                          LED7_ON;
9D00465C  3C02BF88   LUI V0, -16504
9D004660  24030100   ADDIU V1, ZERO, 256
9D004664  AC436164   SW V1, 24932(V0)
56:                          LED8_OFF;
9D004668  3C02BF88   LUI V0, -16504
9D00466C  24032000   ADDIU V1, ZERO, 8192
9D004670  AC4360E8   SW V1, 24808(V0)
57:                          while(TRUE);
9D004674  0B40119D   J 0x9D004674
9D004678  00000000   NOP
58:                      }
59:                      if(!PAC1710SubsystemInitialize(PAC1710_ADDRESS))
9D00467C  0F400524   JAL PAC1710SubsystemInitialize
9D004680  24040030   ADDIU A0, ZERO, 48
9D004684  1440001B   BNE V0, ZERO, 0x9D0046F4
9D004688  00000000   NOP
60:                      {
61:                          LED1_ON;
9D00468C  3C02BF88   LUI V0, -16504
9D004690  24034000   ADDIU V1, ZERO, 16384
9D004694  AC4360E4   SW V1, 24804(V0)
62:                          LED2_OFF;
9D004698  3C02BF88   LUI V0, -16504
9D00469C  34038000   ORI V1, ZERO, -32768
9D0046A0  AC4360E8   SW V1, 24808(V0)
63:                          LED3_ON;
9D0046A4  3C02BF88   LUI V0, -16504
9D0046A8  24030010   ADDIU V1, ZERO, 16
9D0046AC  AC436164   SW V1, 24932(V0)
64:                          LED4_OFF;
9D0046B0  3C02BF88   LUI V0, -16504
9D0046B4  24030020   ADDIU V1, ZERO, 32
9D0046B8  AC436168   SW V1, 24936(V0)
65:                          LED5_ON;
9D0046BC  3C02BF88   LUI V0, -16504
9D0046C0  24030008   ADDIU V1, ZERO, 8
9D0046C4  AC436164   SW V1, 24932(V0)
66:                          LED6_OFF;
9D0046C8  3C02BF88   LUI V0, -16504
9D0046CC  24030004   ADDIU V1, ZERO, 4
9D0046D0  AC436168   SW V1, 24936(V0)
67:                          LED7_ON;
9D0046D4  3C02BF88   LUI V0, -16504
9D0046D8  24030100   ADDIU V1, ZERO, 256
9D0046DC  AC436164   SW V1, 24932(V0)
68:                          LED8_OFF;
9D0046E0  3C02BF88   LUI V0, -16504
9D0046E4  24032000   ADDIU V1, ZERO, 8192
9D0046E8  AC4360E8   SW V1, 24808(V0)
69:                          while(TRUE);
9D0046EC  0B4011BB   J 0x9D0046EC
9D0046F0  00000000   NOP
70:                      }
71:                      #ifdef USE_DIGIPOT
72:                      DigipotSubsystemInitialize();
9D0046F4  0F400E00   JAL DigipotSubsystemInitialize
9D0046F8  00000000   NOP
73:                      #endif
74:                      if(!ConfigSPIComms())
9D0046FC  0F4008BF   JAL ConfigSPIComms
9D004700  00000000   NOP
9D004704  14400003   BNE V0, ZERO, 0x9D004714
9D004708  00000000   NOP
75:                      {
76:                          while(TRUE);
9D00470C  0B4011C3   J 0x9D00470C
9D004710  00000000   NOP
77:                      }
78:                      TRISThisConfigure();
9D004714  0F400B10   JAL TRISThisConfigure
9D004718  00000000   NOP
9D00471C  0B4011CD   J 0x9D004734
9D004720  00000000   NOP
79:                      
80:                      mEnableWatchdog();
81:                  
82:                      while(TRUE)
83:                      {
84:                          mClearWatchdog();
85:                          DoTRISThis();
9D004734  0F400C59   JAL DoTRISThis
9D004738  00000000   NOP
86:                          DoPowerMonState();
9D00473C  0F4006AF   JAL DoPowerMonState
9D004740  00000000   NOP
87:                          DoLEDs();
9D004744  0F4013DE   JAL DoLEDs
9D004748  00000000   NOP
88:                          #ifdef USE_DIGIPOT
89:                          DoDigipot();
9D00474C  0F400E2B   JAL DoDigipot
9D004750  00000000   NOP
90:                          //DigipotStartReadingAll();
91:                          if(digipotGet)
9D004754  8FC20010   LW V0, 16(S8)
9D004758  10400007   BEQ V0, ZERO, 0x9D004778
9D00475C  00000000   NOP
92:                          {
93:                              if(DigipotStartGetStatus())
9D004760  0F400D60   JAL DigipotStartGetStatus
9D004764  00000000   NOP
9D004768  1040FFEE   BEQ V0, ZERO, 0x9D004724
9D00476C  00000000   NOP
94:                              {
95:                                  digipotGet=FALSE;
9D004770  0B4011CD   J 0x9D004734
96:                              }
97:                          }
98:                          else
99:                          {
100:                             if(DigipotReadingReady())
9D004778  0F400DAB   JAL DigipotReadingReady
9D00477C  00000000   NOP
9D004780  1040FFEB   BEQ V0, ZERO, 0x9D004730
9D004784  00000000   NOP
101:                             {
102:                                 UINT8 reading;
103:                                 reading=DigipotGetStatus();
9D004788  0F400D78   JAL DigipotGetStatus
9D00478C  00000000   NOP
9D004790  A3C20014   SB V0, 20(S8)
104:                                 Nop();
9D004794  00000040   SSNOP
105:                                 Nop();
9D004798  00000040   SSNOP
106:                                 Nop();
9D00479C  00000040   SSNOP
107:                                 Nop();
9D0047A0  00000040   SSNOP
108:                                 Nop();
9D0047A4  00000040   SSNOP
109:                                 //if(DigipotGetReading(0,&reading))
110:                                 //{
111:                                 //    Nop();
112:                                 //}
113:                                 //else
114:                                 //{
115:                                 //    Nop();
116:                                 //}
117:                             }
118:                         }
119:                         #endif /* USE_DIGIPOT */
120:                 //        if(PAC1710GetData(PAC1710_DATA_CURRENT,&monitorCurrentReadings[currentIndex]))
121:                 //        {
122:                 //            currentIndex++;
123:                 //            currentIndex%=CURRENT_HISTORY_SIZE;
124:                 //        }
125:                 //        if(PAC1710GetData(PAC1710_DATA_VOLTAGE,&monitorVoltageReadings[voltageIndex]))
126:                 //        {
127:                 //            voltageIndex++;
128:                 //            voltageIndex%=VOLTAGE_HISTORY_SIZE;
129:                 //        }
130:                 //        if(GetCurrentData(PAC1710_ADDRESS,&readingHoldingSigned))
131:                 //        {
132:                 //            monitorCurrentReadings[currentIndex++]=readingHoldingSigned>>4;
133:                 //            if(currentIndex>=100)
134:                 //            {
135:                 //                currentIndex=0;
136:                 //            }
137:                 //        }
138:                 //        if(GetVoltageData(PAC1710_ADDRESS,&readingHoldingUnsigned))
139:                 //        {
140:                 //            monitorVoltageReadings[voltageIndex++]=readingHoldingUnsigned>>5;
141:                 //            if(voltageIndex>=100)
142:                 //            {
143:                 //                voltageIndex=0;
144:                 //            }
145:                 //        }
146:                     }
9D004724  00000000   NOP
9D004728  0B4011CD   J 0x9D004734
9D00472C  00000000   NOP
9D004730  00000000   NOP
9D004774  AFC00010   SW ZERO, 16(S8)
9D0047A8  0B4011CD   J 0x9D004734
9D0047AC  00000000   NOP
147:                 }
148:                 
149:                 void __attribute__ ((interrupt(IPL0SOFT))) _DefaultInterrupt(void)
150:                 {
9D0047B0  415DE800   RDPGPR SP, SP
9D0047B4  401A7000   MFC0 K0, EPC
9D0047B8  401B6000   MFC0 K1, Status
9D0047BC  27BDFFE8   ADDIU SP, SP, -24
9D0047C0  AFBA0014   SW K0, 20(SP)
9D0047C4  401A6002   MFC0 K0, SRSCtl
9D0047C8  AFBB0010   SW K1, 16(SP)
9D0047CC  AFBA000C   SW K0, 12(SP)
9D0047D0  7C1B7844   INS K1, ZERO, 1, 15
9D0047D4  377B0000   ORI K1, K1, 0
9D0047D8  409B6000   MTC0 K1, Status
9D0047DC  AFBE0004   SW S8, 4(SP)
9D0047E0  AFA30000   SW V1, 0(SP)
9D0047E4  03A0F021   ADDU S8, SP, ZERO
151:                     while(TRUE);
9D0047E8  0B4011FA   J 0x9D0047E8
9D0047EC  00000000   NOP
152:                 }
153:                 
154:                 void InitializeSystem(void)
155:                 {
9D0047F0  27BDFF80   ADDIU SP, SP, -128
9D0047F4  AFBF007C   SW RA, 124(SP)
9D0047F8  AFBE0078   SW S8, 120(SP)
9D0047FC  03A0F021   ADDU S8, SP, ZERO
156:                     /**************************************************************************/
157:                     /* Configure, enable the cache for the best performance                   */
158:                     OSCConfig(OSC_POSC_PLL,PLL_OUTPUT_MULT,PLL_OUTPUT_DIVIDER,0);
9D004800  24040300   ADDIU A0, ZERO, 768
9D004804  3C050005   LUI A1, 5
9D004808  00003021   ADDU A2, ZERO, ZERO
9D00480C  00003821   ADDU A3, ZERO, ZERO
9D004810  0F40151E   JAL OSCConfig
9D004814  00000000   NOP
9D004818  3C0204C4   LUI V0, 1220
9D00481C  3442B400   ORI V0, V0, -19456
9D004820  AFC20010   SW V0, 16(S8)
9D004824  24020005   ADDIU V0, ZERO, 5
9D004828  AFC20014   SW V0, 20(S8)
159:                     SYSTEMConfig(GetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
160:                     mOSCSetPBDIV(PBCLK_DIV);
161:                     /* Enable multiple interrupt vectors */
162:                     INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR);
9D004C18  00002021   ADDU A0, ZERO, ZERO
9D004C1C  0F40178A   JAL INTConfigureSystem
9D004C20  00000000   NOP
163:                     AD1PCFG=0xFFFF;
9D004C24  3C02BF81   LUI V0, -16511
9D004C28  3403FFFF   ORI V1, ZERO, -1
9D004C2C  AC439060   SW V1, -28576(V0)
164:                     P5V_POWER_GOOD_DIRECTION=TRIS_IN;
9D004C30  3C03BF88   LUI V1, -16504
9D004C34  8C626100   LW V0, 24832(V1)
9D004C38  24040001   ADDIU A0, ZERO, 1
9D004C3C  7C824A44   INS V0, A0, 9, 1
9D004C40  AC626100   SW V0, 24832(V1)
165:                     LEDInitialize();
9D004C44  0F40131D   JAL LEDInitialize
9D004C48  00000000   NOP
166:                     TickInitialize();
9D004C4C  0F4014F4   JAL TickInitialize
9D004C50  00000000   NOP
167:                     INTEnableInterrupts();
9D004C54  0F40182D   JAL INTEnableInterrupts
9D004C58  00000000   NOP
168:                 }
9D004C5C  03C0E821   ADDU SP, S8, ZERO
9D004C60  8FBF007C   LW RA, 124(SP)
9D004C64  8FBE0078   LW S8, 120(SP)
9D004C68  27BD0080   ADDIU SP, SP, 128
9D004C6C  03E00008   JR RA
9D004C70  00000000   NOP
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/general_exception_handler.c  ------------------
1:                   #include <common.h>
2:                   
3:                   typedef enum
4:                   {                       /******************************************************/
5:                   	EXCEP_IRQ = 0,	/* 0 - interrupt                                      */
6:                   	EXCEP_AdEL = 4,	/* 4 - address error exception (load or ifetch)       */
7:                   	EXCEP_AdES,	/* 5 - address error exception (store)                */
8:                   	EXCEP_IBE,	/* 6 - bus error (ifetch)                             */
9:                   	EXCEP_DBE,	/* 7 - bus error (load/store)                         */
10:                  	EXCEP_Sys,	/* 8 - syscall                                        */
11:                  	EXCEP_Bp,	/* 9 - breakpoint                                     */
12:                  	EXCEP_RI,	/* 10 - reserved instruction                          */
13:                  	EXCEP_CpU,	/* 11 - coprocessor unusable                          */
14:                  	EXCEP_Overflow,	/* 12 - arithmetic overflow                           */
15:                  	EXCEP_Trap,	/* 13 - trap (possible divide by zero)                */
16:                  	EXCEP_IS1 = 16,	/* 16 - implementation specfic                        */
17:                  	EXCEP_CEU,	/* 17 - CorExtend Unuseable                           */
18:                  	EXCEP_C2E	/* 18 - coprocessor 2                                 */
19:                  } _excep_code;          /******************************************************/
20:                  
21:                  /******************************************************************************/
22:                  /* void _general_exception_handler(unsigned int Cause, unsigned int Status)   */
23:                  /*                                                                            */
24:                  /* PreCondition:    None                                                      */
25:                  /*                                                                            */
26:                  /* Input:           None                                                      */
27:                  /*                                                                            */
28:                  /* Output:          None                                                      */
29:                  /*                                                                            */
30:                  /* Side Effects:    None                                                      */
31:                  /*                                                                            */
32:                  /*  Overview:       Overrides (weak) general exception handler provided by    */
33:                  /*                  C32. Uses C32 macros to read epc and cause registers.     */
34:                  /*                  Application code can then do something useful with them.  */
35:                  /*                                                                            */
36:                  /******************************************************************************/
37:                  
38:                  void __attribute__((naked, nomips16)) _general_exception_handler(UINT32 cause, UINT32 status)
39:                  {
9D005C58  AFC40018   SW A0, 24(S8)
9D005C5C  AFC5001C   SW A1, 28(S8)
40:                      UINT32 count=0;
9D005C60  AFC00000   SW ZERO, 0(S8)
41:                      UINT32 _epc=0;
9D005C64  AFC00004   SW ZERO, 4(S8)
42:                      UINT32 _status = 0;
9D005C68  AFC00008   SW ZERO, 8(S8)
43:                      _excep_code _cause = 0;
9D005C6C  AFC0000C   SW ZERO, 12(S8)
44:                  
45:                      _status = status;
9D005C70  8FC2001C   LW V0, 28(S8)
9D005C74  AFC20008   SW V0, 8(S8)
46:                      _cause = ((cause & 0x0000007C) >> 2);
9D005C78  8FC20018   LW V0, 24(S8)
9D005C7C  3042007C   ANDI V0, V0, 124
9D005C80  00021082   SRL V0, V0, 2
9D005C84  AFC2000C   SW V0, 12(S8)
47:                      _epc = _CP0_GET_EPC();
9D005C88  40027000   MFC0 V0, EPC
9D005C8C  AFC20004   SW V0, 4(S8)
48:                      while(TRUE)
49:                      {
50:                          Nop();
9D005C90  00000040   SSNOP
51:                      }
9D005C94  0B401724   J 0x9D005C90
9D005C98  00000000   NOP
52:                  } 
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/delay.c  --------------------------------------
1:                   /******************************************************************************/
2:                   /* File: delay.c                                                              */
3:                   /* Author: Matt Bennett                                                       */
4:                   /* Date: December 26, 2011                                                    */
5:                   /* Version: 0.9                                                               */
6:                   /*                                                                            */
7:                   /* Description: Functions to access a real time timer, derived from 'tick'    */
8:                   /*                                                                            */
9:                   /******************************************************************************/
10:                  
11:                  #include "common.h"
12:                  #include "tick.h"
13:                  #include "delay.h"
14:                  
15:                  /******************************************************************************/
16:                  /* DelayMs(int toWait)                                                        */
17:                  /*  wait between toWait and toWait+1 milliseconds. Added the +1 in there since*/
18:                  /*  we don't know where within the 'tick' this starts.                        */
19:                  /* NB: this is a blocking function!                                           */
20:                  /******************************************************************************/
21:                  #ifdef DELAY_USE_CORE_TIMER
22:                  
23:                  
24:                  void DelayUs(UINT32 delay_us)
25:                  {
9D005730  27BDFFE0   ADDIU SP, SP, -32
9D005734  AFBF001C   SW RA, 28(SP)
9D005738  AFBE0018   SW S8, 24(SP)
9D00573C  03A0F021   ADDU S8, SP, ZERO
9D005740  AFC40020   SW A0, 32(S8)
26:                      UINT32   DelayStartTime;
27:                      DelayStartTime = ReadCoreTimer();
9D005744  0F40182B   JAL ReadCoreTimer
9D005748  00000000   NOP
9D00574C  AFC20010   SW V0, 16(S8)
28:                      while((ReadCoreTimer() - DelayStartTime) < (delay_us * CORE_TIMER_MICROSECONDS));
9D005750  00000000   NOP
9D005754  0F40182B   JAL ReadCoreTimer
9D005758  00000000   NOP
9D00575C  00401821   ADDU V1, V0, ZERO
9D005760  8FC20010   LW V0, 16(S8)
9D005764  00621023   SUBU V0, V1, V0
9D005768  8FC40020   LW A0, 32(S8)
9D00576C  24030028   ADDIU V1, ZERO, 40
9D005770  70831802   MUL V1, A0, V1
9D005774  0043102B   SLTU V0, V0, V1
9D005778  1440FFF6   BNE V0, ZERO, 0x9D005754
9D00577C  00000000   NOP
29:                  }
9D005780  03C0E821   ADDU SP, S8, ZERO
9D005784  8FBF001C   LW RA, 28(SP)
9D005788  8FBE0018   LW S8, 24(SP)
9D00578C  27BD0020   ADDIU SP, SP, 32
9D005790  03E00008   JR RA
9D005794  00000000   NOP
30:                  
31:                  void DelayMs(UINT32 delay_ms)
32:                  {
9D005798  27BDFFE0   ADDIU SP, SP, -32
9D00579C  AFBF001C   SW RA, 28(SP)
9D0057A0  AFBE0018   SW S8, 24(SP)
9D0057A4  03A0F021   ADDU S8, SP, ZERO
9D0057A8  AFC40020   SW A0, 32(S8)
33:                      UINT32   DelayStartTime;
34:                      DelayStartTime = ReadCoreTimer();
9D0057AC  0F40182B   JAL ReadCoreTimer
9D0057B0  00000000   NOP
9D0057B4  AFC20010   SW V0, 16(S8)
35:                      while((ReadCoreTimer() - DelayStartTime) < (delay_ms * CORE_TIMER_MILLISECONDS));
9D0057B8  00000000   NOP
9D0057BC  0F40182B   JAL ReadCoreTimer
9D0057C0  00000000   NOP
9D0057C4  00401821   ADDU V1, V0, ZERO
9D0057C8  8FC20010   LW V0, 16(S8)
9D0057CC  00621023   SUBU V0, V1, V0
9D0057D0  8FC40020   LW A0, 32(S8)
9D0057D4  34039C40   ORI V1, ZERO, -25536
9D0057D8  70831802   MUL V1, A0, V1
9D0057DC  0043102B   SLTU V0, V0, V1
9D0057E0  1440FFF6   BNE V0, ZERO, 0x9D0057BC
9D0057E4  00000000   NOP
36:                  }
9D0057E8  03C0E821   ADDU SP, S8, ZERO
9D0057EC  8FBF001C   LW RA, 28(SP)
9D0057F0  8FBE0018   LW S8, 24(SP)
9D0057F4  27BD0020   ADDIU SP, SP, 32
9D0057F8  03E00008   JR RA
9D0057FC  00000000   NOP
37:                  
38:                  #else
39:                  
40:                  void DelayMS(int ms)
41:                  {
42:                      UINT64 when;
43:                      when=TickGet()+ms+1;
44:                      while(TickGet()<when);
45:                  }
46:                  
47:                  #endif
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/commsToRPi.c  ---------------------------------
1:                   /******************************************************************************/
2:                   /*                                                                            */
3:                   /* File:   commsToRPi.c                                                       */
4:                   /* Author: Matt Bennett                                                       */
5:                   /*                                                                            */
6:                   /* Created on January 30, 2013                                                */
7:                   /*                                                                            */
8:                   /******************************************************************************/
9:                   
10:                  #include <common.h>
11:                  #include <TRISThis.h>
12:                  #include <commsToRPi.h>
13:                  #include <peripheral/spi.h>
14:                  #include <peripheral/int.h>
15:                  
16:                  SPI_TYPE SPI;
17:                  extern TRISTHIS_DATA_TYPE TRISThisData;
18:                  
19:                  /******************************************************************************/
20:                  
21:                  BOOL SPIByteGet(UINT8 address, UINT8 *data)
22:                  {
9D0021F8  27BDFFF8   ADDIU SP, SP, -8
9D0021FC  AFBE0004   SW S8, 4(SP)
9D002200  03A0F021   ADDU S8, SP, ZERO
9D002204  00801021   ADDU V0, A0, ZERO
9D002208  AFC5000C   SW A1, 12(S8)
9D00220C  A3C20008   SB V0, 8(S8)
23:                      if(address>=sizeof(SPI.RXData))
9D002210  93C30008   LBU V1, 8(S8)
9D002214  240200FF   ADDIU V0, ZERO, 255
9D002218  14620004   BNE V1, V0, 0x9D00222C
9D00221C  00000000   NOP
24:                      {
25:                          return FALSE;
9D002220  00001021   ADDU V0, ZERO, ZERO
9D002224  0B400893   J 0x9D00224C
9D002228  00000000   NOP
26:                      }
27:                      else
28:                      {
29:                          *data=SPI.RXData[address];
9D00222C  93C30008   LBU V1, 8(S8)
9D002230  3C02A000   LUI V0, -24576
9D002234  24420430   ADDIU V0, V0, 1072
9D002238  00621021   ADDU V0, V1, V0
9D00223C  9043000C   LBU V1, 12(V0)
9D002240  8FC2000C   LW V0, 12(S8)
9D002244  A0430000   SB V1, 0(V0)
30:                          return TRUE;
9D002248  24020001   ADDIU V0, ZERO, 1
31:                      }
32:                  }
9D00224C  03C0E821   ADDU SP, S8, ZERO
9D002250  8FBE0004   LW S8, 4(SP)
9D002254  27BD0008   ADDIU SP, SP, 8
9D002258  03E00008   JR RA
9D00225C  00000000   NOP
33:                  
34:                  BOOL SPIWordGet(UINT8 address, UINT32 *data)
35:                  {
9D002260  27BDFFF8   ADDIU SP, SP, -8
9D002264  AFBE0004   SW S8, 4(SP)
9D002268  03A0F021   ADDU S8, SP, ZERO
9D00226C  00801021   ADDU V0, A0, ZERO
9D002270  AFC5000C   SW A1, 12(S8)
9D002274  A3C20008   SB V0, 8(S8)
36:                  
37:                  }
9D002278  03C0E821   ADDU SP, S8, ZERO
9D00227C  8FBE0004   LW S8, 4(SP)
9D002280  27BD0008   ADDIU SP, SP, 8
9D002284  03E00008   JR RA
9D002288  00000000   NOP
38:                  /******************************************************************************/
39:                  
40:                  BOOL SPIDataReady(void)
41:                  {
9D00228C  27BDFFE0   ADDIU SP, SP, -32
9D002290  AFBF001C   SW RA, 28(SP)
9D002294  AFBE0018   SW S8, 24(SP)
9D002298  03A0F021   ADDU S8, SP, ZERO
42:                      BOOL returnValue;
43:                      unsigned int statusTemp;
44:                      statusTemp = INTDisableInterrupts();
9D00229C  0F40182F   JAL INTDisableInterrupts
9D0022A0  00000000   NOP
9D0022A4  AFC20010   SW V0, 16(S8)
45:                      returnValue=SPI.status.RXDataReady;
9D0022A8  3C02A000   LUI V0, -24576
9D0022AC  24420430   ADDIU V0, V0, 1072
9D0022B0  8C420008   LW V0, 8(V0)
9D0022B4  7C420000   EXT V0, V0, 0, 1
9D0022B8  304200FF   ANDI V0, V0, 255
9D0022BC  AFC20014   SW V0, 20(S8)
46:                      SPI.status.RXDataReady=FALSE;
9D0022C0  3C02A000   LUI V0, -24576
9D0022C4  24430430   ADDIU V1, V0, 1072
9D0022C8  8C620008   LW V0, 8(V1)
9D0022CC  7C020004   INS V0, ZERO, 0, 1
9D0022D0  AC620008   SW V0, 8(V1)
47:                      INTRestoreInterrupts(statusTemp);
9D0022D4  8FC40010   LW A0, 16(S8)
9D0022D8  0F401805   JAL INTRestoreInterrupts
9D0022DC  00000000   NOP
48:                      return returnValue;
9D0022E0  8FC20014   LW V0, 20(S8)
49:                  }
9D0022E4  03C0E821   ADDU SP, S8, ZERO
9D0022E8  8FBF001C   LW RA, 28(SP)
9D0022EC  8FBE0018   LW S8, 24(SP)
9D0022F0  27BD0020   ADDIU SP, SP, 32
9D0022F4  03E00008   JR RA
9D0022F8  00000000   NOP
50:                  
51:                  /******************************************************************************/
52:                  
53:                  BOOL ConfigSPIComms(void)
54:                  {
9D0022FC  27BDFFE8   ADDIU SP, SP, -24
9D002300  AFBF0014   SW RA, 20(SP)
9D002304  AFBE0010   SW S8, 16(SP)
9D002308  03A0F021   ADDU S8, SP, ZERO
55:                      SpiChnClose(RPI_SPI_CHANNEL);
9D00230C  24040001   ADDIU A0, ZERO, 1
9D002310  0F401634   JAL SpiChnClose
9D002314  00000000   NOP
56:                      /* do I need to configure this? */
57:                      INTEnable(INT_SOURCE_SPI_RX(RPI_SPI_CHANNEL),INT_DISABLED);
9D002318  24040029   ADDIU A0, ZERO, 41
9D00231C  00002821   ADDU A1, ZERO, ZERO
9D002320  0F4016DD   JAL INTEnable
9D002324  00000000   NOP
58:                      INTEnable(INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL),INT_DISABLED);
9D002328  24040025   ADDIU A0, ZERO, 37
9D00232C  00002821   ADDU A1, ZERO, ZERO
9D002330  0F4016DD   JAL INTEnable
9D002334  00000000   NOP
59:                      INTEnable(INT_SOURCE_SPI_ERROR(RPI_SPI_CHANNEL),INT_DISABLED);
9D002338  24040021   ADDIU A0, ZERO, 33
9D00233C  00002821   ADDU A1, ZERO, ZERO
9D002340  0F4016DD   JAL INTEnable
9D002344  00000000   NOP
60:                      INTEnable(INT_SOURCE_SPI(RPI_SPI_CHANNEL),INT_DISABLED);
9D002348  2404001D   ADDIU A0, ZERO, 29
9D00234C  00002821   ADDU A1, ZERO, ZERO
9D002350  0F4016DD   JAL INTEnable
9D002354  00000000   NOP
61:                      RPI_SPI_BUF=0x00;
9D002358  3C02BF80   LUI V0, -16512
9D00235C  AC405E20   SW ZERO, 24096(V0)
62:                      SPI_DATA_IN_DIRECTION = TRIS_IN;
9D002360  3C03BF88   LUI V1, -16504
9D002364  8C626080   LW V0, 24704(V1)
9D002368  24040001   ADDIU A0, ZERO, 1
9D00236C  7C822104   INS V0, A0, 4, 1
9D002370  AC626080   SW V0, 24704(V1)
63:                      SPI_DATA_OUT_DIRECTION = TRIS_OUT;
9D002374  3C03BF88   LUI V1, -16504
9D002378  8C6260C0   LW V0, 24768(V1)
9D00237C  7C020004   INS V0, ZERO, 0, 1
9D002380  AC6260C0   SW V0, 24768(V1)
64:                      SPI_CLOCK_IN_DIRECTION = TRIS_IN;
9D002384  3C03BF88   LUI V1, -16504
9D002388  8C6260C0   LW V0, 24768(V1)
9D00238C  24040001   ADDIU A0, ZERO, 1
9D002390  7C825284   INS V0, A0, 10, 1
9D002394  AC6260C0   SW V0, 24768(V1)
65:                      SPI_SELECT_IN_DIRECTION = TRIS_IN;
9D002398  3C03BF88   LUI V1, -16504
9D00239C  8C6260C0   LW V0, 24768(V1)
9D0023A0  24040001   ADDIU A0, ZERO, 1
9D0023A4  7C824A44   INS V0, A0, 9, 1
9D0023A8  AC6260C0   SW V0, 24768(V1)
66:                  
67:                      SPI.RXCount=0;
9D0023AC  3C02A000   LUI V0, -24576
9D0023B0  24420430   ADDIU V0, V0, 1072
9D0023B4  A0400005   SB ZERO, 5(V0)
68:                      SPI.address.Val=0;
9D0023B8  3C02A000   LUI V0, -24576
9D0023BC  AC400430   SW ZERO, 1072(V0)
69:                      SPI.command=0;
9D0023C0  3C02A000   LUI V0, -24576
9D0023C4  24420430   ADDIU V0, V0, 1072
9D0023C8  A0400004   SB ZERO, 4(V0)
70:                      SpiChnOpen(RPI_SPI_CHANNEL,
9D0023CC  24040001   ADDIU A0, ZERO, 1
9D0023D0  24050180   ADDIU A1, ZERO, 384
9D0023D4  00003021   ADDU A2, ZERO, ZERO
9D0023D8  0F401578   JAL SpiChnOpen
9D0023DC  00000000   NOP
71:                              SPI_OPEN_SLVEN|SPI_OPEN_CKE_REV/*|SPI_OPEN_CKP_HIGH*/|SPI_OPEN_MODE8|SPI_OPEN_SSEN,
72:                              0);
73:                      //TODO: Not acting consistently? RPI needs to send -b 8 -H parameters to spidev
74:                      RPI_SPI_BUF=0xFF;
9D0023E0  3C02BF80   LUI V0, -16512
9D0023E4  240300FF   ADDIU V1, ZERO, 255
9D0023E8  AC435E20   SW V1, 24096(V0)
75:                      INTSetVectorPriority(INT_VECTOR_SPI(RPI_SPI_CHANNEL), INT_PRIORITY_LEVEL_3);
9D0023EC  24040017   ADDIU A0, ZERO, 23
9D0023F0  24050003   ADDIU A1, ZERO, 3
9D0023F4  0F401753   JAL INTSetVectorPriority
9D0023F8  00000000   NOP
76:                      INTSetVectorSubPriority(INT_VECTOR_SPI(RPI_SPI_CHANNEL),
9D0023FC  24040017   ADDIU A0, ZERO, 23
9D002400  24050001   ADDIU A1, ZERO, 1
9D002404  0F401761   JAL INTSetVectorSubPriority
9D002408  00000000   NOP
77:                              INT_SUB_PRIORITY_LEVEL_1);
78:                  
79:                      INTClearFlag(INT_SOURCE_SPI_RX(RPI_SPI_CHANNEL));
9D00240C  24040029   ADDIU A0, ZERO, 41
9D002410  0F4017B8   JAL INTClearFlag
9D002414  00000000   NOP
80:                      INTEnable(INT_SOURCE_SPI_RX(RPI_SPI_CHANNEL),INT_ENABLED);
9D002418  24040029   ADDIU A0, ZERO, 41
9D00241C  24050001   ADDIU A1, ZERO, 1
9D002420  0F4016DD   JAL INTEnable
9D002424  00000000   NOP
81:                      
82:                      INTClearFlag(INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL));
9D002428  24040025   ADDIU A0, ZERO, 37
9D00242C  0F4017B8   JAL INTClearFlag
9D002430  00000000   NOP
83:                      INTEnable(INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL),INT_ENABLED);
9D002434  24040025   ADDIU A0, ZERO, 37
9D002438  24050001   ADDIU A1, ZERO, 1
9D00243C  0F4016DD   JAL INTEnable
9D002440  00000000   NOP
84:                  
85:                      INTClearFlag(INT_SOURCE_SPI_ERROR(RPI_SPI_CHANNEL));
9D002444  24040021   ADDIU A0, ZERO, 33
9D002448  0F4017B8   JAL INTClearFlag
9D00244C  00000000   NOP
86:                      INTEnable(INT_SOURCE_SPI_ERROR(RPI_SPI_CHANNEL),INT_ENABLED);
9D002450  24040021   ADDIU A0, ZERO, 33
9D002454  24050001   ADDIU A1, ZERO, 1
9D002458  0F4016DD   JAL INTEnable
9D00245C  00000000   NOP
87:                  
88:                      INTClearFlag(INT_SOURCE_SPI(RPI_SPI_CHANNEL));
9D002460  2404001D   ADDIU A0, ZERO, 29
9D002464  0F4017B8   JAL INTClearFlag
9D002468  00000000   NOP
89:                      INTEnable(INT_SOURCE_SPI(RPI_SPI_CHANNEL),INT_ENABLED);
9D00246C  2404001D   ADDIU A0, ZERO, 29
9D002470  24050001   ADDIU A1, ZERO, 1
9D002474  0F4016DD   JAL INTEnable
9D002478  00000000   NOP
90:                      /* configure change notice, as I can't figure out any other way to        */
91:                      /* trigger the beginning of the slave select with just the SPI peripheral */
92:                      /* buuut the change notice pins are not on the SS pins, so a white wire is*/
93:                      /* needed                                                                 */
94:                      /* tie chip enable CE0 to pin20/RE5 CE1 */
95:                      SPI_SELECT_CN_DIRECTION=TRIS_IN;
9D00247C  3C03BF88   LUI V1, -16504
9D002480  8C626040   LW V0, 24640(V1)
9D002484  24040001   ADDIU A0, ZERO, 1
9D002488  7C822944   INS V0, A0, 5, 1
9D00248C  AC626040   SW V0, 24640(V1)
96:                      CNCONbits.w=0;
9D002490  3C02BF88   LUI V0, -16504
9D002494  AC4061C0   SW ZERO, 25024(V0)
97:                      CNCONbits.ON=TRUE;
9D002498  3C03BF88   LUI V1, -16504
9D00249C  8C6261C0   LW V0, 25024(V1)
9D0024A0  24040001   ADDIU A0, ZERO, 1
9D0024A4  7C827BC4   INS V0, A0, 15, 1
9D0024A8  AC6261C0   SW V0, 25024(V1)
98:                      CNENbits.w=0;
9D0024AC  3C02BF88   LUI V0, -16504
9D0024B0  AC4061D0   SW ZERO, 25040(V0)
99:                      CNENbits.CNEN7=TRUE;
9D0024B4  3C03BF88   LUI V1, -16504
9D0024B8  8C6261D0   LW V0, 25040(V1)
9D0024BC  24040001   ADDIU A0, ZERO, 1
9D0024C0  7C8239C4   INS V0, A0, 7, 1
9D0024C4  AC6261D0   SW V0, 25040(V1)
100:                     RPI_SPI_RX_OVERFLOW_CLEAR;
9D0024C8  3C03BF80   LUI V1, -16512
9D0024CC  8C625E10   LW V0, 24080(V1)
9D0024D0  7C023184   INS V0, ZERO, 6, 1
9D0024D4  AC625E10   SW V0, 24080(V1)
101:                     SPI1CONbits.STXISEL=0b01;
9D0024D8  3C03BF80   LUI V1, -16512
9D0024DC  8C625E00   LW V0, 24064(V1)
9D0024E0  24040001   ADDIU A0, ZERO, 1
9D0024E4  7C821884   INS V0, A0, 2, 2
9D0024E8  AC625E00   SW V0, 24064(V1)
102:                     SPI.status.w=0;
9D0024EC  3C02A000   LUI V0, -24576
9D0024F0  24420430   ADDIU V0, V0, 1072
9D0024F4  AC400008   SW ZERO, 8(V0)
103:                     INTClearFlag(INT_CN);
9D0024F8  2404001C   ADDIU A0, ZERO, 28
9D0024FC  0F4017B8   JAL INTClearFlag
9D002500  00000000   NOP
104:                     INTSetVectorPriority(INT_CHANGE_NOTICE_VECTOR, INT_PRIORITY_LEVEL_2);
9D002504  24040026   ADDIU A0, ZERO, 38
9D002508  24050002   ADDIU A1, ZERO, 2
9D00250C  0F401753   JAL INTSetVectorPriority
9D002510  00000000   NOP
105:                     INTSetVectorSubPriority(INT_CHANGE_NOTICE_VECTOR, INT_SUB_PRIORITY_LEVEL_1);
9D002514  24040026   ADDIU A0, ZERO, 38
9D002518  24050001   ADDIU A1, ZERO, 1
9D00251C  0F401761   JAL INTSetVectorSubPriority
9D002520  00000000   NOP
106:                     INTEnable(INT_CN,INT_ENABLED);
9D002524  2404001C   ADDIU A0, ZERO, 28
9D002528  24050001   ADDIU A1, ZERO, 1
9D00252C  0F4016DD   JAL INTEnable
9D002530  00000000   NOP
107:                     return TRUE;
9D002534  24020001   ADDIU V0, ZERO, 1
108:                 }
9D002538  03C0E821   ADDU SP, S8, ZERO
9D00253C  8FBF0014   LW RA, 20(SP)
9D002540  8FBE0010   LW S8, 16(SP)
9D002544  27BD0018   ADDIU SP, SP, 24
9D002548  03E00008   JR RA
9D00254C  00000000   NOP
109:                 
110:                 /******************************************************************************/
111:                 
112:                 void __ISR(_CHANGE_NOTICE_VECTOR , RPI_COMMS_CE_PRIORITY) RPiSPICNInterrutpt(void)
113:                 {
9D002550  415DE800   RDPGPR SP, SP
9D002554  401A7000   MFC0 K0, EPC
9D002558  401B6000   MFC0 K1, Status
9D00255C  27BDFFE0   ADDIU SP, SP, -32
9D002560  AFBA001C   SW K0, 28(SP)
9D002564  401A6002   MFC0 K0, SRSCtl
9D002568  AFBB0018   SW K1, 24(SP)
9D00256C  AFBA0014   SW K0, 20(SP)
9D002570  7C1B7844   INS K1, ZERO, 1, 15
9D002574  377B1000   ORI K1, K1, 4096
9D002578  409B6000   MTC0 K1, Status
9D00257C  AFBE000C   SW S8, 12(SP)
9D002580  AFA40008   SW A0, 8(SP)
9D002584  AFA30004   SW V1, 4(SP)
9D002588  AFA20000   SW V0, 0(SP)
9D00258C  03A0F021   ADDU S8, SP, ZERO
114:                     IFS1CLR=_IFS1_CNIF_MASK;
9D002590  3C02BF88   LUI V0, -16504
9D002594  24030001   ADDIU V1, ZERO, 1
9D002598  AC431044   SW V1, 4164(V0)
115:                     if((SPI.status.CEStatus==FALSE)&&(SPI_SELECT_CN_IN==FALSE))
9D00259C  3C02A000   LUI V0, -24576
9D0025A0  24420430   ADDIU V0, V0, 1072
9D0025A4  8C420008   LW V0, 8(V0)
9D0025A8  30420002   ANDI V0, V0, 2
9D0025AC  14400025   BNE V0, ZERO, 0x9D002644
9D0025B0  00000000   NOP
9D0025B4  3C02BF88   LUI V0, -16504
9D0025B8  8C426050   LW V0, 24656(V0)
9D0025BC  30420020   ANDI V0, V0, 32
9D0025C0  14400020   BNE V0, ZERO, 0x9D002644
9D0025C4  00000000   NOP
116:                     {
117:                         if(SPI.status.RXDataReady)
9D0025C8  3C02A000   LUI V0, -24576
9D0025CC  24420430   ADDIU V0, V0, 1072
9D0025D0  8C420008   LW V0, 8(V0)
9D0025D4  30420001   ANDI V0, V0, 1
9D0025D8  1040000C   BEQ V0, ZERO, 0x9D00260C
9D0025DC  00000000   NOP
118:                         {
119:                             /* we missed some data */
120:                             SPI.status.RXDataReady=FALSE;
9D0025E0  3C02A000   LUI V0, -24576
9D0025E4  24430430   ADDIU V1, V0, 1072
9D0025E8  8C620008   LW V0, 8(V1)
9D0025EC  7C020004   INS V0, ZERO, 0, 1
9D0025F0  AC620008   SW V0, 8(V1)
121:                             SPI.status.RXOverrun=TRUE;
9D0025F4  3C02A000   LUI V0, -24576
9D0025F8  24430430   ADDIU V1, V0, 1072
9D0025FC  8C620008   LW V0, 8(V1)
9D002600  24040001   ADDIU A0, ZERO, 1
9D002604  7C822944   INS V0, A0, 5, 1
9D002608  AC620008   SW V0, 8(V1)
122:                         }
123:                         SPI.RXState=STATE_SPI_RX_COMMAND;
9D00260C  3C02A000   LUI V0, -24576
9D002610  24420430   ADDIU V0, V0, 1072
9D002614  AC400110   SW ZERO, 272(V0)
124:                         SPI.status.CEStatus=TRUE;
9D002618  3C02A000   LUI V0, -24576
9D00261C  24430430   ADDIU V1, V0, 1072
9D002620  8C620008   LW V0, 8(V1)
9D002624  24040001   ADDIU A0, ZERO, 1
9D002628  7C820844   INS V0, A0, 1, 1
9D00262C  AC620008   SW V0, 8(V1)
125:                         SPI.RXCount=0;
9D002630  3C02A000   LUI V0, -24576
9D002634  24420430   ADDIU V0, V0, 1072
9D002638  A0400005   SB ZERO, 5(V0)
9D00263C  0B4009AB   J 0x9D0026AC
9D002640  00000000   NOP
126:                     }
127:                     else if((SPI.status.CEStatus==TRUE)&&(SPI_SELECT_CN_IN==TRUE))
9D002644  3C02A000   LUI V0, -24576
9D002648  24420430   ADDIU V0, V0, 1072
9D00264C  8C420008   LW V0, 8(V0)
9D002650  30420002   ANDI V0, V0, 2
9D002654  10400015   BEQ V0, ZERO, 0x9D0026AC
9D002658  00000000   NOP
9D00265C  3C02BF88   LUI V0, -16504
9D002660  8C426050   LW V0, 24656(V0)
9D002664  30420020   ANDI V0, V0, 32
9D002668  10400010   BEQ V0, ZERO, 0x9D0026AC
9D00266C  00000000   NOP
128:                     {
129:                         SPI.RXState=STATE_SPI_RX_COMPLETE;
9D002670  3C02A000   LUI V0, -24576
9D002674  24420430   ADDIU V0, V0, 1072
9D002678  24030007   ADDIU V1, ZERO, 7
9D00267C  AC430110   SW V1, 272(V0)
130:                         SPI.status.RXDataReady=TRUE;
9D002680  3C02A000   LUI V0, -24576
9D002684  24430430   ADDIU V1, V0, 1072
9D002688  8C620008   LW V0, 8(V1)
9D00268C  24040001   ADDIU A0, ZERO, 1
9D002690  7C820004   INS V0, A0, 0, 1
9D002694  AC620008   SW V0, 8(V1)
131:                         SPI.status.CEStatus=FALSE;
9D002698  3C02A000   LUI V0, -24576
9D00269C  24430430   ADDIU V1, V0, 1072
9D0026A0  8C620008   LW V0, 8(V1)
9D0026A4  7C020844   INS V0, ZERO, 1, 1
9D0026A8  AC620008   SW V0, 8(V1)
132:                     }
133:                 }
9D0026AC  03C0E821   ADDU SP, S8, ZERO
9D0026B0  8FBE000C   LW S8, 12(SP)
9D0026B4  8FA40008   LW A0, 8(SP)
9D0026B8  8FA30004   LW V1, 4(SP)
9D0026BC  8FA20000   LW V0, 0(SP)
9D0026C0  41606000   DI ZERO
9D0026C4  000000C0   EHB
9D0026C8  8FBA001C   LW K0, 28(SP)
9D0026CC  8FBB0018   LW K1, 24(SP)
9D0026D0  409A7000   MTC0 K0, EPC
9D0026D4  8FBA0014   LW K0, 20(SP)
9D0026D8  27BD0020   ADDIU SP, SP, 32
9D0026DC  409A6002   MTC0 K0, SRSCtl
9D0026E0  41DDE800   WRPGPR SP, SP
9D0026E4  409B6000   MTC0 K1, Status
9D0026E8  42000018   ERET
134:                 
135:                 /******************************************************************************/
136:                 
137:                 inline BOOL RPiSelectStatus(void)
138:                 {
9D0026EC  27BDFFE0   ADDIU SP, SP, -32
9D0026F0  AFBF001C   SW RA, 28(SP)
9D0026F4  AFBE0018   SW S8, 24(SP)
9D0026F8  03A0F021   ADDU S8, SP, ZERO
139:                     BOOL returnValue;
140:                     unsigned int intEnabled;
141:                     intEnabled=INTGetEnable(INT_CN);
9D0026FC  2404001C   ADDIU A0, ZERO, 28
9D002700  0F4017D6   JAL INTGetEnable
9D002704  00000000   NOP
9D002708  AFC20010   SW V0, 16(S8)
142:                     INTEnable(INT_CN,INT_DISABLED);
9D00270C  2404001C   ADDIU A0, ZERO, 28
9D002710  00002821   ADDU A1, ZERO, ZERO
9D002714  0F4016DD   JAL INTEnable
9D002718  00000000   NOP
143:                     returnValue=SPI.status.CEStatus;
9D00271C  3C02A000   LUI V0, -24576
9D002720  24420430   ADDIU V0, V0, 1072
9D002724  8C420008   LW V0, 8(V0)
9D002728  7C420040   EXT V0, V0, 1, 1
9D00272C  304200FF   ANDI V0, V0, 255
9D002730  AFC20014   SW V0, 20(S8)
144:                     if(intEnabled)
9D002734  8FC20010   LW V0, 16(S8)
9D002738  10400005   BEQ V0, ZERO, 0x9D002750
9D00273C  00000000   NOP
145:                     {
146:                         INTEnable(INT_CN,INT_ENABLED);
9D002740  2404001C   ADDIU A0, ZERO, 28
9D002744  24050001   ADDIU A1, ZERO, 1
9D002748  0F4016DD   JAL INTEnable
9D00274C  00000000   NOP
147:                     }
148:                     return returnValue;
9D002750  8FC20014   LW V0, 20(S8)
149:                 }
9D002754  03C0E821   ADDU SP, S8, ZERO
9D002758  8FBF001C   LW RA, 28(SP)
9D00275C  8FBE0018   LW S8, 24(SP)
9D002760  27BD0020   ADDIU SP, SP, 32
9D002764  03E00008   JR RA
9D002768  00000000   NOP
150:                 
151:                 /******************************************************************************/
152:                 
153:                 void __ISR(RPI_SPI_INTERRUPT , RPI_COMMS_INT_PRIORITY) RPiSPIInterrutpt(void)
154:                 {
9D00276C  415DE800   RDPGPR SP, SP
9D002770  401A7000   MFC0 K0, EPC
9D002774  401B6000   MFC0 K1, Status
9D002778  27BDFFD0   ADDIU SP, SP, -48
9D00277C  AFBA002C   SW K0, 44(SP)
9D002780  401A6002   MFC0 K0, SRSCtl
9D002784  AFBB0028   SW K1, 40(SP)
9D002788  AFBA0024   SW K0, 36(SP)
9D00278C  7C1B7844   INS K1, ZERO, 1, 15
9D002790  377B0C00   ORI K1, K1, 3072
9D002794  409B6000   MTC0 K1, Status
9D002798  AFBE0014   SW S8, 20(SP)
9D00279C  AFA50010   SW A1, 16(SP)
9D0027A0  AFA4000C   SW A0, 12(SP)
9D0027A4  AFA30008   SW V1, 8(SP)
9D0027A8  AFA20004   SW V0, 4(SP)
9D0027AC  00001012   MFLO V0, 0
9D0027B0  AFA2001C   SW V0, 28(SP)
9D0027B4  00001810   MFHI V1, 0
9D0027B8  AFA30018   SW V1, 24(SP)
9D0027BC  03A0F021   ADDU S8, SP, ZERO
155:                     static UINT8 SPITemp;
156:                     if(SPI_RX_INTERRUPT_ENABLE&&SPI_RX_INTERRUPT_FLAG)
9D0027C0  3C02BF88   LUI V0, -16504
9D0027C4  8C431060   LW V1, 4192(V0)
9D0027C8  3C020100   LUI V0, 256
9D0027CC  00621024   AND V0, V1, V0
9D0027D0  104000BA   BEQ V0, ZERO, 0x9D002ABC
9D0027D4  00000000   NOP
9D0027D8  3C02BF88   LUI V0, -16504
9D0027DC  8C431030   LW V1, 4144(V0)
9D0027E0  3C020100   LUI V0, 256
9D0027E4  00621024   AND V0, V1, V0
9D0027E8  104000B4   BEQ V0, ZERO, 0x9D002ABC
9D0027EC  00000000   NOP
157:                     {
158:                         SPI_RX_INTERRUPT_FLAG_CLEAR;
9D0027F0  3C02BF88   LUI V0, -16504
9D0027F4  3C030100   LUI V1, 256
9D0027F8  AC431034   SW V1, 4148(V0)
159:                         if(RPI_SPI_RX_BUF_FULL)
9D0027FC  3C02BF80   LUI V0, -16512
9D002800  8C425E10   LW V0, 24080(V0)
9D002804  30420001   ANDI V0, V0, 1
9D002808  104000AC   BEQ V0, ZERO, 0x9D002ABC
9D00280C  00000000   NOP
160:                         {
161:                             /* data in the buffer, read it */
162:                             SPITemp=RPI_SPI_BUF;
9D002810  3C02BF80   LUI V0, -16512
9D002814  8C425E20   LW V0, 24096(V0)
9D002818  304200FF   ANDI V0, V0, 255
9D00281C  A3828028   SB V0, -32728(GP)
163:                             switch(SPI.RXState)
9D002820  3C02A000   LUI V0, -24576
9D002824  24420430   ADDIU V0, V0, 1072
9D002828  8C420110   LW V0, 272(V0)
9D00282C  2C430009   SLTIU V1, V0, 9
9D002830  10600096   BEQ V1, ZERO, 0x9D002A8C
9D002834  00000000   NOP
9D002838  00021880   SLL V1, V0, 2
9D00283C  3C029D00   LUI V0, -25344
9D002840  24422854   ADDIU V0, V0, 10324
9D002844  00621021   ADDU V0, V1, V0
9D002848  8C420000   LW V0, 0(V0)
9D00284C  00400008   JR V0
9D002850  00000000   NOP
164:                             {
165:                                 case STATE_SPI_RX_COMMAND:
166:                                 {
167:                                     SPI.command=SPITemp;
9D002878  93838028   LBU V1, -32728(GP)
9D00287C  3C02A000   LUI V0, -24576
9D002880  24420430   ADDIU V0, V0, 1072
9D002884  A0430004   SB V1, 4(V0)
168:                                     SPI.TXBuffer=NOT_YET_BYTE;
9D002888  3C02A000   LUI V0, -24576
9D00288C  24420430   ADDIU V0, V0, 1072
9D002890  A040010C   SB ZERO, 268(V0)
169:                                     SPI.RXState=STATE_SPI_RX_ADDRESS_MSB;
9D002894  3C02A000   LUI V0, -24576
9D002898  24420430   ADDIU V0, V0, 1072
9D00289C  24030001   ADDIU V1, ZERO, 1
9D0028A0  AC430110   SW V1, 272(V0)
170:                                     break;
9D0028A4  0B400AAF   J 0x9D002ABC
9D0028A8  00000000   NOP
171:                                 }
172:                                 case STATE_SPI_RX_ADDRESS_MSB:
173:                                 {
174:                                     SPI.address.Val=0;
9D0028AC  3C02A000   LUI V0, -24576
9D0028B0  AC400430   SW ZERO, 1072(V0)
175:                                     SPI.RXState=STATE_SPI_RX_ADDRESS_2SB;
9D0028B4  3C02A000   LUI V0, -24576
9D0028B8  24420430   ADDIU V0, V0, 1072
9D0028BC  24030002   ADDIU V1, ZERO, 2
9D0028C0  AC430110   SW V1, 272(V0)
176:                                     SPI.address.byte.UB=SPITemp;
9D0028C4  93838028   LBU V1, -32728(GP)
9D0028C8  3C02A000   LUI V0, -24576
9D0028CC  24420430   ADDIU V0, V0, 1072
9D0028D0  A0430002   SB V1, 2(V0)
177:                                     break;
9D0028D4  0B400AAF   J 0x9D002ABC
9D0028D8  00000000   NOP
178:                                 }
179:                                 case STATE_SPI_RX_ADDRESS_2SB:
180:                                 {
181:                                     SPI.RXState=STATE_SPI_RX_ADDRESS_LSB;
9D0028DC  3C02A000   LUI V0, -24576
9D0028E0  24420430   ADDIU V0, V0, 1072
9D0028E4  24030003   ADDIU V1, ZERO, 3
9D0028E8  AC430110   SW V1, 272(V0)
182:                                     SPI.address.byte.HB=SPITemp;
9D0028EC  93838028   LBU V1, -32728(GP)
9D0028F0  3C02A000   LUI V0, -24576
9D0028F4  24420430   ADDIU V0, V0, 1072
9D0028F8  A0430001   SB V1, 1(V0)
183:                                     break;
9D0028FC  0B400AAF   J 0x9D002ABC
9D002900  00000000   NOP
184:                                 }
185:                                 case STATE_SPI_RX_ADDRESS_LSB:
186:                                 {
187:                                     SPI.RXState=STATE_SPI_RX_DATA;
9D002904  3C02A000   LUI V0, -24576
9D002908  24420430   ADDIU V0, V0, 1072
9D00290C  24030004   ADDIU V1, ZERO, 4
9D002910  AC430110   SW V1, 272(V0)
188:                                     SPI.address.byte.LB=SPITemp;
9D002914  93838028   LBU V1, -32728(GP)
9D002918  3C02A000   LUI V0, -24576
9D00291C  A0430430   SB V1, 1072(V0)
189:                                     break;
9D002920  0B400AAF   J 0x9D002ABC
9D002924  00000000   NOP
190:                                 }
191:                                 case STATE_SPI_RX_DATA:
192:                                 {
193:                                     if(!SPI.status.RXOverrunError)
9D002928  3C02A000   LUI V0, -24576
9D00292C  24420430   ADDIU V0, V0, 1072
9D002930  8C420008   LW V0, 8(V0)
9D002934  30420008   ANDI V0, V0, 8
9D002938  1440005F   BNE V0, ZERO, 0x9D002AB8
9D00293C  00000000   NOP
194:                                     {
195:                                         switch(SPI.command)
9D002940  3C02A000   LUI V0, -24576
9D002944  24420430   ADDIU V0, V0, 1072
9D002948  90420004   LBU V0, 4(V0)
9D00294C  24030002   ADDIU V1, ZERO, 2
9D002950  10430006   BEQ V0, V1, 0x9D00296C
9D002954  00000000   NOP
9D002958  24030003   ADDIU V1, ZERO, 3
9D00295C  10430023   BEQ V0, V1, 0x9D0029EC
9D002960  00000000   NOP
9D002964  0B400A96   J 0x9D002A58
9D002968  00000000   NOP
196:                                         {
197:                                             case SPI_WRITE:
198:                                             {
199:                                                 SPI.RXData[SPI.RXCount++]=SPITemp;
9D00296C  3C02A000   LUI V0, -24576
9D002970  24420430   ADDIU V0, V0, 1072
9D002974  90420005   LBU V0, 5(V0)
9D002978  00402821   ADDU A1, V0, ZERO
9D00297C  93848028   LBU A0, -32728(GP)
9D002980  3C03A000   LUI V1, -24576
9D002984  24630430   ADDIU V1, V1, 1072
9D002988  00A31821   ADDU V1, A1, V1
9D00298C  A064000C   SB A0, 12(V1)
9D002990  24420001   ADDIU V0, V0, 1
9D002994  304300FF   ANDI V1, V0, 255
9D002998  3C02A000   LUI V0, -24576
9D00299C  24420430   ADDIU V0, V0, 1072
9D0029A0  A0430005   SB V1, 5(V0)
200:                                                 if(SPI.RXCount==SPI_RX_BUFFER_SIZE)
9D0029A4  3C02A000   LUI V0, -24576
9D0029A8  24420430   ADDIU V0, V0, 1072
9D0029AC  90430005   LBU V1, 5(V0)
9D0029B0  240200FF   ADDIU V0, ZERO, 255
9D0029B4  1462000B   BNE V1, V0, 0x9D0029E4
9D0029B8  00000000   NOP
201:                                                 {
202:                                                     /* error-- went too long*/
203:                                                     SPI.status.RXOverrunError=TRUE;
9D0029BC  3C02A000   LUI V0, -24576
9D0029C0  24430430   ADDIU V1, V0, 1072
9D0029C4  8C620008   LW V0, 8(V1)
9D0029C8  24040001   ADDIU A0, ZERO, 1
9D0029CC  7C8218C4   INS V0, A0, 3, 1
9D0029D0  AC620008   SW V0, 8(V1)
204:                                                     SPI.RXState=STATE_SPI_RX_SPI_WRITE_COMPLETE;
9D0029D4  3C02A000   LUI V0, -24576
9D0029D8  24420430   ADDIU V0, V0, 1072
9D0029DC  24030008   ADDIU V1, ZERO, 8
9D0029E0  AC430110   SW V1, 272(V0)
205:                                                 }
206:                                                 break;
9D0029E4  0B400AA1   J 0x9D002A84
9D0029E8  00000000   NOP
207:                                             }
208:                                             case SPI_READ:
209:                                             {
210:                                                 SPI.TXIndex = SPI.address.byte.LB % sizeof (TRISThisData);
9D0029EC  3C02A000   LUI V0, -24576
9D0029F0  90430430   LBU V1, 1072(V0)
9D0029F4  2402002C   ADDIU V0, ZERO, 44
9D0029F8  0062001B   DIVU V1, V0
9D0029FC  004001F4   TEQ V0, ZERO
9D002A00  00001010   MFHI V0, 0
9D002A04  304300FF   ANDI V1, V0, 255
9D002A08  3C02A000   LUI V0, -24576
9D002A0C  24420430   ADDIU V0, V0, 1072
9D002A10  A043010D   SB V1, 269(V0)
211:                                                 SPI.TXBuffer= TRISThisData.data[SPI.TXIndex];
9D002A14  3C02A000   LUI V0, -24576
9D002A18  24420430   ADDIU V0, V0, 1072
9D002A1C  9042010D   LBU V0, 269(V0)
9D002A20  00401821   ADDU V1, V0, ZERO
9D002A24  3C02A000   LUI V0, -24576
9D002A28  24420544   ADDIU V0, V0, 1348
9D002A2C  00621021   ADDU V0, V1, V0
9D002A30  90430000   LBU V1, 0(V0)
9D002A34  3C02A000   LUI V0, -24576
9D002A38  24420430   ADDIU V0, V0, 1072
9D002A3C  A043010C   SB V1, 268(V0)
212:                                                 SPI.RXState = STATE_SPI_RX_READING;
9D002A40  3C02A000   LUI V0, -24576
9D002A44  24420430   ADDIU V0, V0, 1072
9D002A48  24030005   ADDIU V1, ZERO, 5
9D002A4C  AC430110   SW V1, 272(V0)
213:                                                 break;
9D002A50  0B400AA1   J 0x9D002A84
9D002A54  00000000   NOP
214:                                             }
215:                                             default:
216:                                             {
217:                                                 SPI.status.unknownCommandRX=TRUE;
9D002A58  3C02A000   LUI V0, -24576
9D002A5C  24430430   ADDIU V1, V0, 1072
9D002A60  8C620008   LW V0, 8(V1)
9D002A64  24040001   ADDIU A0, ZERO, 1
9D002A68  7C8239C4   INS V0, A0, 7, 1
9D002A6C  AC620008   SW V0, 8(V1)
218:                                                 SPI.RXState=STATE_SPI_RX_MYSTERY;
9D002A70  3C02A000   LUI V0, -24576
9D002A74  24420430   ADDIU V0, V0, 1072
9D002A78  24030006   ADDIU V1, ZERO, 6
9D002A7C  AC430110   SW V1, 272(V0)
219:                                                 /* don't know what to do */
220:                                                 break;
9D002A80  00000000   NOP
221:                                             }
222:                                         } 
223:                                     }
224:                                     break;
9D002A84  0B400AAF   J 0x9D002ABC
9D002A88  00000000   NOP
9D002AB8  00000000   NOP
225:                                 }
226:                                 case STATE_SPI_RX_COMPLETE:
227:                                 case STATE_SPI_RX_SPI_WRITE_COMPLETE:
228:                                 case STATE_SPI_RX_READING:
229:                                 case STATE_SPI_RX_MYSTERY:
230:                                 {
231:                                     break;
9D002AAC  00000000   NOP
9D002AB0  0B400AAF   J 0x9D002ABC
9D002AB4  00000000   NOP
232:                                 }
233:                                 default:
234:                                 {
235:                                     SPI.status.RXMysteryState=TRUE;
9D002A8C  3C02A000   LUI V0, -24576
9D002A90  24430430   ADDIU V1, V0, 1072
9D002A94  8C620008   LW V0, 8(V1)
9D002A98  24040001   ADDIU A0, ZERO, 1
9D002A9C  7C823184   INS V0, A0, 6, 1
9D002AA0  AC620008   SW V0, 8(V1)
236:                                     break;
9D002AA4  0B400AAF   J 0x9D002ABC
9D002AA8  00000000   NOP
237:                                 }
238:                             }
239:                         }
240:                         //SPI_RX_INTERRUPT_FLAG_CLEAR;
241:                     }
242:                     if(SPI_TX_INTERRUPT_ENABLE&&SPI_TX_INTERRUPT_FLAG)
9D002ABC  3C02BF88   LUI V0, -16504
9D002AC0  8C431060   LW V1, 4192(V0)
9D002AC4  3C020200   LUI V0, 512
9D002AC8  00621024   AND V0, V1, V0
9D002ACC  1040002E   BEQ V0, ZERO, 0x9D002B88
9D002AD0  00000000   NOP
9D002AD4  3C02BF88   LUI V0, -16504
9D002AD8  8C431030   LW V1, 4144(V0)
9D002ADC  3C020200   LUI V0, 512
9D002AE0  00621024   AND V0, V1, V0
9D002AE4  10400028   BEQ V0, ZERO, 0x9D002B88
9D002AE8  00000000   NOP
243:                     {
244:                         SPI_TX_INTERRUPT_FLAG_CLEAR;
9D002AEC  3C02BF88   LUI V0, -16504
9D002AF0  3C030200   LUI V1, 512
9D002AF4  AC431034   SW V1, 4148(V0)
245:                         RPI_SPI_BUF=SPI.TXBuffer;
9D002AF8  3C02A000   LUI V0, -24576
9D002AFC  24420430   ADDIU V0, V0, 1072
9D002B00  9042010C   LBU V0, 268(V0)
9D002B04  00401821   ADDU V1, V0, ZERO
9D002B08  3C02BF80   LUI V0, -16512
9D002B0C  AC435E20   SW V1, 24096(V0)
246:                         SPI.TXIndex++;
9D002B10  3C02A000   LUI V0, -24576
9D002B14  24420430   ADDIU V0, V0, 1072
9D002B18  9042010D   LBU V0, 269(V0)
9D002B1C  24420001   ADDIU V0, V0, 1
9D002B20  304300FF   ANDI V1, V0, 255
9D002B24  3C02A000   LUI V0, -24576
9D002B28  24420430   ADDIU V0, V0, 1072
9D002B2C  A043010D   SB V1, 269(V0)
247:                         SPI.TXIndex = SPI.TXIndex % sizeof (TRISThisData);
9D002B30  3C02A000   LUI V0, -24576
9D002B34  24420430   ADDIU V0, V0, 1072
9D002B38  9043010D   LBU V1, 269(V0)
9D002B3C  2402002C   ADDIU V0, ZERO, 44
9D002B40  0062001B   DIVU V1, V0
9D002B44  004001F4   TEQ V0, ZERO
9D002B48  00001010   MFHI V0, 0
9D002B4C  304300FF   ANDI V1, V0, 255
9D002B50  3C02A000   LUI V0, -24576
9D002B54  24420430   ADDIU V0, V0, 1072
9D002B58  A043010D   SB V1, 269(V0)
248:                         /* get the next byte ready */
249:                         SPI.TXBuffer=TRISThisData.data[SPI.TXIndex];
9D002B5C  3C02A000   LUI V0, -24576
9D002B60  24420430   ADDIU V0, V0, 1072
9D002B64  9042010D   LBU V0, 269(V0)
9D002B68  00401821   ADDU V1, V0, ZERO
9D002B6C  3C02A000   LUI V0, -24576
9D002B70  24420544   ADDIU V0, V0, 1348
9D002B74  00621021   ADDU V0, V1, V0
9D002B78  90430000   LBU V1, 0(V0)
9D002B7C  3C02A000   LUI V0, -24576
9D002B80  24420430   ADDIU V0, V0, 1072
9D002B84  A043010C   SB V1, 268(V0)
250:                     }
251:                     if(SPI_INTERRUPT_ERROR_ENABLE&&SPI_INTERRUPT_ERROR_FLAG)
9D002B88  3C02BF88   LUI V0, -16504
9D002B8C  8C431060   LW V1, 4192(V0)
9D002B90  3C020080   LUI V0, 128
9D002B94  00621024   AND V0, V1, V0
9D002B98  10400014   BEQ V0, ZERO, 0x9D002BEC
9D002B9C  00000000   NOP
9D002BA0  3C02BF88   LUI V0, -16504
9D002BA4  8C431030   LW V1, 4144(V0)
9D002BA8  3C020080   LUI V0, 128
9D002BAC  00621024   AND V0, V1, V0
9D002BB0  1040000E   BEQ V0, ZERO, 0x9D002BEC
9D002BB4  00000000   NOP
252:                     {
253:                         SPI_INTERRUPT_ERROR_FLAG_CLEAR;
9D002BB8  3C02BF88   LUI V0, -16504
9D002BBC  3C030080   LUI V1, 128
9D002BC0  AC431034   SW V1, 4148(V0)
254:                         RPI_SPI_RX_OVERFLOW_CLEAR;
9D002BC4  3C03BF80   LUI V1, -16512
9D002BC8  8C625E10   LW V0, 24080(V1)
9D002BCC  7C023184   INS V0, ZERO, 6, 1
9D002BD0  AC625E10   SW V0, 24080(V1)
255:                         SPI.status.RXOverflow=TRUE;
9D002BD4  3C02A000   LUI V0, -24576
9D002BD8  24430430   ADDIU V1, V0, 1072
9D002BDC  8C620008   LW V0, 8(V1)
9D002BE0  24040001   ADDIU A0, ZERO, 1
9D002BE4  7C822104   INS V0, A0, 4, 1
9D002BE8  AC620008   SW V0, 8(V1)
256:                     }
257:                 }
9D002BEC  03C0E821   ADDU SP, S8, ZERO
9D002BF0  8FA2001C   LW V0, 28(SP)
9D002BF4  00400013   MTLO V0, 0
9D002BF8  8FA30018   LW V1, 24(SP)
9D002BFC  00600011   MTHI V1, 0
9D002C00  8FBE0014   LW S8, 20(SP)
9D002C04  8FA50010   LW A1, 16(SP)
9D002C08  8FA4000C   LW A0, 12(SP)
9D002C0C  8FA30008   LW V1, 8(SP)
9D002C10  8FA20004   LW V0, 4(SP)
9D002C14  41606000   DI ZERO
9D002C18  000000C0   EHB
9D002C1C  8FBA002C   LW K0, 44(SP)
9D002C20  8FBB0028   LW K1, 40(SP)
9D002C24  409A7000   MTC0 K0, EPC
9D002C28  8FBA0024   LW K0, 36(SP)
9D002C2C  27BD0030   ADDIU SP, SP, 48
9D002C30  409A6002   MTC0 K0, SRSCtl
9D002C34  41DDE800   WRPGPR SP, SP
9D002C38  409B6000   MTC0 K1, Status
9D002C3C  42000018   ERET
258:                 
259:                 /******************************************************************************/
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/TRISThis.c  -----------------------------------
1:                   /******************************************************************************/
2:                   /* File:   TRISThis.c                                                         */
3:                   /* Author: matt                                                               */
4:                   /*                                                                            */
5:                   /* Created on September 14, 2013, 4:19 PM                                     */
6:                   /******************************************************************************/
7:                   
8:                   // <editor-fold defaultstate="collapsed" desc="SLA">
9:                   /******************************************************************************/
10:                  /* Software License Agreement                                                 */
11:                  /*                                                                            */
12:                  /*                                                                            */
13:                  /******************************************************************************/
14:                  
15:                  
16:                  #include <common.h>
17:                  #include <LED.h>
18:                  #include <commsToRPi.h>
19:                  #include <int.h>
20:                  #include <PAC1710.h>
21:                  #include <TRISThis.h>
22:                  
23:                  TRISTHIS_DATA_TYPE TRISThisData;
24:                  
25:                  /******************************************************************************/
26:                  
27:                  BOOL TRISThisConfigure(void)
28:                  {
9D002C40  27BDFFE0   ADDIU SP, SP, -32
9D002C44  AFBF001C   SW RA, 28(SP)
9D002C48  AFBE0018   SW S8, 24(SP)
9D002C4C  03A0F021   ADDU S8, SP, ZERO
29:                      int index;
30:                      index=sizeof(TRISThisData);
9D002C50  2402002C   ADDIU V0, ZERO, 44
9D002C54  AFC20010   SW V0, 16(S8)
31:                      for(index=0;index<sizeof(TRISThisData);index++)
9D002C58  AFC00010   SW ZERO, 16(S8)
9D002C5C  0B400B21   J 0x9D002C84
9D002C60  00000000   NOP
9D002C78  8FC20010   LW V0, 16(S8)
9D002C7C  24420001   ADDIU V0, V0, 1
9D002C80  AFC20010   SW V0, 16(S8)
9D002C84  8FC20010   LW V0, 16(S8)
9D002C88  2C42002C   SLTIU V0, V0, 44
9D002C8C  1440FFF5   BNE V0, ZERO, 0x9D002C64
9D002C90  00000000   NOP
32:                      {
33:                          TRISThisData.data[index]=0;
9D002C64  3C02A000   LUI V0, -24576
9D002C68  24430544   ADDIU V1, V0, 1348
9D002C6C  8FC20010   LW V0, 16(S8)
9D002C70  00621021   ADDU V0, V1, V0
9D002C74  A0400000   SB ZERO, 0(V0)
34:                      }
35:                      TRISThisData.status.configured=FALSE;
9D002C94  3C03A000   LUI V1, -24576
9D002C98  8C620544   LW V0, 1348(V1)
9D002C9C  7C020004   INS V0, ZERO, 0, 1
9D002CA0  AC620544   SW V0, 1348(V1)
36:                      if(TRISThisDigitalConfigure())
9D002CA4  0F400B3C   JAL TRISThisDigitalConfigure
9D002CA8  00000000   NOP
9D002CAC  10400006   BEQ V0, ZERO, 0x9D002CC8
9D002CB0  00000000   NOP
37:                      {
38:                          TRISThisData.status.configured=TRUE;
9D002CB4  3C03A000   LUI V1, -24576
9D002CB8  8C620544   LW V0, 1348(V1)
9D002CBC  24040001   ADDIU A0, ZERO, 1
9D002CC0  7C820004   INS V0, A0, 0, 1
9D002CC4  AC620544   SW V0, 1348(V1)
39:                      }
40:                      return TRISThisData.status.configured;
9D002CC8  3C02A000   LUI V0, -24576
9D002CCC  8C420544   LW V0, 1348(V0)
9D002CD0  7C420000   EXT V0, V0, 0, 1
9D002CD4  304200FF   ANDI V0, V0, 255
41:                  }
9D002CD8  03C0E821   ADDU SP, S8, ZERO
9D002CDC  8FBF001C   LW RA, 28(SP)
9D002CE0  8FBE0018   LW S8, 24(SP)
9D002CE4  27BD0020   ADDIU SP, SP, 32
9D002CE8  03E00008   JR RA
9D002CEC  00000000   NOP
42:                  
43:                  /******************************************************************************/
44:                  
45:                  BOOL TRISThisDigitalConfigure(void)
46:                  {
9D002CF0  27BDFFE0   ADDIU SP, SP, -32
9D002CF4  AFBF001C   SW RA, 28(SP)
9D002CF8  AFBE0018   SW S8, 24(SP)
9D002CFC  03A0F021   ADDU S8, SP, ZERO
47:                      UINT32 index;
48:                      IO_OUT00=FALSE;
9D002D00  3C03BF88   LUI V1, -16504
9D002D04  8C6260E0   LW V0, 24800(V1)
9D002D08  7C020844   INS V0, ZERO, 1, 1
9D002D0C  AC6260E0   SW V0, 24800(V1)
49:                      IO_OUT01=FALSE;
9D002D10  3C03BF88   LUI V1, -16504
9D002D14  8C6260E0   LW V0, 24800(V1)
9D002D18  7C021084   INS V0, ZERO, 2, 1
9D002D1C  AC6260E0   SW V0, 24800(V1)
50:                      IO_OUT02=FALSE;
9D002D20  3C03BF88   LUI V1, -16504
9D002D24  8C6260E0   LW V0, 24800(V1)
9D002D28  7C0218C4   INS V0, ZERO, 3, 1
9D002D2C  AC6260E0   SW V0, 24800(V1)
51:                      IO_OUT03=FALSE;
9D002D30  3C03BF88   LUI V1, -16504
9D002D34  8C6260E0   LW V0, 24800(V1)
9D002D38  7C022104   INS V0, ZERO, 4, 1
9D002D3C  AC6260E0   SW V0, 24800(V1)
52:                      IO_OUT04=FALSE;
9D002D40  3C03BF88   LUI V1, -16504
9D002D44  8C6260E0   LW V0, 24800(V1)
9D002D48  7C022944   INS V0, ZERO, 5, 1
9D002D4C  AC6260E0   SW V0, 24800(V1)
53:                      IO_OUT05=FALSE;
9D002D50  3C03BF88   LUI V1, -16504
9D002D54  8C6260E0   LW V0, 24800(V1)
9D002D58  7C023184   INS V0, ZERO, 6, 1
9D002D5C  AC6260E0   SW V0, 24800(V1)
54:                      IO_OUT06=FALSE;
9D002D60  3C03BF88   LUI V1, -16504
9D002D64  8C6260E0   LW V0, 24800(V1)
9D002D68  7C0239C4   INS V0, ZERO, 7, 1
9D002D6C  AC6260E0   SW V0, 24800(V1)
55:                      IO_OUT07=FALSE;
9D002D70  3C03BF88   LUI V1, -16504
9D002D74  8C6260E0   LW V0, 24800(V1)
9D002D78  7C024204   INS V0, ZERO, 8, 1
9D002D7C  AC6260E0   SW V0, 24800(V1)
56:                      IO_OUT08=FALSE;
9D002D80  3C03BF88   LUI V1, -16504
9D002D84  8C626120   LW V0, 24864(V1)
9D002D88  7C020004   INS V0, ZERO, 0, 1
9D002D8C  AC626120   SW V0, 24864(V1)
57:                      IO_OUT09=FALSE;
9D002D90  3C03BF88   LUI V1, -16504
9D002D94  8C626120   LW V0, 24864(V1)
9D002D98  7C020844   INS V0, ZERO, 1, 1
9D002D9C  AC626120   SW V0, 24864(V1)
58:                      IO_OUT10=FALSE;
9D002DA0  3C03BF88   LUI V1, -16504
9D002DA4  8C626120   LW V0, 24864(V1)
9D002DA8  7C021084   INS V0, ZERO, 2, 1
9D002DAC  AC626120   SW V0, 24864(V1)
59:                      IO_OUT11=FALSE;
9D002DB0  3C03BF88   LUI V1, -16504
9D002DB4  8C626120   LW V0, 24864(V1)
9D002DB8  7C0218C4   INS V0, ZERO, 3, 1
9D002DBC  AC626120   SW V0, 24864(V1)
60:                      IO_OUT12=FALSE;
9D002DC0  3C03BF88   LUI V1, -16504
9D002DC4  8C626120   LW V0, 24864(V1)
9D002DC8  7C022104   INS V0, ZERO, 4, 1
9D002DCC  AC626120   SW V0, 24864(V1)
61:                      IO_OUT13=FALSE;
9D002DD0  3C03BF88   LUI V1, -16504
9D002DD4  8C626120   LW V0, 24864(V1)
9D002DD8  7C022944   INS V0, ZERO, 5, 1
9D002DDC  AC626120   SW V0, 24864(V1)
62:                      IO_OUT14=FALSE;
9D002DE0  3C03BF88   LUI V1, -16504
9D002DE4  8C626120   LW V0, 24864(V1)
9D002DE8  7C023184   INS V0, ZERO, 6, 1
9D002DEC  AC626120   SW V0, 24864(V1)
63:                      IO_OUT15=FALSE;
9D002DF0  3C03BF88   LUI V1, -16504
9D002DF4  8C626120   LW V0, 24864(V1)
9D002DF8  7C0239C4   INS V0, ZERO, 7, 1
9D002DFC  AC626120   SW V0, 24864(V1)
64:                      IO_DIRECTION00=TRIS_IN;
9D002E00  3C03BF88   LUI V1, -16504
9D002E04  8C6260C0   LW V0, 24768(V1)
9D002E08  24040001   ADDIU A0, ZERO, 1
9D002E0C  7C820844   INS V0, A0, 1, 1
9D002E10  AC6260C0   SW V0, 24768(V1)
65:                      IO_DIRECTION01=TRIS_IN;
9D002E14  3C03BF88   LUI V1, -16504
9D002E18  8C6260C0   LW V0, 24768(V1)
9D002E1C  24040001   ADDIU A0, ZERO, 1
9D002E20  7C821084   INS V0, A0, 2, 1
9D002E24  AC6260C0   SW V0, 24768(V1)
66:                      IO_DIRECTION02=TRIS_IN;
9D002E28  3C03BF88   LUI V1, -16504
9D002E2C  8C6260C0   LW V0, 24768(V1)
9D002E30  24040001   ADDIU A0, ZERO, 1
9D002E34  7C8218C4   INS V0, A0, 3, 1
9D002E38  AC6260C0   SW V0, 24768(V1)
67:                      IO_DIRECTION03=TRIS_IN;
9D002E3C  3C03BF88   LUI V1, -16504
9D002E40  8C6260C0   LW V0, 24768(V1)
9D002E44  24040001   ADDIU A0, ZERO, 1
9D002E48  7C822104   INS V0, A0, 4, 1
9D002E4C  AC6260C0   SW V0, 24768(V1)
68:                      IO_DIRECTION04=TRIS_IN;
9D002E50  3C03BF88   LUI V1, -16504
9D002E54  8C6260C0   LW V0, 24768(V1)
9D002E58  24040001   ADDIU A0, ZERO, 1
9D002E5C  7C822944   INS V0, A0, 5, 1
9D002E60  AC6260C0   SW V0, 24768(V1)
69:                      IO_DIRECTION05=TRIS_IN;
9D002E64  3C03BF88   LUI V1, -16504
9D002E68  8C6260C0   LW V0, 24768(V1)
9D002E6C  24040001   ADDIU A0, ZERO, 1
9D002E70  7C823184   INS V0, A0, 6, 1
9D002E74  AC6260C0   SW V0, 24768(V1)
70:                      IO_DIRECTION06=TRIS_IN;
9D002E78  3C03BF88   LUI V1, -16504
9D002E7C  8C6260C0   LW V0, 24768(V1)
9D002E80  24040001   ADDIU A0, ZERO, 1
9D002E84  7C8239C4   INS V0, A0, 7, 1
9D002E88  AC6260C0   SW V0, 24768(V1)
71:                      IO_DIRECTION07=TRIS_IN;
9D002E8C  3C03BF88   LUI V1, -16504
9D002E90  8C6260C0   LW V0, 24768(V1)
9D002E94  24040001   ADDIU A0, ZERO, 1
9D002E98  7C824204   INS V0, A0, 8, 1
9D002E9C  AC6260C0   SW V0, 24768(V1)
72:                      IO_DIRECTION08=TRIS_IN;
9D002EA0  3C03BF88   LUI V1, -16504
9D002EA4  8C626100   LW V0, 24832(V1)
9D002EA8  24040001   ADDIU A0, ZERO, 1
9D002EAC  7C820004   INS V0, A0, 0, 1
9D002EB0  AC626100   SW V0, 24832(V1)
73:                      IO_DIRECTION09=TRIS_IN;
9D002EB4  3C03BF88   LUI V1, -16504
9D002EB8  8C626100   LW V0, 24832(V1)
9D002EBC  24040001   ADDIU A0, ZERO, 1
9D002EC0  7C820844   INS V0, A0, 1, 1
9D002EC4  AC626100   SW V0, 24832(V1)
74:                      IO_DIRECTION10=TRIS_IN;
9D002EC8  3C03BF88   LUI V1, -16504
9D002ECC  8C626100   LW V0, 24832(V1)
9D002ED0  24040001   ADDIU A0, ZERO, 1
9D002ED4  7C821084   INS V0, A0, 2, 1
9D002ED8  AC626100   SW V0, 24832(V1)
75:                      IO_DIRECTION11=TRIS_IN;
9D002EDC  3C03BF88   LUI V1, -16504
9D002EE0  8C626100   LW V0, 24832(V1)
9D002EE4  24040001   ADDIU A0, ZERO, 1
9D002EE8  7C8218C4   INS V0, A0, 3, 1
9D002EEC  AC626100   SW V0, 24832(V1)
76:                      IO_DIRECTION12=TRIS_IN;
9D002EF0  3C03BF88   LUI V1, -16504
9D002EF4  8C626100   LW V0, 24832(V1)
9D002EF8  24040001   ADDIU A0, ZERO, 1
9D002EFC  7C822104   INS V0, A0, 4, 1
9D002F00  AC626100   SW V0, 24832(V1)
77:                      IO_DIRECTION13=TRIS_IN;
9D002F04  3C03BF88   LUI V1, -16504
9D002F08  8C626100   LW V0, 24832(V1)
9D002F0C  24040001   ADDIU A0, ZERO, 1
9D002F10  7C822944   INS V0, A0, 5, 1
9D002F14  AC626100   SW V0, 24832(V1)
78:                      IO_DIRECTION14=TRIS_IN;
9D002F18  3C03BF88   LUI V1, -16504
9D002F1C  8C626100   LW V0, 24832(V1)
9D002F20  24040001   ADDIU A0, ZERO, 1
9D002F24  7C823184   INS V0, A0, 6, 1
9D002F28  AC626100   SW V0, 24832(V1)
79:                      IO_DIRECTION15=TRIS_IN;
9D002F2C  3C03BF88   LUI V1, -16504
9D002F30  8C626100   LW V0, 24832(V1)
9D002F34  24040001   ADDIU A0, ZERO, 1
9D002F38  7C8239C4   INS V0, A0, 7, 1
9D002F3C  AC626100   SW V0, 24832(V1)
80:                      /* clear out the data array */
81:                      for(index=0;index<TRISTHIS_DATA_SIZE;index++)
9D002F40  AFC00010   SW ZERO, 16(S8)
9D002F44  0B400BDB   J 0x9D002F6C
9D002F48  00000000   NOP
9D002F60  8FC20010   LW V0, 16(S8)
9D002F64  24420001   ADDIU V0, V0, 1
9D002F68  AFC20010   SW V0, 16(S8)
9D002F6C  8FC20010   LW V0, 16(S8)
9D002F70  2C42002C   SLTIU V0, V0, 44
9D002F74  1440FFF5   BNE V0, ZERO, 0x9D002F4C
9D002F78  00000000   NOP
82:                      {
83:                          TRISThisData.data[index]=0;
9D002F4C  3C02A000   LUI V0, -24576
9D002F50  24430544   ADDIU V1, V0, 1348
9D002F54  8FC20010   LW V0, 16(S8)
9D002F58  00621021   ADDU V0, V1, V0
9D002F5C  A0400000   SB ZERO, 0(V0)
84:                      }
85:                      /* read in the current state */
86:                      TRISThisData.digital.port.Val=TRISThisReadDigitalInputs();
9D002F7C  0F400BF8   JAL TRISThisReadDigitalInputs
9D002F80  00000000   NOP
9D002F84  00401821   ADDU V1, V0, ZERO
9D002F88  3C02A000   LUI V0, -24576
9D002F8C  24420544   ADDIU V0, V0, 1348
9D002F90  AC43000C   SW V1, 12(V0)
87:                      TRISThisData.digital.latch.Val=TRISThisReadDigitalLatches();
9D002F94  0F400C0B   JAL TRISThisReadDigitalLatches
9D002F98  00000000   NOP
9D002F9C  00401821   ADDU V1, V0, ZERO
9D002FA0  3C02A000   LUI V0, -24576
9D002FA4  24420544   ADDIU V0, V0, 1348
9D002FA8  AC430008   SW V1, 8(V0)
88:                      TRISThisData.digital.direction.Val=TRISThisReadDigitalDirection();
9D002FAC  0F400C1E   JAL TRISThisReadDigitalDirection
9D002FB0  00000000   NOP
9D002FB4  00401821   ADDU V1, V0, ZERO
9D002FB8  3C02A000   LUI V0, -24576
9D002FBC  24420544   ADDIU V0, V0, 1348
9D002FC0  AC430010   SW V1, 16(V0)
89:                      return TRUE;
9D002FC4  24020001   ADDIU V0, ZERO, 1
90:                  }
9D002FC8  03C0E821   ADDU SP, S8, ZERO
9D002FCC  8FBF001C   LW RA, 28(SP)
9D002FD0  8FBE0018   LW S8, 24(SP)
9D002FD4  27BD0020   ADDIU SP, SP, 32
9D002FD8  03E00008   JR RA
9D002FDC  00000000   NOP
91:                  
92:                  /******************************************************************************/
93:                  
94:                  UINT32 TRISThisReadDigitalInputs(void)
95:                  {
9D002FE0  27BDFFF0   ADDIU SP, SP, -16
9D002FE4  AFBE000C   SW S8, 12(SP)
9D002FE8  03A0F021   ADDU S8, SP, ZERO
96:                      UINT32_VAL readTemp;
97:                      readTemp.Val=0;
9D002FEC  AFC00000   SW ZERO, 0(S8)
98:                      readTemp.byte.LB=(0xff&(PORTD>>1));
9D002FF0  3C02BF88   LUI V0, -16504
9D002FF4  8C4260D0   LW V0, 24784(V0)
9D002FF8  00021042   SRL V0, V0, 1
9D002FFC  304200FF   ANDI V0, V0, 255
9D003000  A3C20000   SB V0, 0(S8)
99:                      readTemp.byte.HB=(0xff&(PORTE));
9D003004  3C02BF88   LUI V0, -16504
9D003008  8C426110   LW V0, 24848(V0)
9D00300C  304200FF   ANDI V0, V0, 255
9D003010  A3C20001   SB V0, 1(S8)
100:                     return readTemp.Val;
9D003014  8FC20000   LW V0, 0(S8)
101:                 }
9D003018  03C0E821   ADDU SP, S8, ZERO
9D00301C  8FBE000C   LW S8, 12(SP)
9D003020  27BD0010   ADDIU SP, SP, 16
9D003024  03E00008   JR RA
9D003028  00000000   NOP
102:                 
103:                 /******************************************************************************/
104:                 
105:                 UINT32 TRISThisReadDigitalLatches(void)
106:                 {
9D00302C  27BDFFF0   ADDIU SP, SP, -16
9D003030  AFBE000C   SW S8, 12(SP)
9D003034  03A0F021   ADDU S8, SP, ZERO
107:                     UINT32_VAL readTemp;
108:                     readTemp.Val=0;
9D003038  AFC00000   SW ZERO, 0(S8)
109:                     readTemp.byte.LB=(0xff&(LATD>>1));
9D00303C  3C02BF88   LUI V0, -16504
9D003040  8C4260E0   LW V0, 24800(V0)
9D003044  00021042   SRL V0, V0, 1
9D003048  304200FF   ANDI V0, V0, 255
9D00304C  A3C20000   SB V0, 0(S8)
110:                     readTemp.byte.HB=(0xff&(LATE));
9D003050  3C02BF88   LUI V0, -16504
9D003054  8C426120   LW V0, 24864(V0)
9D003058  304200FF   ANDI V0, V0, 255
9D00305C  A3C20001   SB V0, 1(S8)
111:                     return readTemp.Val;
9D003060  8FC20000   LW V0, 0(S8)
112:                 }
9D003064  03C0E821   ADDU SP, S8, ZERO
9D003068  8FBE000C   LW S8, 12(SP)
9D00306C  27BD0010   ADDIU SP, SP, 16
9D003070  03E00008   JR RA
9D003074  00000000   NOP
113:                 
114:                 /******************************************************************************/
115:                 
116:                 UINT32 TRISThisReadDigitalDirection(void)
117:                 {
9D003078  27BDFFF0   ADDIU SP, SP, -16
9D00307C  AFBE000C   SW S8, 12(SP)
9D003080  03A0F021   ADDU S8, SP, ZERO
118:                     UINT32_VAL readTemp;
119:                     readTemp.Val=0;
9D003084  AFC00000   SW ZERO, 0(S8)
120:                     readTemp.byte.LB=(0xff&(TRISD>>1));
9D003088  3C02BF88   LUI V0, -16504
9D00308C  8C4260C0   LW V0, 24768(V0)
9D003090  00021042   SRL V0, V0, 1
9D003094  304200FF   ANDI V0, V0, 255
9D003098  A3C20000   SB V0, 0(S8)
121:                     readTemp.byte.HB=(0xff&(TRISE));
9D00309C  3C02BF88   LUI V0, -16504
9D0030A0  8C426100   LW V0, 24832(V0)
9D0030A4  304200FF   ANDI V0, V0, 255
9D0030A8  A3C20001   SB V0, 1(S8)
122:                     return readTemp.Val;
9D0030AC  8FC20000   LW V0, 0(S8)
123:                 }
9D0030B0  03C0E821   ADDU SP, S8, ZERO
9D0030B4  8FBE000C   LW S8, 12(SP)
9D0030B8  27BD0010   ADDIU SP, SP, 16
9D0030BC  03E00008   JR RA
9D0030C0  00000000   NOP
124:                 
125:                 /******************************************************************************/
126:                 
127:                 BOOL TRISThisSetDigitalLatches(UINT32_VAL toSet)
128:                 {
9D0030C4  27BDFFF0   ADDIU SP, SP, -16
9D0030C8  AFBE000C   SW S8, 12(SP)
9D0030CC  03A0F021   ADDU S8, SP, ZERO
9D0030D0  AFC40010   SW A0, 16(S8)
129:                     BOOL returnValue=FALSE;
9D0030D4  AFC00000   SW ZERO, 0(S8)
130:                     LATD=toSet.byte.LB<<1;
9D0030D8  93C20010   LBU V0, 16(S8)
9D0030DC  00021040   SLL V0, V0, 1
9D0030E0  00401821   ADDU V1, V0, ZERO
9D0030E4  3C02BF88   LUI V0, -16504
9D0030E8  AC4360E0   SW V1, 24800(V0)
131:                     LATE=toSet.byte.HB;
9D0030EC  93C20011   LBU V0, 17(S8)
9D0030F0  00401821   ADDU V1, V0, ZERO
9D0030F4  3C02BF88   LUI V0, -16504
9D0030F8  AC436120   SW V1, 24864(V0)
132:                     return returnValue;
9D0030FC  8FC20000   LW V0, 0(S8)
133:                 }
9D003100  03C0E821   ADDU SP, S8, ZERO
9D003104  8FBE000C   LW S8, 12(SP)
9D003108  27BD0010   ADDIU SP, SP, 16
9D00310C  03E00008   JR RA
9D003110  00000000   NOP
134:                 
135:                 /******************************************************************************/
136:                 
137:                 BOOL TRISThisSetDigitalDirection(UINT32_VAL toSet)
138:                 {
9D003114  27BDFFF0   ADDIU SP, SP, -16
9D003118  AFBE000C   SW S8, 12(SP)
9D00311C  03A0F021   ADDU S8, SP, ZERO
9D003120  AFC40010   SW A0, 16(S8)
139:                     BOOL returnValue=FALSE;
9D003124  AFC00000   SW ZERO, 0(S8)
140:                     TRISD=toSet.byte.LB<<1;
9D003128  93C20010   LBU V0, 16(S8)
9D00312C  00021040   SLL V0, V0, 1
9D003130  00401821   ADDU V1, V0, ZERO
9D003134  3C02BF88   LUI V0, -16504
9D003138  AC4360C0   SW V1, 24768(V0)
141:                     TRISE=toSet.byte.HB;
9D00313C  93C20011   LBU V0, 17(S8)
9D003140  00401821   ADDU V1, V0, ZERO
9D003144  3C02BF88   LUI V0, -16504
9D003148  AC436100   SW V1, 24832(V0)
142:                     return returnValue;
9D00314C  8FC20000   LW V0, 0(S8)
143:                 }
9D003150  03C0E821   ADDU SP, S8, ZERO
9D003154  8FBE000C   LW S8, 12(SP)
9D003158  27BD0010   ADDIU SP, SP, 16
9D00315C  03E00008   JR RA
9D003160  00000000   NOP
144:                 
145:                 /******************************************************************************/
146:                 
147:                 void DoTRISThis(void)
148:                 {
9D003164  27BDFFE0   ADDIU SP, SP, -32
9D003168  AFBF001C   SW RA, 28(SP)
9D00316C  AFBE0018   SW S8, 24(SP)
9D003170  AFB00014   SW S0, 20(SP)
9D003174  03A0F021   ADDU S8, SP, ZERO
149:                     static UINT32_VAL tempHolding;
150:                 
151:                     TRISThisData.digital.port.Val=TRISThisReadDigitalInputs();
9D003178  0F400BF8   JAL TRISThisReadDigitalInputs
9D00317C  00000000   NOP
9D003180  00401821   ADDU V1, V0, ZERO
9D003184  3C02A000   LUI V0, -24576
9D003188  24420544   ADDIU V0, V0, 1348
9D00318C  AC43000C   SW V1, 12(V0)
152:                     TRISThisData.digital.latch.Val=TRISThisReadDigitalLatches();
9D003190  0F400C0B   JAL TRISThisReadDigitalLatches
9D003194  00000000   NOP
9D003198  00401821   ADDU V1, V0, ZERO
9D00319C  3C02A000   LUI V0, -24576
9D0031A0  24420544   ADDIU V0, V0, 1348
9D0031A4  AC430008   SW V1, 8(V0)
153:                     TRISThisData.digital.direction.Val=TRISThisReadDigitalDirection();
9D0031A8  0F400C1E   JAL TRISThisReadDigitalDirection
9D0031AC  00000000   NOP
9D0031B0  00401821   ADDU V1, V0, ZERO
9D0031B4  3C02A000   LUI V0, -24576
9D0031B8  24420544   ADDIU V0, V0, 1348
9D0031BC  AC430010   SW V1, 16(V0)
154:                     TRISThisData.status.autoLEDmode=GetLEDAutoMode();
9D0031C0  0F40147F   JAL GetLEDAutoMode
9D0031C4  00000000   NOP
9D0031C8  304200FF   ANDI V0, V0, 255
9D0031CC  30420001   ANDI V0, V0, 1
9D0031D0  304400FF   ANDI A0, V0, 255
9D0031D4  3C03A000   LUI V1, -24576
9D0031D8  8C620544   LW V0, 1348(V1)
9D0031DC  7C821084   INS V0, A0, 2, 1
9D0031E0  AC620544   SW V0, 1348(V1)
155:                     TRISThisData.status.V5p0Good=P5V_POWER_GOOD;
9D0031E4  3C02BF88   LUI V0, -16504
9D0031E8  8C426110   LW V0, 24848(V0)
9D0031EC  7C420240   EXT V0, V0, 9, 1
9D0031F0  304400FF   ANDI A0, V0, 255
9D0031F4  3C03A000   LUI V1, -24576
9D0031F8  8C620544   LW V0, 1348(V1)
9D0031FC  7C820844   INS V0, A0, 1, 1
9D003200  AC620544   SW V0, 1348(V1)
156:                     if(SPIDataReady())
9D003204  0F4008A3   JAL SPIDataReady
9D003208  00000000   NOP
9D00320C  1040005C   BEQ V0, ZERO, 0x9D003380
9D003210  00000000   NOP
157:                     {
158:                         /* if there is data available from the SPI, figure out what it is, and*/
159:                         /* put it */
160:                         INTEnable( INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL),INT_DISABLED);
9D003214  24040025   ADDIU A0, ZERO, 37
9D003218  00002821   ADDU A1, ZERO, ZERO
9D00321C  0F4016DD   JAL INTEnable
9D003220  00000000   NOP
161:                         /* called a lot- save churn on the stack?                             */
162:                         static UINT32_VAL tempData;
163:                         /* check the data we read                                             */
164:                         SPIByteGet(INDEX_STATUS_MB,&tempData.byte.MB);
9D003224  00002021   ADDU A0, ZERO, ZERO
9D003228  2785802F   ADDIU A1, GP, -32721
9D00322C  0F40087E   JAL SPIByteGet
9D003230  00000000   NOP
165:                         SPIByteGet(INDEX_STATUS_UB,&tempData.byte.UB);
9D003234  24040001   ADDIU A0, ZERO, 1
9D003238  2785802E   ADDIU A1, GP, -32722
9D00323C  0F40087E   JAL SPIByteGet
9D003240  00000000   NOP
166:                         SPIByteGet(INDEX_STATUS_HB,&tempData.byte.HB);
9D003244  24040002   ADDIU A0, ZERO, 2
9D003248  2785802D   ADDIU A1, GP, -32723
9D00324C  0F40087E   JAL SPIByteGet
9D003250  00000000   NOP
167:                         SPIByteGet(INDEX_STATUS_LB,&tempData.byte.LB);
9D003254  24040003   ADDIU A0, ZERO, 3
9D003258  2785802C   ADDIU A1, GP, -32724
9D00325C  0F40087E   JAL SPIByteGet
9D003260  00000000   NOP
168:                         /* tempdata is the status */
169:                         tempData.Val|=STATUS_READ_ONLY_MASK;
9D003264  8F82802C   LW V0, -32724(GP)
9D003268  34420003   ORI V0, V0, 3
9D00326C  AF82802C   SW V0, -32724(GP)
170:                         if(tempData.Val!=(TRISThisReadStatus()|STATUS_READ_ONLY_MASK))
9D003270  8F90802C   LW S0, -32724(GP)
9D003274  0F400D10   JAL TRISThisReadStatus
9D003278  00000000   NOP
9D00327C  34420003   ORI V0, V0, 3
9D003280  1202000C   BEQ S0, V0, 0x9D0032B4
9D003284  00000000   NOP
171:                         {
172:                             TRISThisSetStatus(tempData.Val);
9D003288  8F82802C   LW V0, -32724(GP)
9D00328C  00402021   ADDU A0, V0, ZERO
9D003290  0F400D22   JAL TRISThisSetStatus
9D003294  00000000   NOP
173:                             LEDAutoMode(TRISThisData.status.autoLEDmode);
9D003298  3C02A000   LUI V0, -24576
9D00329C  8C420544   LW V0, 1348(V0)
9D0032A0  7C420080   EXT V0, V0, 2, 1
9D0032A4  304200FF   ANDI V0, V0, 255
9D0032A8  00402021   ADDU A0, V0, ZERO
9D0032AC  0F40146A   JAL LEDAutoMode
9D0032B0  00000000   NOP
174:                         }
175:                         SPIByteGet(INDEX_LED,&tempData.byte.LB);
9D0032B4  24040007   ADDIU A0, ZERO, 7
9D0032B8  2785802C   ADDIU A1, GP, -32724
9D0032BC  0F40087E   JAL SPIByteGet
9D0032C0  00000000   NOP
176:                         if(tempData.byte.LB!=ReadLEDs())
9D0032C4  9390802C   LBU S0, -32724(GP)
9D0032C8  0F401340   JAL ReadLEDs
9D0032CC  00000000   NOP
9D0032D0  12020005   BEQ S0, V0, 0x9D0032E8
9D0032D4  00000000   NOP
177:                         {
178:                             SetLEDs(tempData.byte.LB);
9D0032D8  9382802C   LBU V0, -32724(GP)
9D0032DC  00402021   ADDU A0, V0, ZERO
9D0032E0  0F401389   JAL SetLEDs
9D0032E4  00000000   NOP
179:                         }
180:                         tempData.Val=0;
9D0032E8  AF80802C   SW ZERO, -32724(GP)
181:                         SPIByteGet(INDEX_DIGITAL_DIRECTION_LB,&tempData.byte.LB);
9D0032EC  2404000F   ADDIU A0, ZERO, 15
9D0032F0  2785802C   ADDIU A1, GP, -32724
9D0032F4  0F40087E   JAL SPIByteGet
9D0032F8  00000000   NOP
182:                         SPIByteGet(INDEX_DIGITAL_DIRECTION_HB,&tempData.byte.HB);
9D0032FC  2404000E   ADDIU A0, ZERO, 14
9D003300  2785802D   ADDIU A1, GP, -32723
9D003304  0F40087E   JAL SPIByteGet
9D003308  00000000   NOP
183:                         if(tempData.Val!=TRISThisReadDigitalDirection())
9D00330C  8F90802C   LW S0, -32724(GP)
9D003310  0F400C1E   JAL TRISThisReadDigitalDirection
9D003314  00000000   NOP
9D003318  12020004   BEQ S0, V0, 0x9D00332C
9D00331C  00000000   NOP
184:                         {
185:                             TRISThisSetDigitalDirection(tempData);
9D003320  8F84802C   LW A0, -32724(GP)
9D003324  0F400C45   JAL TRISThisSetDigitalDirection
9D003328  00000000   NOP
186:                         }
187:                         tempData.Val=0;
9D00332C  AF80802C   SW ZERO, -32724(GP)
188:                         SPIByteGet(INDEX_DIGITAL_LATCH_LB,&tempData.byte.LB);
9D003330  2404000B   ADDIU A0, ZERO, 11
9D003334  2785802C   ADDIU A1, GP, -32724
9D003338  0F40087E   JAL SPIByteGet
9D00333C  00000000   NOP
189:                         SPIByteGet(INDEX_DIGITAL_LATCH_HB,&tempData.byte.HB);
9D003340  2404000A   ADDIU A0, ZERO, 10
9D003344  2785802D   ADDIU A1, GP, -32723
9D003348  0F40087E   JAL SPIByteGet
9D00334C  00000000   NOP
190:                         if(tempData.Val!=TRISThisReadDigitalLatches())
9D003350  8F90802C   LW S0, -32724(GP)
9D003354  0F400C0B   JAL TRISThisReadDigitalLatches
9D003358  00000000   NOP
9D00335C  12020004   BEQ S0, V0, 0x9D003370
9D003360  00000000   NOP
191:                         {
192:                             TRISThisSetDigitalLatches(tempData);
9D003364  8F84802C   LW A0, -32724(GP)
9D003368  0F400C31   JAL TRISThisSetDigitalLatches
9D00336C  00000000   NOP
193:                         }
194:                         INTEnable( INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL),INT_ENABLED);
9D003370  24040025   ADDIU A0, ZERO, 37
9D003374  24050001   ADDIU A1, ZERO, 1
9D003378  0F4016DD   JAL INTEnable
9D00337C  00000000   NOP
195:                     }
196:                     /* update the data that the SPI might read */
197:                     if(PAC1710GetData(PAC1710_DATA_CURRENT,&tempHolding.w[0]))
9D003380  27828030   ADDIU V0, GP, -32720
9D003384  00002021   ADDU A0, ZERO, ZERO
9D003388  00402821   ADDU A1, V0, ZERO
9D00338C  0F400844   JAL PAC1710GetData
9D003390  00000000   NOP
9D003394  1040000A   BEQ V0, ZERO, 0x9D0033C0
9D003398  00000000   NOP
198:                     {
199:                         TRISThisData.supplyCurrent.w[0]=tempHolding.w[0];
9D00339C  97838030   LHU V1, -32720(GP)
9D0033A0  3C02A000   LUI V0, -24576
9D0033A4  24420544   ADDIU V0, V0, 1348
9D0033A8  A4430024   SH V1, 36(V0)
200:                         TRISThisData.status.freshSupplyCurrent=TRUE;
9D0033AC  3C03A000   LUI V1, -24576
9D0033B0  8C620544   LW V0, 1348(V1)
9D0033B4  24040001   ADDIU A0, ZERO, 1
9D0033B8  7C822104   INS V0, A0, 4, 1
9D0033BC  AC620544   SW V0, 1348(V1)
201:                     }
202:                     if(PAC1710GetData(PAC1710_DATA_VOLTAGE,&tempHolding.w[0]))
9D0033C0  27828030   ADDIU V0, GP, -32720
9D0033C4  24040001   ADDIU A0, ZERO, 1
9D0033C8  00402821   ADDU A1, V0, ZERO
9D0033CC  0F400844   JAL PAC1710GetData
9D0033D0  00000000   NOP
9D0033D4  1040000A   BEQ V0, ZERO, 0x9D003400
9D0033D8  00000000   NOP
203:                     {
204:                         TRISThisData.supplyVoltage.w[0]=tempHolding.w[0];
9D0033DC  97838030   LHU V1, -32720(GP)
9D0033E0  3C02A000   LUI V0, -24576
9D0033E4  24420544   ADDIU V0, V0, 1348
9D0033E8  A4430028   SH V1, 40(V0)
205:                         TRISThisData.status.freshSupplyVoltage=TRUE;
9D0033EC  3C03A000   LUI V1, -24576
9D0033F0  8C620544   LW V0, 1348(V1)
9D0033F4  24040001   ADDIU A0, ZERO, 1
9D0033F8  7C8218C4   INS V0, A0, 3, 1
9D0033FC  AC620544   SW V0, 1348(V1)
206:                     }
207:                     TRISThisData.status.autoLEDmode=GetLEDAutoMode();
9D003400  0F40147F   JAL GetLEDAutoMode
9D003404  00000000   NOP
9D003408  304200FF   ANDI V0, V0, 255
9D00340C  30420001   ANDI V0, V0, 1
9D003410  304400FF   ANDI A0, V0, 255
9D003414  3C03A000   LUI V1, -24576
9D003418  8C620544   LW V0, 1348(V1)
9D00341C  7C821084   INS V0, A0, 2, 1
9D003420  AC620544   SW V0, 1348(V1)
208:                     
209:                 
210:                 }
9D003424  03C0E821   ADDU SP, S8, ZERO
9D003428  8FBF001C   LW RA, 28(SP)
9D00342C  8FBE0018   LW S8, 24(SP)
9D003430  8FB00014   LW S0, 20(SP)
9D003434  27BD0020   ADDIU SP, SP, 32
9D003438  03E00008   JR RA
9D00343C  00000000   NOP
211:                 
212:                 /******************************************************************************/
213:                 
214:                 UINT32 TRISThisReadStatus(void)
215:                 {
9D003440  27BDFFF8   ADDIU SP, SP, -8
9D003444  AFBE0004   SW S8, 4(SP)
9D003448  03A0F021   ADDU S8, SP, ZERO
216:                     TRISThisData.status.V5p0Good=P5V_POWER_GOOD;
9D00344C  3C02BF88   LUI V0, -16504
9D003450  8C426110   LW V0, 24848(V0)
9D003454  7C420240   EXT V0, V0, 9, 1
9D003458  304400FF   ANDI A0, V0, 255
9D00345C  3C03A000   LUI V1, -24576
9D003460  8C620544   LW V0, 1348(V1)
9D003464  7C820844   INS V0, A0, 1, 1
9D003468  AC620544   SW V0, 1348(V1)
217:                     return TRISThisData.status.w.Val;
9D00346C  3C02A000   LUI V0, -24576
9D003470  8C420544   LW V0, 1348(V0)
218:                 }
9D003474  03C0E821   ADDU SP, S8, ZERO
9D003478  8FBE0004   LW S8, 4(SP)
9D00347C  27BD0008   ADDIU SP, SP, 8
9D003480  03E00008   JR RA
9D003484  00000000   NOP
219:                 
220:                 /******************************************************************************/
221:                 
222:                 UINT32 TRISThisSetStatus(UINT32 toSet)
223:                 {
9D003488  27BDFFE8   ADDIU SP, SP, -24
9D00348C  AFBF0014   SW RA, 20(SP)
9D003490  AFBE0010   SW S8, 16(SP)
9D003494  03A0F021   ADDU S8, SP, ZERO
9D003498  AFC40018   SW A0, 24(S8)
224:                     TRISThisData.status.w.Val=(toSet & ~STATUS_READ_ONLY_MASK)|
9D00349C  8FC30018   LW V1, 24(S8)
9D0034A0  2402FFFC   ADDIU V0, ZERO, -4
9D0034A4  00621824   AND V1, V1, V0
9D0034B4  00621825   OR V1, V1, V0
9D0034B8  3C02A000   LUI V0, -24576
9D0034BC  AC430544   SW V1, 1348(V0)
225:                             (STATUS_READ_ONLY_MASK & TRISThisData.status.w.Val);
9D0034A8  3C02A000   LUI V0, -24576
9D0034AC  8C420544   LW V0, 1348(V0)
9D0034B0  30420003   ANDI V0, V0, 3
226:                     LEDAutoMode(TRISThisData.status.autoLEDmode);
9D0034C0  3C02A000   LUI V0, -24576
9D0034C4  8C420544   LW V0, 1348(V0)
9D0034C8  7C420080   EXT V0, V0, 2, 1
9D0034CC  304200FF   ANDI V0, V0, 255
9D0034D0  00402021   ADDU A0, V0, ZERO
9D0034D4  0F40146A   JAL LEDAutoMode
9D0034D8  00000000   NOP
227:                     return TRISThisData.status.w.Val;
9D0034DC  3C02A000   LUI V0, -24576
9D0034E0  8C420544   LW V0, 1348(V0)
228:                 }
9D0034E4  03C0E821   ADDU SP, S8, ZERO
9D0034E8  8FBF0014   LW RA, 20(SP)
9D0034EC  8FBE0010   LW S8, 16(SP)
9D0034F0  27BD0018   ADDIU SP, SP, 24
9D0034F4  03E00008   JR RA
9D0034F8  00000000   NOP
229:                 
230:                 /******************************************************************************/
231:                 
232:                 BOOL TRISThisReadLEDMode(void)
233:                 {
9D0034FC  27BDFFF8   ADDIU SP, SP, -8
9D003500  AFBE0004   SW S8, 4(SP)
9D003504  03A0F021   ADDU S8, SP, ZERO
234:                     return TRISThisData.status.autoLEDmode;
9D003508  3C02A000   LUI V0, -24576
9D00350C  8C420544   LW V0, 1348(V0)
9D003510  7C420080   EXT V0, V0, 2, 1
9D003514  304200FF   ANDI V0, V0, 255
235:                 }
9D003518  03C0E821   ADDU SP, S8, ZERO
9D00351C  8FBE0004   LW S8, 4(SP)
9D003520  27BD0008   ADDIU SP, SP, 8
9D003524  03E00008   JR RA
9D003528  00000000   NOP
236:                 
237:                 /******************************************************************************/
238:                 
239:                 void TRISThisSetLEDAutoMode(BOOL autoLED)
240:                 {
9D00352C  27BDFFE8   ADDIU SP, SP, -24
9D003530  AFBF0014   SW RA, 20(SP)
9D003534  AFBE0010   SW S8, 16(SP)
9D003538  03A0F021   ADDU S8, SP, ZERO
9D00353C  AFC40018   SW A0, 24(S8)
241:                     TRISThisData.status.autoLEDmode=LEDAutoMode(autoLED);
9D003540  8FC40018   LW A0, 24(S8)
9D003544  0F40146A   JAL LEDAutoMode
9D003548  00000000   NOP
9D00354C  304200FF   ANDI V0, V0, 255
9D003550  30420001   ANDI V0, V0, 1
9D003554  304400FF   ANDI A0, V0, 255
9D003558  3C03A000   LUI V1, -24576
9D00355C  8C620544   LW V0, 1348(V1)
9D003560  7C821084   INS V0, A0, 2, 1
9D003564  AC620544   SW V0, 1348(V1)
242:                 }
9D003568  03C0E821   ADDU SP, S8, ZERO
9D00356C  8FBF0014   LW RA, 20(SP)
9D003570  8FBE0010   LW S8, 16(SP)
9D003574  27BD0018   ADDIU SP, SP, 24
9D003578  03E00008   JR RA
9D00357C  00000000   NOP
243:                 
244:                 /******************************************************************************/
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/PAC1710.c  ------------------------------------
1:                   /******************************************************************************/
2:                   /* File:   PAC1710.c                                                          */
3:                   /* Author: Matt Bennett                                                       */
4:                   /*                                                                            */
5:                   /* Created on                                                                 */
6:                   /* Updated August 2013                                                        */
7:                   /******************************************************************************/
8:                   /* code to talk to the PAC1710 power/voltage/current monitor                  */
9:                   /******************************************************************************/
10:                  
11:                  #include <common.h>
12:                  #include <PAC1710.h>
13:                  #include <I2C_Bus_Master.h>
14:                  
15:                  BOOL INTalertAsserted;
16:                  PAC1710_STATUS_FLAGS_TYPE PAC1710SubsystemFlags;
17:                  
18:                  PAC1710_Subsystem_TYPE PAC1710subsystem;
19:                  
20:                  UINT16_VAL monitorCurrentHolding;
21:                  UINT16_VAL monitorVoltageHolding;
22:                  
23:                  /******************************************************************************/
24:                  
25:                  BOOL PAC1710SubsystemInitialize(UINT32 address)
26:                  {
9D001490  27BDFFE8   ADDIU SP, SP, -24
9D001494  AFBF0014   SW RA, 20(SP)
9D001498  AFBE0010   SW S8, 16(SP)
9D00149C  03A0F021   ADDU S8, SP, ZERO
9D0014A0  AFC40018   SW A0, 24(S8)
27:                      if(MasterI2CAvailable()&&MasterI2CClaimPort(POWER_MONITOR))
9D0014A4  0F400504   JAL MasterI2CAvailable
9D0014A8  00000000   NOP
9D0014AC  1040002E   BEQ V0, ZERO, 0x9D001568
9D0014B0  00000000   NOP
9D0014B4  24040002   ADDIU A0, ZERO, 2
9D0014B8  0F4004DF   JAL MasterI2CClaimPort
9D0014BC  00000000   NOP
9D0014C0  10400029   BEQ V0, ZERO, 0x9D001568
9D0014C4  00000000   NOP
28:                      {
29:                          PAC1710SubsystemFlags.w=0;
9D0014C8  AF80804C   SW ZERO, -32692(GP)
30:                          if(PAC1710Present(address))
9D0014CC  8FC40018   LW A0, 24(S8)
9D0014D0  0F400562   JAL PAC1710Present
9D0014D4  00000000   NOP
9D0014D8  1040001E   BEQ V0, ZERO, 0x9D001554
9D0014DC  00000000   NOP
31:                          {
32:                              if(PAC1710Configure(address))
9D0014E0  8FC40018   LW A0, 24(S8)
9D0014E4  0F4005B8   JAL PAC1710Configure
9D0014E8  00000000   NOP
9D0014EC  10400014   BEQ V0, ZERO, 0x9D001540
9D0014F0  00000000   NOP
33:                              {
34:                                  PAC1710SubsystemFlags.monitorConfigured=TRUE;
9D0014F4  8F82804C   LW V0, -32692(GP)
9D0014F8  24030001   ADDIU V1, ZERO, 1
9D0014FC  7C620844   INS V0, V1, 1, 1
9D001500  AF82804C   SW V0, -32692(GP)
35:                                  /* Yay! */
36:                              }
37:                              else
38:                              {
39:                                  MasterI2CReleasePort();
9D001540  0F4004FB   JAL MasterI2CReleasePort
9D001544  00000000   NOP
40:                                  return FALSE;
9D001548  00001021   ADDU V0, ZERO, ZERO
9D00154C  0B40055C   J 0x9D001570
9D001550  00000000   NOP
41:                              }
42:                          }
43:                          else
44:                          {
45:                              MasterI2CReleasePort();
9D001554  0F4004FB   JAL MasterI2CReleasePort
9D001558  00000000   NOP
46:                              return FALSE;
9D00155C  00001021   ADDU V0, ZERO, ZERO
9D001560  0B40055C   J 0x9D001570
9D001564  00000000   NOP
9D001568  0B40055C   J 0x9D001570
9D00156C  00000000   NOP
47:                              //while(TRUE);
48:                          }
49:                          PAC1710AlertConfigure();
9D001504  0F400617   JAL PAC1710AlertConfigure
9D001508  00000000   NOP
50:                          /* is at least one configured? */
51:                          PAC1710SubsystemFlags.subsystemConfigured=
9D001518  8F82804C   LW V0, -32692(GP)
9D00151C  7C622104   INS V0, V1, 4, 1
9D001520  AF82804C   SW V0, -32692(GP)
52:                                  PAC1710SubsystemFlags.monitorConfigured;
9D00150C  8F82804C   LW V0, -32692(GP)
9D001510  7C420040   EXT V0, V0, 1, 1
9D001514  304300FF   ANDI V1, V0, 255
53:                          MasterI2CReleasePort();
9D001524  0F4004FB   JAL MasterI2CReleasePort
9D001528  00000000   NOP
54:                          return PAC1710SubsystemFlags.subsystemConfigured;
9D00152C  8F82804C   LW V0, -32692(GP)
9D001530  7C420100   EXT V0, V0, 4, 1
9D001534  304200FF   ANDI V0, V0, 255
9D001538  0B40055C   J 0x9D001570
9D00153C  00000000   NOP
55:                      }
56:                  }
9D001570  03C0E821   ADDU SP, S8, ZERO
9D001574  8FBF0014   LW RA, 20(SP)
9D001578  8FBE0010   LW S8, 16(SP)
9D00157C  27BD0018   ADDIU SP, SP, 24
9D001580  03E00008   JR RA
9D001584  00000000   NOP
57:                  
58:                  /******************************************************************************/
59:                  
60:                  BOOL PAC1710Present(UINT32 address)
61:                  {
9D001588  27BDFFD0   ADDIU SP, SP, -48
9D00158C  AFBF002C   SW RA, 44(SP)
9D001590  AFBE0028   SW S8, 40(SP)
9D001594  03A0F021   ADDU S8, SP, ZERO
9D001598  AFC40030   SW A0, 48(S8)
62:                      UINT8 productID=0;
9D00159C  A3C00020   SB ZERO, 32(S8)
63:                      UINT8 SMSCID=0;
9D0015A0  A3C00021   SB ZERO, 33(S8)
64:                      UINT8 revision=0;
9D0015A4  A3C00022   SB ZERO, 34(S8)
65:                      BOOL productIDGoodRead=FALSE;
9D0015A8  AFC00010   SW ZERO, 16(S8)
66:                      BOOL SMSCIDGoodRead=FALSE;
9D0015AC  AFC00014   SW ZERO, 20(S8)
67:                      BOOL revisionGoodRead=FALSE;
9D0015B0  AFC00018   SW ZERO, 24(S8)
68:                      BOOL returnValue=FALSE;
9D0015B4  AFC0001C   SW ZERO, 28(S8)
69:                      if(MasterI2CHasPort(POWER_MONITOR))
9D0015B8  24040002   ADDIU A0, ZERO, 2
9D0015BC  0F400513   JAL MasterI2CHasPort
9D0015C0  00000000   NOP
9D0015C4  10400028   BEQ V0, ZERO, 0x9D001668
9D0015C8  00000000   NOP
70:                      //if(MasterI2CAvailable()&&MasterI2CClaimPort(POWER_MONITOR))
71:                      {
72:                          if(MasterI2CReadByte(address,PAC1710_REG_PRODUCT_ID,&productID))
9D0015CC  8FC20030   LW V0, 48(S8)
9D0015D0  304200FF   ANDI V0, V0, 255
9D0015D4  00401821   ADDU V1, V0, ZERO
9D0015D8  27C20020   ADDIU V0, S8, 32
9D0015DC  00602021   ADDU A0, V1, ZERO
9D0015E0  240500FD   ADDIU A1, ZERO, 253
9D0015E4  00403021   ADDU A2, V0, ZERO
9D0015E8  0F4003E3   JAL MasterI2CReadByte
9D0015EC  00000000   NOP
9D0015F0  10400003   BEQ V0, ZERO, 0x9D001600
9D0015F4  00000000   NOP
73:                          {
74:                              productIDGoodRead=TRUE;
9D0015F8  24020001   ADDIU V0, ZERO, 1
9D0015FC  AFC20010   SW V0, 16(S8)
75:                          }
76:                          if(MasterI2CReadByte(address,PAC1710_REG_SMSC_ID,&SMSCID))
9D001600  8FC20030   LW V0, 48(S8)
9D001604  304200FF   ANDI V0, V0, 255
9D001608  00401821   ADDU V1, V0, ZERO
9D00160C  27C20021   ADDIU V0, S8, 33
9D001610  00602021   ADDU A0, V1, ZERO
9D001614  240500FE   ADDIU A1, ZERO, 254
9D001618  00403021   ADDU A2, V0, ZERO
9D00161C  0F4003E3   JAL MasterI2CReadByte
9D001620  00000000   NOP
9D001624  10400003   BEQ V0, ZERO, 0x9D001634
9D001628  00000000   NOP
77:                          {
78:                              SMSCIDGoodRead=TRUE;
9D00162C  24020001   ADDIU V0, ZERO, 1
9D001630  AFC20014   SW V0, 20(S8)
79:                          }
80:                          if(MasterI2CReadByte(address,PAC1710_REG_REVISION,&revision))
9D001634  8FC20030   LW V0, 48(S8)
9D001638  304200FF   ANDI V0, V0, 255
9D00163C  00401821   ADDU V1, V0, ZERO
9D001640  27C20022   ADDIU V0, S8, 34
9D001644  00602021   ADDU A0, V1, ZERO
9D001648  240500FF   ADDIU A1, ZERO, 255
9D00164C  00403021   ADDU A2, V0, ZERO
9D001650  0F4003E3   JAL MasterI2CReadByte
9D001654  00000000   NOP
9D001658  10400003   BEQ V0, ZERO, 0x9D001668
9D00165C  00000000   NOP
81:                          {
82:                              revisionGoodRead=TRUE;
9D001660  24020001   ADDIU V0, ZERO, 1
9D001664  AFC20018   SW V0, 24(S8)
83:                          }
84:                      }
85:                      if ((productIDGoodRead&&(productID==PAC1710_PRODUCT_ID))&&
9D001668  8FC20010   LW V0, 16(S8)
9D00166C  10400015   BEQ V0, ZERO, 0x9D0016C4
9D001670  00000000   NOP
9D001674  93C30020   LBU V1, 32(S8)
9D001678  24020058   ADDIU V0, ZERO, 88
9D00167C  14620011   BNE V1, V0, 0x9D0016C4
9D001680  00000000   NOP
9D001684  8FC20014   LW V0, 20(S8)
9D001688  1040000E   BEQ V0, ZERO, 0x9D0016C4
9D00168C  00000000   NOP
86:                          (SMSCIDGoodRead&&(SMSCID==PAC1710_SMSC_ID))&&
9D001690  93C30021   LBU V1, 33(S8)
9D001694  2402005D   ADDIU V0, ZERO, 93
9D001698  1462000A   BNE V1, V0, 0x9D0016C4
9D00169C  00000000   NOP
9D0016A0  8FC20018   LW V0, 24(S8)
9D0016A4  10400007   BEQ V0, ZERO, 0x9D0016C4
9D0016A8  00000000   NOP
87:                          (revisionGoodRead&&(revision==PAC1710_REVISION)))
9D0016AC  93C30022   LBU V1, 34(S8)
9D0016B0  24020081   ADDIU V0, ZERO, 129
9D0016B4  14620003   BNE V1, V0, 0x9D0016C4
9D0016B8  00000000   NOP
88:                      {
89:                          returnValue=TRUE;
9D0016BC  24020001   ADDIU V0, ZERO, 1
9D0016C0  AFC2001C   SW V0, 28(S8)
90:                      }
91:                      //MasterI2CReleasePort();
92:                      return returnValue;
9D0016C4  8FC2001C   LW V0, 28(S8)
93:                  }
9D0016C8  03C0E821   ADDU SP, S8, ZERO
9D0016CC  8FBF002C   LW RA, 44(SP)
9D0016D0  8FBE0028   LW S8, 40(SP)
9D0016D4  27BD0030   ADDIU SP, SP, 48
9D0016D8  03E00008   JR RA
9D0016DC  00000000   NOP
94:                  
95:                  /******************************************************************************/
96:                  
97:                  BOOL PAC1710Configure(UINT32 address)
98:                  {
9D0016E0  27BDFFD0   ADDIU SP, SP, -48
9D0016E4  AFBF002C   SW RA, 44(SP)
9D0016E8  AFBE0028   SW S8, 40(SP)
9D0016EC  03A0F021   ADDU S8, SP, ZERO
9D0016F0  AFC40030   SW A0, 48(S8)
99:                      UINT8 dataRead;
100:                     PAC1710_CONFIGURATION_REG_TYPE config;
101:                     PAC1710_VSENSE_REG_TYPE vsense;
102:                     PAC1710_VSOURCE_SAMPLING_CONFIG_REG_TYPE vsourceConfig;
103:                     BOOL returnValue=FALSE;
9D0016F4  AFC00010   SW ZERO, 16(S8)
104:                     if(MasterI2CHasPort(POWER_MONITOR))
9D0016F8  24040002   ADDIU A0, ZERO, 2
9D0016FC  0F400513   JAL MasterI2CHasPort
9D001700  00000000   NOP
9D001704  1040004C   BEQ V0, ZERO, 0x9D001838
9D001708  00000000   NOP
105:                     //if(MasterI2CAvailable()&&MasterI2CClaimPort(POWER_MONITOR))
106:                     {
107:                         vsourceConfig.b=0;
9D00170C  A3C00020   SB ZERO, 32(S8)
108:                         vsense.b=0;
9D001710  A3C0001C   SB ZERO, 28(S8)
109:                         config.b=0;
9D001714  A3C00018   SB ZERO, 24(S8)
110:                         config.b=0;
9D001718  A3C00018   SB ZERO, 24(S8)
111:                         vsourceConfig.VSRC_AVG=VSRC_AVERAGE_DISABLED;
9D00171C  8FC20020   LW V0, 32(S8)
9D001720  7C021884   INS V0, ZERO, 2, 2
9D001724  AFC20020   SW V0, 32(S8)
112:                         vsourceConfig.VSRC_SAMP_TIME=VSRC_SAMPLE_TIME_20_MS;
9D001728  8FC20020   LW V0, 32(S8)
9D00172C  24030003   ADDIU V1, ZERO, 3
9D001730  7C620804   INS V0, V1, 0, 2
9D001734  AFC20020   SW V0, 32(S8)
113:                         vsense.CS_RNG=CS_RANGE_10MV;
9D001738  8FC2001C   LW V0, 28(S8)
9D00173C  7C020804   INS V0, ZERO, 0, 2
9D001740  AFC2001C   SW V0, 28(S8)
114:                         vsense.CS_SAMP_AVG=CS_SAMP_DISABLED;
9D001744  8FC2001C   LW V0, 28(S8)
9D001748  7C021884   INS V0, ZERO, 2, 2
9D00174C  AFC2001C   SW V0, 28(S8)
115:                         vsense.CS_SAMP_TIME=CS_SAMPLE_TIME_10_MS;
9D001750  8FC2001C   LW V0, 28(S8)
9D001754  24030002   ADDIU V1, ZERO, 2
9D001758  7C623104   INS V0, V1, 4, 3
9D00175C  AFC2001C   SW V0, 28(S8)
116:                         config.CONV_DONE_EN=TRUE;
9D001760  8FC20018   LW V0, 24(S8)
9D001764  24030001   ADDIU V1, ZERO, 1
9D001768  7C623184   INS V0, V1, 6, 1
9D00176C  AFC20018   SW V0, 24(S8)
117:                         //config.MASK_ALL=TRUE;
118:                 
119:                         if(MasterI2CWriteVerifyByteNoRetry(address,PAC1710_REG_CONFIGURATION,config.b))
9D001770  8FC20030   LW V0, 48(S8)
9D001774  304200FF   ANDI V0, V0, 255
9D001778  00401821   ADDU V1, V0, ZERO
9D00177C  93C20018   LBU V0, 24(S8)
9D001780  00602021   ADDU A0, V1, ZERO
9D001784  00002821   ADDU A1, ZERO, ZERO
9D001788  00403021   ADDU A2, V0, ZERO
9D00178C  0F400457   JAL MasterI2CWriteVerifyByteNoRetry
9D001790  00000000   NOP
9D001794  10400028   BEQ V0, ZERO, 0x9D001838
9D001798  00000000   NOP
120:                         {
121:                             if(MasterI2CWriteVerifyByteNoRetry(address,PAC1710_REG_VSOURCE_CONFIG,vsourceConfig.b))
9D00179C  8FC20030   LW V0, 48(S8)
9D0017A0  304200FF   ANDI V0, V0, 255
9D0017A4  00401821   ADDU V1, V0, ZERO
9D0017A8  93C20020   LBU V0, 32(S8)
9D0017AC  00602021   ADDU A0, V1, ZERO
9D0017B0  2405000A   ADDIU A1, ZERO, 10
9D0017B4  00403021   ADDU A2, V0, ZERO
9D0017B8  0F400457   JAL MasterI2CWriteVerifyByteNoRetry
9D0017BC  00000000   NOP
9D0017C0  1040001D   BEQ V0, ZERO, 0x9D001838
9D0017C4  00000000   NOP
122:                             {
123:                                 if(MasterI2CWriteVerifyByteNoRetry(address,PAC1710_REG_VSENSE_CONFIG,vsense.b))
9D0017C8  8FC20030   LW V0, 48(S8)
9D0017CC  304200FF   ANDI V0, V0, 255
9D0017D0  00401821   ADDU V1, V0, ZERO
9D0017D4  93C2001C   LBU V0, 28(S8)
9D0017D8  00602021   ADDU A0, V1, ZERO
9D0017DC  2405000B   ADDIU A1, ZERO, 11
9D0017E0  00403021   ADDU A2, V0, ZERO
9D0017E4  0F400457   JAL MasterI2CWriteVerifyByteNoRetry
9D0017E8  00000000   NOP
9D0017EC  10400012   BEQ V0, ZERO, 0x9D001838
9D0017F0  00000000   NOP
124:                                 {
125:                                     if(MasterI2CReadByte(address,PAC1710_REG_CONV_RATE,&dataRead))
9D0017F4  8FC20030   LW V0, 48(S8)
9D0017F8  304200FF   ANDI V0, V0, 255
9D0017FC  00401821   ADDU V1, V0, ZERO
9D001800  27C20014   ADDIU V0, S8, 20
9D001804  00602021   ADDU A0, V1, ZERO
9D001808  24050001   ADDIU A1, ZERO, 1
9D00180C  00403021   ADDU A2, V0, ZERO
9D001810  0F4003E3   JAL MasterI2CReadByte
9D001814  00000000   NOP
9D001818  10400007   BEQ V0, ZERO, 0x9D001838
9D00181C  00000000   NOP
126:                                     {
127:                                         if(dataRead==0x03)
9D001820  93C30014   LBU V1, 20(S8)
9D001824  24020003   ADDIU V0, ZERO, 3
9D001828  14620003   BNE V1, V0, 0x9D001838
9D00182C  00000000   NOP
128:                                         {
129:                                             returnValue= TRUE;
9D001830  24020001   ADDIU V0, ZERO, 1
9D001834  AFC20010   SW V0, 16(S8)
130:                                         }
131:                                     }
132:                                 }
133:                             }
134:                         }
135:                     }
136:                     MasterI2CReleasePort();
9D001838  0F4004FB   JAL MasterI2CReleasePort
9D00183C  00000000   NOP
137:                     return returnValue;
9D001840  8FC20010   LW V0, 16(S8)
138:                 }
9D001844  03C0E821   ADDU SP, S8, ZERO
9D001848  8FBF002C   LW RA, 44(SP)
9D00184C  8FBE0028   LW S8, 40(SP)
9D001850  27BD0030   ADDIU SP, SP, 48
9D001854  03E00008   JR RA
9D001858  00000000   NOP
139:                 
140:                 /******************************************************************************/
141:                 
142:                 void PAC1710AlertConfigure(void)
143:                 {
9D00185C  27BDFFE8   ADDIU SP, SP, -24
9D001860  AFBF0014   SW RA, 20(SP)
9D001864  AFBE0010   SW S8, 16(SP)
9D001868  03A0F021   ADDU S8, SP, ZERO
144:                     ALERT_N_DIRECTION=TRIS_IN;
9D00186C  3C03BF88   LUI V1, -16504
9D001870  8C626100   LW V0, 24832(V1)
9D001874  24040001   ADDIU A0, ZERO, 1
9D001878  7C824204   INS V0, A0, 8, 1
9D00187C  AC626100   SW V0, 24832(V1)
145:                     INTalertAsserted=FALSE;
9D001880  AF808054   SW ZERO, -32684(GP)
146:                     PAC1710SubsystemFlags.alertAsserted=FALSE;
9D001884  8F82804C   LW V0, -32692(GP)
9D001888  7C020004   INS V0, ZERO, 0, 1
9D00188C  AF82804C   SW V0, -32692(GP)
147:                     INTCONbits.INT1EP=FALSE; /* set for falling edge interrupt */
9D001890  3C03BF88   LUI V1, -16504
9D001894  8C621000   LW V0, 4096(V1)
9D001898  7C020844   INS V0, ZERO, 1, 1
9D00189C  AC621000   SW V0, 4096(V1)
148:                     INTSetVectorPriority(INT_INT1,ALERT_INT_PRIORITY);
9D0018A0  24040004   ADDIU A0, ZERO, 4
9D0018A4  24050004   ADDIU A1, ZERO, 4
9D0018A8  0F401753   JAL INTSetVectorPriority
9D0018AC  00000000   NOP
149:                     INTClearFlag(INT_INT1);
9D0018B0  24040004   ADDIU A0, ZERO, 4
9D0018B4  0F4017B8   JAL INTClearFlag
9D0018B8  00000000   NOP
150:                     INTEnable(INT_INT1,INT_ENABLED);
9D0018BC  24040004   ADDIU A0, ZERO, 4
9D0018C0  24050001   ADDIU A1, ZERO, 1
9D0018C4  0F4016DD   JAL INTEnable
9D0018C8  00000000   NOP
151:                 }
9D0018CC  03C0E821   ADDU SP, S8, ZERO
9D0018D0  8FBF0014   LW RA, 20(SP)
9D0018D4  8FBE0010   LW S8, 16(SP)
9D0018D8  27BD0018   ADDIU SP, SP, 24
9D0018DC  03E00008   JR RA
9D0018E0  00000000   NOP
152:                 
153:                 /******************************************************************************/
154:                 
155:                 BOOL IsAlertAsserted(void)
156:                 {
9D0018E4  27BDFFE0   ADDIU SP, SP, -32
9D0018E8  AFBF001C   SW RA, 28(SP)
9D0018EC  AFBE0018   SW S8, 24(SP)
9D0018F0  03A0F021   ADDU S8, SP, ZERO
157:                     BOOL returnValue;
158:                     INTEnable(INT_INT1,INT_DISABLED);
9D0018F4  24040004   ADDIU A0, ZERO, 4
9D0018F8  00002821   ADDU A1, ZERO, ZERO
9D0018FC  0F4016DD   JAL INTEnable
9D001900  00000000   NOP
159:                     returnValue=INTalertAsserted;
9D001904  8F828054   LW V0, -32684(GP)
9D001908  AFC20010   SW V0, 16(S8)
160:                     /* if alert is not asserted, re-enable the interrupt */
161:                     if(!returnValue)
9D00190C  8FC20010   LW V0, 16(S8)
9D001910  14400005   BNE V0, ZERO, 0x9D001928
9D001914  00000000   NOP
162:                     {
163:                         INTEnable(INT_INT1,INT_ENABLED);
9D001918  24040004   ADDIU A0, ZERO, 4
9D00191C  24050001   ADDIU A1, ZERO, 1
9D001920  0F4016DD   JAL INTEnable
9D001924  00000000   NOP
164:                     }
165:                     return returnValue;
9D001928  8FC20010   LW V0, 16(S8)
166:                 }
9D00192C  03C0E821   ADDU SP, S8, ZERO
9D001930  8FBF001C   LW RA, 28(SP)
9D001934  8FBE0018   LW S8, 24(SP)
9D001938  27BD0020   ADDIU SP, SP, 32
9D00193C  03E00008   JR RA
9D001940  00000000   NOP
167:                 
168:                 /******************************************************************************/
169:                 
170:                 void ClearAlertAsserted(void)
171:                 {
9D001944  27BDFFE8   ADDIU SP, SP, -24
9D001948  AFBF0014   SW RA, 20(SP)
9D00194C  AFBE0010   SW S8, 16(SP)
9D001950  03A0F021   ADDU S8, SP, ZERO
172:                     INTEnable(INT_INT1,INT_DISABLED);
9D001954  24040004   ADDIU A0, ZERO, 4
9D001958  00002821   ADDU A1, ZERO, ZERO
9D00195C  0F4016DD   JAL INTEnable
9D001960  00000000   NOP
173:                     INTalertAsserted=FALSE;
9D001964  AF808054   SW ZERO, -32684(GP)
174:                     INTEnable(INT_INT1,INT_ENABLED);
9D001968  24040004   ADDIU A0, ZERO, 4
9D00196C  24050001   ADDIU A1, ZERO, 1
9D001970  0F4016DD   JAL INTEnable
9D001974  00000000   NOP
175:                 }
9D001978  03C0E821   ADDU SP, S8, ZERO
9D00197C  8FBF0014   LW RA, 20(SP)
9D001980  8FBE0010   LW S8, 16(SP)
9D001984  27BD0018   ADDIU SP, SP, 24
9D001988  03E00008   JR RA
9D00198C  00000000   NOP
176:                 
177:                 /******************************************************************************/
178:                 
179:                 void __ISR (_EXTERNAL_1_VECTOR,ALERT_INT_PRIORITY_ISR) _INT1Interrupt(void)
180:                 {
9D001990  415DE800   RDPGPR SP, SP
9D001994  401A7000   MFC0 K0, EPC
9D001998  401B6000   MFC0 K1, Status
9D00199C  27BDFF90   ADDIU SP, SP, -112
9D0019A0  AFBA006C   SW K0, 108(SP)
9D0019A4  AFBB0068   SW K1, 104(SP)
9D0019A8  7C1B7844   INS K1, ZERO, 1, 15
9D0019AC  377B1000   ORI K1, K1, 4096
9D0019B0  409B6000   MTC0 K1, Status
9D0019B4  AFBF005C   SW RA, 92(SP)
9D0019B8  AFBE0058   SW S8, 88(SP)
9D0019BC  AFB90054   SW T9, 84(SP)
9D0019C0  AFB80050   SW T8, 80(SP)
9D0019C4  AFAF004C   SW T7, 76(SP)
9D0019C8  AFAE0048   SW T6, 72(SP)
9D0019CC  AFAD0044   SW T5, 68(SP)
9D0019D0  AFAC0040   SW T4, 64(SP)
9D0019D4  AFAB003C   SW T3, 60(SP)
9D0019D8  AFAA0038   SW T2, 56(SP)
9D0019DC  AFA90034   SW T1, 52(SP)
9D0019E0  AFA80030   SW T0, 48(SP)
9D0019E4  AFA7002C   SW A3, 44(SP)
9D0019E8  AFA60028   SW A2, 40(SP)
9D0019EC  AFA50024   SW A1, 36(SP)
9D0019F0  AFA40020   SW A0, 32(SP)
9D0019F4  AFA3001C   SW V1, 28(SP)
9D0019F8  AFA20018   SW V0, 24(SP)
9D0019FC  AFA10014   SW AT, 20(SP)
9D001A00  00001012   MFLO V0, 0
9D001A04  AFA20064   SW V0, 100(SP)
9D001A08  00001810   MFHI V1, 0
9D001A0C  AFA30060   SW V1, 96(SP)
9D001A10  03A0F021   ADDU S8, SP, ZERO
181:                     INTEnable(INT_INT1,INT_DISABLED);
9D001A14  24040004   ADDIU A0, ZERO, 4
9D001A18  00002821   ADDU A1, ZERO, ZERO
9D001A1C  0F4016DD   JAL INTEnable
9D001A20  00000000   NOP
182:                     INTClearFlag(INT_INT1);
9D001A24  24040004   ADDIU A0, ZERO, 4
9D001A28  0F4017B8   JAL INTClearFlag
9D001A2C  00000000   NOP
183:                     INTalertAsserted=TRUE;
9D001A30  24020001   ADDIU V0, ZERO, 1
9D001A34  AF828054   SW V0, -32684(GP)
184:                 }
9D001A38  03C0E821   ADDU SP, S8, ZERO
9D001A3C  8FA20064   LW V0, 100(SP)
9D001A40  00400013   MTLO V0, 0
9D001A44  8FA30060   LW V1, 96(SP)
9D001A48  00600011   MTHI V1, 0
9D001A4C  8FBF005C   LW RA, 92(SP)
9D001A50  8FBE0058   LW S8, 88(SP)
9D001A54  8FB90054   LW T9, 84(SP)
9D001A58  8FB80050   LW T8, 80(SP)
9D001A5C  8FAF004C   LW T7, 76(SP)
9D001A60  8FAE0048   LW T6, 72(SP)
9D001A64  8FAD0044   LW T5, 68(SP)
9D001A68  8FAC0040   LW T4, 64(SP)
9D001A6C  8FAB003C   LW T3, 60(SP)
9D001A70  8FAA0038   LW T2, 56(SP)
9D001A74  8FA90034   LW T1, 52(SP)
9D001A78  8FA80030   LW T0, 48(SP)
9D001A7C  8FA7002C   LW A3, 44(SP)
9D001A80  8FA60028   LW A2, 40(SP)
9D001A84  8FA50024   LW A1, 36(SP)
9D001A88  8FA40020   LW A0, 32(SP)
9D001A8C  8FA3001C   LW V1, 28(SP)
9D001A90  8FA20018   LW V0, 24(SP)
9D001A94  8FA10014   LW AT, 20(SP)
9D001A98  41606000   DI ZERO
9D001A9C  000000C0   EHB
9D001AA0  8FBA006C   LW K0, 108(SP)
9D001AA4  8FBB0068   LW K1, 104(SP)
9D001AA8  409A7000   MTC0 K0, EPC
9D001AAC  27BD0070   ADDIU SP, SP, 112
9D001AB0  41DDE800   WRPGPR SP, SP
9D001AB4  409B6000   MTC0 K1, Status
9D001AB8  42000018   ERET
185:                 
186:                 /******************************************************************************/
187:                 
188:                 BOOL DoPowerMonState(void)
189:                 {
9D001ABC  27BDFFE0   ADDIU SP, SP, -32
9D001AC0  AFBF001C   SW RA, 28(SP)
9D001AC4  AFBE0018   SW S8, 24(SP)
9D001AC8  03A0F021   ADDU S8, SP, ZERO
190:                     static enum POWER_MONITOR_STATE_TYPE state=PM_STATE_IDLE;
191:                     static I2CBUS_COMMAND_TYPE command;
192:                     if(!PAC1710SubsystemFlags.subsystemConfigured)
9D001ACC  8F82804C   LW V0, -32692(GP)
9D001AD0  30420010   ANDI V0, V0, 16
9D001AD4  14400004   BNE V0, ZERO, 0x9D001AE8
9D001AD8  00000000   NOP
193:                     {
194:                         return FALSE;
9D001ADC  00001021   ADDU V0, ZERO, ZERO
9D001AE0  0B4007F8   J 0x9D001FE0
9D001AE4  00000000   NOP
195:                     }
196:                     if(!MasterI2CHasPort(POWER_MONITOR))
9D001AE8  24040002   ADDIU A0, ZERO, 2
9D001AEC  0F400513   JAL MasterI2CHasPort
9D001AF0  00000000   NOP
9D001AF4  14400010   BNE V0, ZERO, 0x9D001B38
9D001AF8  00000000   NOP
197:                     {
198:                         if(MasterI2CAvailable())
9D001AFC  0F400504   JAL MasterI2CAvailable
9D001B00  00000000   NOP
9D001B04  10400009   BEQ V0, ZERO, 0x9D001B2C
9D001B08  00000000   NOP
199:                         {
200:                             /* if the port is available, claim it */
201:                             if(!MasterI2CClaimPort(POWER_MONITOR))
9D001B0C  24040002   ADDIU A0, ZERO, 2
9D001B10  0F4004DF   JAL MasterI2CClaimPort
9D001B14  00000000   NOP
9D001B18  14400007   BNE V0, ZERO, 0x9D001B38
9D001B1C  00000000   NOP
202:                             {
203:                                 return FALSE;
9D001B20  00001021   ADDU V0, ZERO, ZERO
9D001B24  0B4007F8   J 0x9D001FE0
9D001B28  00000000   NOP
204:                             }
205:                         }
206:                         else
207:                         {
208:                             /* port not available */
209:                             return FALSE;
9D001B2C  00001021   ADDU V0, ZERO, ZERO
9D001B30  0B4007F8   J 0x9D001FE0
9D001B34  00000000   NOP
210:                         }
211:                     }
212:                     /* only get here if the port is claimed by the power monitor subsystem */
213:                     PAC1710SubsystemFlags.alertAsserted=IsAlertAsserted();
9D001B38  0F400639   JAL IsAlertAsserted
9D001B3C  00000000   NOP
9D001B40  304200FF   ANDI V0, V0, 255
9D001B44  30420001   ANDI V0, V0, 1
9D001B48  304300FF   ANDI V1, V0, 255
9D001B4C  8F82804C   LW V0, -32692(GP)
9D001B50  7C620004   INS V0, V1, 0, 1
9D001B54  AF82804C   SW V0, -32692(GP)
214:                     switch (state)
9D001B58  8F828020   LW V0, -32736(GP)
9D001B5C  2C430009   SLTIU V1, V0, 9
9D001B60  106000FD   BEQ V1, ZERO, 0x9D001F58
9D001B64  00000000   NOP
9D001B68  00021880   SLL V1, V0, 2
9D001B6C  3C029D00   LUI V0, -25344
9D001B70  24421B84   ADDIU V0, V0, 7044
9D001B74  00621021   ADDU V0, V1, V0
9D001B78  8C420000   LW V0, 0(V0)
9D001B7C  00400008   JR V0
9D001B80  00000000   NOP
215:                     {
216:                         case PM_STATE_IDLE:
217:                         {
218:                             if (PAC1710SubsystemFlags.alertAsserted)
9D001BA8  8F82804C   LW V0, -32692(GP)
9D001BAC  30420001   ANDI V0, V0, 1
9D001BB0  104000EE   BEQ V0, ZERO, 0x9D001F6C
9D001BB4  00000000   NOP
219:                             {
220:                                 if (PAC1710SubsystemFlags.monitorConfigured)
9D001BB8  8F82804C   LW V0, -32692(GP)
9D001BBC  30420002   ANDI V0, V0, 2
9D001BC0  10400005   BEQ V0, ZERO, 0x9D001BD8
9D001BC4  00000000   NOP
221:                                 {
222:                                     state = PM_STATE_CHECK_MONITOR;
9D001BC8  24020001   ADDIU V0, ZERO, 1
9D001BCC  AF828020   SW V0, -32736(GP)
223:                                 } 
224:                                 else
225:                                 {
226:                                     state = PM_STATE_ALERT_WRAP_UP;
9D001BD8  24020008   ADDIU V0, ZERO, 8
9D001BDC  AF828020   SW V0, -32736(GP)
227:                                 }
228:                             }
229:                             break;
9D001BD0  0B4007F7   J 0x9D001FDC
9D001BD4  00000000   NOP
9D001BE0  0B4007F7   J 0x9D001FDC
9D001BE4  00000000   NOP
9D001F6C  00000000   NOP
9D001F70  0B4007F7   J 0x9D001FDC
9D001F74  00000000   NOP
230:                         }
231:                         case PM_STATE_CHECK_MONITOR:
232:                         {
233:                             if (!MasterI2CIsBusy())
9D001BE8  0F40039B   JAL MasterI2CIsBusy
9D001BEC  00000000   NOP
9D001BF0  144000E1   BNE V0, ZERO, 0x9D001F78
9D001BF4  00000000   NOP
234:                             {
235:                                 command.status.flags.I2C_read = TRUE;
9D001BF8  3C03A000   LUI V1, -24576
9D001BFC  8C620570   LW V0, 1392(V1)
9D001C00  24040001   ADDIU A0, ZERO, 1
9D001C04  7C821084   INS V0, A0, 2, 1
9D001C08  AC620570   SW V0, 1392(V1)
236:                                 command.target_address = PAC1710_ADDRESS;
9D001C0C  3C02A000   LUI V0, -24576
9D001C10  24420570   ADDIU V0, V0, 1392
9D001C14  24030030   ADDIU V1, ZERO, 48
9D001C18  A0430004   SB V1, 4(V0)
237:                                 command.Word[0] = PAC1710_REG_HIGH_LIMIT_STATUS;
9D001C1C  3C02A000   LUI V0, -24576
9D001C20  24420570   ADDIU V0, V0, 1392
9D001C24  24030004   ADDIU V1, ZERO, 4
9D001C28  A0430005   SB V1, 5(V0)
238:                                 command.WordSize = 1;
9D001C2C  3C02A000   LUI V0, -24576
9D001C30  24420570   ADDIU V0, V0, 1392
9D001C34  24030001   ADDIU V1, ZERO, 1
9D001C38  A043001A   SB V1, 26(V0)
239:                                 command.DataSize = 1;
9D001C3C  3C02A000   LUI V0, -24576
9D001C40  24420570   ADDIU V0, V0, 1392
9D001C44  24030001   ADDIU V1, ZERO, 1
9D001C48  A0430019   SB V1, 25(V0)
240:                                 if (MasterI2CQueueCommand(&command))
9D001C4C  3C02A000   LUI V0, -24576
9D001C50  24440570   ADDIU A0, V0, 1392
9D001C54  0F400271   JAL MasterI2CQueueCommand
9D001C58  00000000   NOP
9D001C5C  104000C9   BEQ V0, ZERO, 0x9D001F84
9D001C60  00000000   NOP
241:                                 {
242:                                     state = PM_STATE_CHECK_MONITOR_WAIT;
9D001C64  24020002   ADDIU V0, ZERO, 2
9D001C68  AF828020   SW V0, -32736(GP)
243:                                 }
244:                             }
245:                             break;
9D001C6C  0B4007F7   J 0x9D001FDC
9D001C70  00000000   NOP
9D001F78  00000000   NOP
9D001F7C  0B4007F7   J 0x9D001FDC
9D001F80  00000000   NOP
9D001F84  00000000   NOP
9D001F88  0B4007F7   J 0x9D001FDC
9D001F8C  00000000   NOP
246:                         }
247:                         case PM_STATE_CHECK_MONITOR_WAIT:
248:                         {
249:                             if (MasterI2CUpdateQueuedCommand(&command))
9D001C74  3C02A000   LUI V0, -24576
9D001C78  24440570   ADDIU A0, V0, 1392
9D001C7C  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D001C80  00000000   NOP
9D001C84  10400011   BEQ V0, ZERO, 0x9D001CCC
9D001C88  00000000   NOP
250:                             {
251:                                 PAC1710_HIGH_LIMIT_STATUS_REG_TYPE reg;
252:                                 reg.b = command.Data[0];
9D001C8C  3C02A000   LUI V0, -24576
9D001C90  24420570   ADDIU V0, V0, 1392
9D001C94  9042000F   LBU V0, 15(V0)
9D001C98  A3C20010   SB V0, 16(S8)
253:                                 if (reg.CONV_DONE)
9D001C9C  8FC20010   LW V0, 16(S8)
9D001CA0  30420080   ANDI V0, V0, 128
9D001CA4  10400005   BEQ V0, ZERO, 0x9D001CBC
9D001CA8  00000000   NOP
254:                                 {
255:                                     state = PM_STATE_READ_MONITOR_VOLTAGE;
9D001CAC  24020003   ADDIU V0, ZERO, 3
9D001CB0  AF828020   SW V0, -32736(GP)
256:                                 }
257:                                 else
258:                                 {
259:                                     state = PM_STATE_ALERT_WRAP_UP;
9D001CBC  24020008   ADDIU V0, ZERO, 8
9D001CC0  AF828020   SW V0, -32736(GP)
260:                                 }
261:                             } 
262:                             else if (command.status.flags.I2C_error)
9D001CCC  3C02A000   LUI V0, -24576
9D001CD0  8C420570   LW V0, 1392(V0)
9D001CD4  30420040   ANDI V0, V0, 64
9D001CD8  104000AD   BEQ V0, ZERO, 0x9D001F90
9D001CDC  00000000   NOP
263:                             {
264:                                 /* check the other current monitor */
265:                                 state = PM_STATE_ALERT_WRAP_UP;
9D001CE0  24020008   ADDIU V0, ZERO, 8
9D001CE4  AF828020   SW V0, -32736(GP)
266:                             }
267:                             break;
9D001CB4  0B4007F7   J 0x9D001FDC
9D001CB8  00000000   NOP
9D001CC4  0B4007F7   J 0x9D001FDC
9D001CC8  00000000   NOP
9D001CE8  0B4007F7   J 0x9D001FDC
9D001CEC  00000000   NOP
9D001F90  00000000   NOP
9D001F94  0B4007F7   J 0x9D001FDC
9D001F98  00000000   NOP
268:                         }
269:                         case PM_STATE_READ_MONITOR_VOLTAGE:
270:                         {
271:                             if (!MasterI2CIsBusy())
9D001CF0  0F40039B   JAL MasterI2CIsBusy
9D001CF4  00000000   NOP
9D001CF8  144000A8   BNE V0, ZERO, 0x9D001F9C
9D001CFC  00000000   NOP
272:                             {
273:                                 command.status.flags.I2C_read = TRUE;
9D001D00  3C03A000   LUI V1, -24576
9D001D04  8C620570   LW V0, 1392(V1)
9D001D08  24040001   ADDIU A0, ZERO, 1
9D001D0C  7C821084   INS V0, A0, 2, 1
9D001D10  AC620570   SW V0, 1392(V1)
274:                                 command.target_address = PAC1710_ADDRESS;
9D001D14  3C02A000   LUI V0, -24576
9D001D18  24420570   ADDIU V0, V0, 1392
9D001D1C  24030030   ADDIU V1, ZERO, 48
9D001D20  A0430004   SB V1, 4(V0)
275:                                 command.Word[0] = PAC1710_REG_VSOURCE_VOLTAGE_HIGH;
9D001D24  3C02A000   LUI V0, -24576
9D001D28  24420570   ADDIU V0, V0, 1392
9D001D2C  24030011   ADDIU V1, ZERO, 17
9D001D30  A0430005   SB V1, 5(V0)
276:                                 command.WordSize = 1;
9D001D34  3C02A000   LUI V0, -24576
9D001D38  24420570   ADDIU V0, V0, 1392
9D001D3C  24030001   ADDIU V1, ZERO, 1
9D001D40  A043001A   SB V1, 26(V0)
277:                                 command.DataSize = 2;
9D001D44  3C02A000   LUI V0, -24576
9D001D48  24420570   ADDIU V0, V0, 1392
9D001D4C  24030002   ADDIU V1, ZERO, 2
9D001D50  A0430019   SB V1, 25(V0)
278:                                 if (MasterI2CQueueCommand(&command))
9D001D54  3C02A000   LUI V0, -24576
9D001D58  24440570   ADDIU A0, V0, 1392
9D001D5C  0F400271   JAL MasterI2CQueueCommand
9D001D60  00000000   NOP
9D001D64  10400090   BEQ V0, ZERO, 0x9D001FA8
9D001D68  00000000   NOP
279:                                 {
280:                                     state = PM_STATE_READ_MONITOR_VOLTAGE_WAIT;
9D001D6C  24020004   ADDIU V0, ZERO, 4
9D001D70  AF828020   SW V0, -32736(GP)
281:                                 }
282:                             }
283:                             break;
9D001D74  0B4007F7   J 0x9D001FDC
9D001D78  00000000   NOP
9D001F9C  00000000   NOP
9D001FA0  0B4007F7   J 0x9D001FDC
9D001FA4  00000000   NOP
9D001FA8  00000000   NOP
9D001FAC  0B4007F7   J 0x9D001FDC
9D001FB0  00000000   NOP
284:                         }
285:                         case PM_STATE_READ_MONITOR_VOLTAGE_WAIT:
286:                         {
287:                             if (MasterI2CUpdateQueuedCommand(&command))
9D001D7C  3C02A000   LUI V0, -24576
9D001D80  24440570   ADDIU A0, V0, 1392
9D001D84  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D001D88  00000000   NOP
9D001D8C  10400011   BEQ V0, ZERO, 0x9D001DD4
9D001D90  00000000   NOP
288:                             {
289:                                 monitorVoltageHolding.byte.HB = command.Data[0];
9D001D94  3C02A000   LUI V0, -24576
9D001D98  24420570   ADDIU V0, V0, 1392
9D001D9C  9042000F   LBU V0, 15(V0)
9D001DA0  A382805D   SB V0, -32675(GP)
290:                                 monitorVoltageHolding.byte.LB = command.Data[1];
9D001DA4  3C02A000   LUI V0, -24576
9D001DA8  24420570   ADDIU V0, V0, 1392
9D001DAC  90420010   LBU V0, 16(V0)
9D001DB0  A382805C   SB V0, -32676(GP)
291:                                 PAC1710SubsystemFlags.monitorVoltageAvailable = TRUE;
9D001DB4  8F82804C   LW V0, -32692(GP)
9D001DB8  24030001   ADDIU V1, ZERO, 1
9D001DBC  7C6218C4   INS V0, V1, 3, 1
9D001DC0  AF82804C   SW V0, -32692(GP)
292:                                 state = PM_STATE_READ_MONITOR_CURRENT;
9D001DC4  24020005   ADDIU V0, ZERO, 5
9D001DC8  AF828020   SW V0, -32736(GP)
293:                             } 
294:                             else if (command.status.flags.I2C_error)
9D001DD4  3C02A000   LUI V0, -24576
9D001DD8  8C420570   LW V0, 1392(V0)
9D001DDC  30420040   ANDI V0, V0, 64
9D001DE0  10400074   BEQ V0, ZERO, 0x9D001FB4
9D001DE4  00000000   NOP
295:                             {
296:                                 /* check the other current monitor */
297:                                 state = PM_STATE_ALERT_WRAP_UP;
9D001DE8  24020008   ADDIU V0, ZERO, 8
9D001DEC  AF828020   SW V0, -32736(GP)
298:                             }
299:                             break;
9D001DCC  0B4007F7   J 0x9D001FDC
9D001DD0  00000000   NOP
9D001DF0  0B4007F7   J 0x9D001FDC
9D001DF4  00000000   NOP
9D001FB4  00000000   NOP
9D001FB8  0B4007F7   J 0x9D001FDC
9D001FBC  00000000   NOP
300:                         }
301:                         case PM_STATE_READ_MONITOR_CURRENT:
302:                         {
303:                             if (!MasterI2CIsBusy())
9D001DF8  0F40039B   JAL MasterI2CIsBusy
9D001DFC  00000000   NOP
9D001E00  1440006F   BNE V0, ZERO, 0x9D001FC0
9D001E04  00000000   NOP
304:                             {
305:                                 command.status.flags.I2C_read = TRUE;
9D001E08  3C03A000   LUI V1, -24576
9D001E0C  8C620570   LW V0, 1392(V1)
9D001E10  24040001   ADDIU A0, ZERO, 1
9D001E14  7C821084   INS V0, A0, 2, 1
9D001E18  AC620570   SW V0, 1392(V1)
306:                                 command.target_address = PAC1710_ADDRESS;
9D001E1C  3C02A000   LUI V0, -24576
9D001E20  24420570   ADDIU V0, V0, 1392
9D001E24  24030030   ADDIU V1, ZERO, 48
9D001E28  A0430004   SB V1, 4(V0)
307:                                 command.Word[0] = PAC1710_REG_SENSE_VOLTAGE_HIGH;
9D001E2C  3C02A000   LUI V0, -24576
9D001E30  24420570   ADDIU V0, V0, 1392
9D001E34  2403000D   ADDIU V1, ZERO, 13
9D001E38  A0430005   SB V1, 5(V0)
308:                                 command.WordSize = 1;
9D001E3C  3C02A000   LUI V0, -24576
9D001E40  24420570   ADDIU V0, V0, 1392
9D001E44  24030001   ADDIU V1, ZERO, 1
9D001E48  A043001A   SB V1, 26(V0)
309:                                 command.DataSize = 2;
9D001E4C  3C02A000   LUI V0, -24576
9D001E50  24420570   ADDIU V0, V0, 1392
9D001E54  24030002   ADDIU V1, ZERO, 2
9D001E58  A0430019   SB V1, 25(V0)
310:                                 if (MasterI2CQueueCommand(&command))
9D001E5C  3C02A000   LUI V0, -24576
9D001E60  24440570   ADDIU A0, V0, 1392
9D001E64  0F400271   JAL MasterI2CQueueCommand
9D001E68  00000000   NOP
9D001E6C  10400057   BEQ V0, ZERO, 0x9D001FCC
9D001E70  00000000   NOP
311:                                 {
312:                                     state = PM_STATE_READ_MONITOR_CURRENT_WAIT;
9D001E74  24020006   ADDIU V0, ZERO, 6
9D001E78  AF828020   SW V0, -32736(GP)
313:                                 }
314:                             }
315:                             break;
9D001E7C  0B4007F7   J 0x9D001FDC
9D001E80  00000000   NOP
9D001FC0  00000000   NOP
9D001FC4  0B4007F7   J 0x9D001FDC
9D001FC8  00000000   NOP
9D001FCC  00000000   NOP
9D001FD0  0B4007F7   J 0x9D001FDC
9D001FD4  00000000   NOP
316:                         }
317:                         case PM_STATE_READ_MONITOR_CURRENT_WAIT:
318:                         {
319:                             if (MasterI2CUpdateQueuedCommand(&command))
9D001E84  3C02A000   LUI V0, -24576
9D001E88  24440570   ADDIU A0, V0, 1392
9D001E8C  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D001E90  00000000   NOP
9D001E94  10400011   BEQ V0, ZERO, 0x9D001EDC
9D001E98  00000000   NOP
320:                             {
321:                                 monitorCurrentHolding.byte.HB = command.Data[0];
9D001E9C  3C02A000   LUI V0, -24576
9D001EA0  24420570   ADDIU V0, V0, 1392
9D001EA4  9042000F   LBU V0, 15(V0)
9D001EA8  A3828049   SB V0, -32695(GP)
322:                                 monitorCurrentHolding.byte.LB = command.Data[1];
9D001EAC  3C02A000   LUI V0, -24576
9D001EB0  24420570   ADDIU V0, V0, 1392
9D001EB4  90420010   LBU V0, 16(V0)
9D001EB8  A3828048   SB V0, -32696(GP)
323:                                 PAC1710SubsystemFlags.monitorCurrentAvailable = TRUE;
9D001EBC  8F82804C   LW V0, -32692(GP)
9D001EC0  24030001   ADDIU V1, ZERO, 1
9D001EC4  7C621084   INS V0, V1, 2, 1
9D001EC8  AF82804C   SW V0, -32692(GP)
324:                                 state = PM_STATE_ALERT_WRAP_UP;
9D001ECC  24020008   ADDIU V0, ZERO, 8
9D001ED0  AF828020   SW V0, -32736(GP)
325:                             } 
326:                             else if (command.status.flags.I2C_error)
9D001EDC  3C02A000   LUI V0, -24576
9D001EE0  8C420570   LW V0, 1392(V0)
9D001EE4  30420040   ANDI V0, V0, 64
9D001EE8  1040003B   BEQ V0, ZERO, 0x9D001FD8
9D001EEC  00000000   NOP
327:                             {
328:                                 /* check the other current monitor */
329:                                 state = PM_STATE_ALERT_WRAP_UP;
9D001EF0  24020008   ADDIU V0, ZERO, 8
9D001EF4  AF828020   SW V0, -32736(GP)
330:                             }
331:                             break;
9D001ED4  0B4007F7   J 0x9D001FDC
9D001ED8  00000000   NOP
9D001EF8  0B4007F7   J 0x9D001FDC
9D001EFC  00000000   NOP
9D001FD8  00000000   NOP
332:                         }
333:                         case PM_STATE_MONITOR_WRAP_UP:
334:                         case PM_STATE_ALERT_WRAP_UP:
335:                         {
336:                             MasterI2CReleasePort();
9D001F00  0F4004FB   JAL MasterI2CReleasePort
9D001F04  00000000   NOP
337:                             if (PAC1710SubsystemFlags.monitorVoltageAvailable ||
9D001F08  8F82804C   LW V0, -32692(GP)
9D001F0C  30420008   ANDI V0, V0, 8
9D001F10  14400005   BNE V0, ZERO, 0x9D001F28
9D001F14  00000000   NOP
9D001F18  8F82804C   LW V0, -32692(GP)
9D001F1C  30420004   ANDI V0, V0, 4
9D001F20  10400005   BEQ V0, ZERO, 0x9D001F38
9D001F24  00000000   NOP
338:                                     PAC1710SubsystemFlags.monitorCurrentAvailable)
339:                             {
340:                                 PAC1710SubsystemFlags.newDataAvailable = TRUE;
9D001F28  8F82804C   LW V0, -32692(GP)
9D001F2C  24030001   ADDIU V1, ZERO, 1
9D001F30  7C622944   INS V0, V1, 5, 1
9D001F34  AF82804C   SW V0, -32692(GP)
341:                             }
342:                             ClearAlertAsserted();
9D001F38  0F400651   JAL ClearAlertAsserted
9D001F3C  00000000   NOP
343:                             PAC1710SubsystemFlags.alertAsserted = FALSE;
9D001F40  8F82804C   LW V0, -32692(GP)
9D001F44  7C020004   INS V0, ZERO, 0, 1
9D001F48  AF82804C   SW V0, -32692(GP)
344:                             state = PM_STATE_IDLE;
9D001F4C  AF808020   SW ZERO, -32736(GP)
345:                             break;
9D001F50  0B4007F7   J 0x9D001FDC
9D001F54  00000000   NOP
346:                         }
347:                         default:
348:                         {
349:                             MasterI2CReleasePort();
9D001F58  0F4004FB   JAL MasterI2CReleasePort
9D001F5C  00000000   NOP
350:                             state = PM_STATE_IDLE;
9D001F60  AF808020   SW ZERO, -32736(GP)
351:                             break;
9D001F64  0B4007F7   J 0x9D001FDC
9D001F68  00000000   NOP
352:                         }
353:                     }
354:                     return TRUE;
9D001FDC  24020001   ADDIU V0, ZERO, 1
355:                 }
9D001FE0  03C0E821   ADDU SP, S8, ZERO
9D001FE4  8FBF001C   LW RA, 28(SP)
9D001FE8  8FBE0018   LW S8, 24(SP)
9D001FEC  27BD0020   ADDIU SP, SP, 32
9D001FF0  03E00008   JR RA
9D001FF4  00000000   NOP
356:                 
357:                 /******************************************************************************/
358:                 
359:                 BOOL GetCurrentData(UINT32 address, INT16 *current)
360:                 {
9D001FF8  27BDFFF0   ADDIU SP, SP, -16
9D001FFC  AFBE000C   SW S8, 12(SP)
9D002000  03A0F021   ADDU S8, SP, ZERO
9D002004  AFC40010   SW A0, 16(S8)
9D002008  AFC50014   SW A1, 20(S8)
361:                     BOOL returnValue=FALSE;
9D00200C  AFC00000   SW ZERO, 0(S8)
362:                     switch(address)
9D002010  8FC30010   LW V1, 16(S8)
9D002014  24020030   ADDIU V0, ZERO, 48
9D002018  14620010   BNE V1, V0, 0x9D00205C
9D00201C  00000000   NOP
363:                     {
364:                         case PAC1710_ADDRESS:
365:                         {
366:                             if(PAC1710SubsystemFlags.monitorCurrentAvailable)
9D002020  8F82804C   LW V0, -32692(GP)
9D002024  30420004   ANDI V0, V0, 4
9D002028  1040000F   BEQ V0, ZERO, 0x9D002068
9D00202C  00000000   NOP
367:                             {
368:                                 PAC1710SubsystemFlags.monitorCurrentAvailable=FALSE;
9D002030  8F82804C   LW V0, -32692(GP)
9D002034  7C021084   INS V0, ZERO, 2, 1
9D002038  AF82804C   SW V0, -32692(GP)
369:                                 *current=(INT16)monitorCurrentHolding.Val;
9D00203C  97828048   LHU V0, -32696(GP)
9D002040  7C021E20   SEH V1, V0
9D002044  8FC20014   LW V0, 20(S8)
9D002048  A4430000   SH V1, 0(V0)
370:                                 returnValue=TRUE;
9D00204C  24020001   ADDIU V0, ZERO, 1
9D002050  AFC20000   SW V0, 0(S8)
371:                             }
372:                             break;
9D002054  0B40081B   J 0x9D00206C
9D002058  00000000   NOP
9D002068  00000000   NOP
373:                         }
374:                         default:
375:                         {
376:                             break;
9D00205C  00000000   NOP
9D002060  0B40081B   J 0x9D00206C
9D002064  00000000   NOP
377:                         }
378:                     }
379:                     return returnValue;
9D00206C  8FC20000   LW V0, 0(S8)
380:                 }
9D002070  03C0E821   ADDU SP, S8, ZERO
9D002074  8FBE000C   LW S8, 12(SP)
9D002078  27BD0010   ADDIU SP, SP, 16
9D00207C  03E00008   JR RA
9D002080  00000000   NOP
381:                 
382:                 /******************************************************************************/
383:                 
384:                 BOOL GetVoltageData(UINT32 address, INT16 *voltage)
385:                 {
9D002084  27BDFFF0   ADDIU SP, SP, -16
9D002088  AFBE000C   SW S8, 12(SP)
9D00208C  03A0F021   ADDU S8, SP, ZERO
9D002090  AFC40010   SW A0, 16(S8)
9D002094  AFC50014   SW A1, 20(S8)
386:                     BOOL returnValue=FALSE;
9D002098  AFC00000   SW ZERO, 0(S8)
387:                     switch(address)
9D00209C  8FC30010   LW V1, 16(S8)
9D0020A0  24020030   ADDIU V0, ZERO, 48
9D0020A4  14620010   BNE V1, V0, 0x9D0020E8
9D0020A8  00000000   NOP
388:                     {
389:                         case PAC1710_ADDRESS:
390:                         {
391:                             if(PAC1710SubsystemFlags.monitorVoltageAvailable)
9D0020AC  8F82804C   LW V0, -32692(GP)
9D0020B0  30420008   ANDI V0, V0, 8
9D0020B4  1040000F   BEQ V0, ZERO, 0x9D0020F4
9D0020B8  00000000   NOP
392:                             {
393:                                 PAC1710SubsystemFlags.monitorVoltageAvailable=FALSE;
9D0020BC  8F82804C   LW V0, -32692(GP)
9D0020C0  7C0218C4   INS V0, ZERO, 3, 1
9D0020C4  AF82804C   SW V0, -32692(GP)
394:                                 *voltage=(INT16)monitorVoltageHolding.Val;
9D0020C8  9782805C   LHU V0, -32676(GP)
9D0020CC  7C021E20   SEH V1, V0
9D0020D0  8FC20014   LW V0, 20(S8)
9D0020D4  A4430000   SH V1, 0(V0)
395:                                 returnValue=TRUE;
9D0020D8  24020001   ADDIU V0, ZERO, 1
9D0020DC  AFC20000   SW V0, 0(S8)
396:                             }
397:                             break;
9D0020E0  0B40083E   J 0x9D0020F8
9D0020E4  00000000   NOP
9D0020F4  00000000   NOP
398:                         }
399:                         default:
400:                         {
401:                             break;
9D0020E8  00000000   NOP
9D0020EC  0B40083E   J 0x9D0020F8
9D0020F0  00000000   NOP
402:                         }
403:                     }
404:                     return returnValue;
9D0020F8  8FC20000   LW V0, 0(S8)
405:                 }
9D0020FC  03C0E821   ADDU SP, S8, ZERO
9D002100  8FBE000C   LW S8, 12(SP)
9D002104  27BD0010   ADDIU SP, SP, 16
9D002108  03E00008   JR RA
9D00210C  00000000   NOP
406:                 
407:                 /******************************************************************************/
408:                 
409:                 
410:                 BOOL PAC1710GetData(enum PAC1710_DATA_TYPE what, INT16 *data)
411:                 {
9D002110  27BDFFE0   ADDIU SP, SP, -32
9D002114  AFBF001C   SW RA, 28(SP)
9D002118  AFBE0018   SW S8, 24(SP)
9D00211C  03A0F021   ADDU S8, SP, ZERO
9D002120  AFC40020   SW A0, 32(S8)
9D002124  AFC50024   SW A1, 36(S8)
412:                     BOOL returnValue=FALSE;
9D002128  AFC00010   SW ZERO, 16(S8)
413:                     INT16 holding;
414:                     switch(what)
9D00212C  8FC20020   LW V0, 32(S8)
9D002130  10400006   BEQ V0, ZERO, 0x9D00214C
9D002134  00000000   NOP
9D002138  24030001   ADDIU V1, ZERO, 1
9D00213C  10430013   BEQ V0, V1, 0x9D00218C
9D002140  00000000   NOP
415:                     {
416:                         case PAC1710_DATA_CURRENT:
417:                         {
418:                             if(GetCurrentData(PAC1710_ADDRESS,&holding))
9D00214C  27C20014   ADDIU V0, S8, 20
9D002150  24040030   ADDIU A0, ZERO, 48
9D002154  00402821   ADDU A1, V0, ZERO
9D002158  0F4007FE   JAL GetCurrentData
9D00215C  00000000   NOP
9D002160  1040001A   BEQ V0, ZERO, 0x9D0021CC
9D002164  00000000   NOP
419:                             {
420:                                 *data=holding>>4;
9D002168  87C20014   LH V0, 20(S8)
9D00216C  00021103   SRA V0, V0, 4
9D002170  7C021E20   SEH V1, V0
9D002174  8FC20024   LW V0, 36(S8)
9D002178  A4430000   SH V1, 0(V0)
421:                                 returnValue=TRUE;
9D00217C  24020001   ADDIU V0, ZERO, 1
9D002180  AFC20010   SW V0, 16(S8)
422:                             }
423:                             break;
9D002184  0B400877   J 0x9D0021DC
9D002188  00000000   NOP
9D0021CC  00000000   NOP
9D0021D0  0B400877   J 0x9D0021DC
9D0021D4  00000000   NOP
424:                         }
425:                         case PAC1710_DATA_VOLTAGE:
426:                         {
427:                             if(GetVoltageData(PAC1710_ADDRESS,&holding))
9D00218C  27C20014   ADDIU V0, S8, 20
9D002190  24040030   ADDIU A0, ZERO, 48
9D002194  00402821   ADDU A1, V0, ZERO
9D002198  0F400821   JAL GetVoltageData
9D00219C  00000000   NOP
9D0021A0  1040000D   BEQ V0, ZERO, 0x9D0021D8
9D0021A4  00000000   NOP
428:                             {
429:                                 *data=holding>>5;
9D0021A8  87C20014   LH V0, 20(S8)
9D0021AC  00021143   SRA V0, V0, 5
9D0021B0  7C021E20   SEH V1, V0
9D0021B4  8FC20024   LW V0, 36(S8)
9D0021B8  A4430000   SH V1, 0(V0)
430:                                 returnValue=TRUE;
9D0021BC  24020001   ADDIU V0, ZERO, 1
9D0021C0  AFC20010   SW V0, 16(S8)
431:                             }
432:                             break;
9D0021C4  0B400877   J 0x9D0021DC
9D0021C8  00000000   NOP
9D0021D8  00000000   NOP
433:                         }
434:                         default:
435:                         {
436:                             break;
9D002144  0B400877   J 0x9D0021DC
9D002148  00000000   NOP
437:                         }
438:                     }
439:                     return returnValue;
9D0021DC  8FC20010   LW V0, 16(S8)
440:                 }
9D0021E0  03C0E821   ADDU SP, S8, ZERO
9D0021E4  8FBF001C   LW RA, 28(SP)
9D0021E8  8FBE0018   LW S8, 24(SP)
9D0021EC  27BD0020   ADDIU SP, SP, 32
9D0021F0  03E00008   JR RA
9D0021F4  00000000   NOP
441:                 /******************************************************************************/
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/MCP4461.c  ------------------------------------
1:                   #include <common.h>
2:                   #include <MCP4461.h>
3:                   #include <I2C_Bus_Master.h>
4:                   
5:                   DIGIPOT_SUBSYSTEM_TYPE digipotStatus;
6:                   DIGIPOT_TYPE digipot;
7:                   
8:                   BOOL DigipotStartGetStatus(void)
9:                   {
9D003580  27BDFFF8   ADDIU SP, SP, -8
9D003584  AFBE0004   SW S8, 4(SP)
9D003588  03A0F021   ADDU S8, SP, ZERO
10:                      if(!digipotStatus.reading&&!digipotStatus.readStatus)
9D00358C  8F828060   LW V0, -32672(GP)
9D003590  30420040   ANDI V0, V0, 64
9D003594  1440000C   BNE V0, ZERO, 0x9D0035C8
9D003598  00000000   NOP
9D00359C  8F828060   LW V0, -32672(GP)
9D0035A0  30420100   ANDI V0, V0, 256
9D0035A4  14400008   BNE V0, ZERO, 0x9D0035C8
9D0035A8  00000000   NOP
11:                      {
12:                          digipotStatus.readStatus=TRUE;
9D0035AC  8F828060   LW V0, -32672(GP)
9D0035B0  24030001   ADDIU V1, ZERO, 1
9D0035B4  7C624204   INS V0, V1, 8, 1
9D0035B8  AF828060   SW V0, -32672(GP)
13:                          return TRUE;
9D0035BC  24020001   ADDIU V0, ZERO, 1
9D0035C0  0B400D73   J 0x9D0035CC
9D0035C4  00000000   NOP
14:                      }
15:                      return FALSE;
9D0035C8  00001021   ADDU V0, ZERO, ZERO
16:                  }
9D0035CC  03C0E821   ADDU SP, S8, ZERO
9D0035D0  8FBE0004   LW S8, 4(SP)
9D0035D4  27BD0008   ADDIU SP, SP, 8
9D0035D8  03E00008   JR RA
9D0035DC  00000000   NOP
17:                  
18:                  UINT8 DigipotGetStatus(void)
19:                  {
9D0035E0  27BDFFF8   ADDIU SP, SP, -8
9D0035E4  AFBE0004   SW S8, 4(SP)
9D0035E8  03A0F021   ADDU S8, SP, ZERO
20:                      return digipot.STATUS.b;
9D0035EC  3C02A000   LUI V0, -24576
9D0035F0  24420400   ADDIU V0, V0, 1024
9D0035F4  9042002C   LBU V0, 44(V0)
21:                  }
9D0035F8  03C0E821   ADDU SP, S8, ZERO
9D0035FC  8FBE0004   LW S8, 4(SP)
9D003600  27BD0008   ADDIU SP, SP, 8
9D003604  03E00008   JR RA
9D003608  00000000   NOP
22:                  
23:                  BOOL DigipotGetReading(UINT8 channel,UINT16 *data)
24:                  {
9D00360C  27BDFFF8   ADDIU SP, SP, -8
9D003610  AFBE0004   SW S8, 4(SP)
9D003614  03A0F021   ADDU S8, SP, ZERO
9D003618  00801021   ADDU V0, A0, ZERO
9D00361C  AFC5000C   SW A1, 12(S8)
9D003620  A3C20008   SB V0, 8(S8)
25:                      if((channel<4)&&(digipot.value[channel].goodRead))
9D003624  93C20008   LBU V0, 8(S8)
9D003628  2C420004   SLTIU V0, V0, 4
9D00362C  10400019   BEQ V0, ZERO, 0x9D003694
9D003630  00000000   NOP
9D003634  93C30008   LBU V1, 8(S8)
9D003638  3C02A000   LUI V0, -24576
9D00363C  00031880   SLL V1, V1, 2
9D003640  24420400   ADDIU V0, V0, 1024
9D003644  00621021   ADDU V0, V1, V0
9D003648  8C420000   LW V0, 0(V0)
9D00364C  7C420380   EXT V0, V0, 14, 1
9D003650  304200FF   ANDI V0, V0, 255
9D003654  1040000F   BEQ V0, ZERO, 0x9D003694
9D003658  00000000   NOP
26:                      {
27:                          *data=digipot.value[channel].pot;
9D00365C  93C30008   LBU V1, 8(S8)
9D003660  3C02A000   LUI V0, -24576
9D003664  00031880   SLL V1, V1, 2
9D003668  24420400   ADDIU V0, V0, 1024
9D00366C  00621021   ADDU V0, V1, V0
9D003670  8C420000   LW V0, 0(V0)
9D003674  7C424000   EXT V0, V0, 0, 9
9D003678  3042FFFF   ANDI V0, V0, -1
9D00367C  00401821   ADDU V1, V0, ZERO
9D003680  8FC2000C   LW V0, 12(S8)
9D003684  A4430000   SH V1, 0(V0)
28:                          return TRUE;
9D003688  24020001   ADDIU V0, ZERO, 1
9D00368C  0B400DA6   J 0x9D003698
9D003690  00000000   NOP
29:                      }
30:                      return FALSE;
9D003694  00001021   ADDU V0, ZERO, ZERO
31:                  }
9D003698  03C0E821   ADDU SP, S8, ZERO
9D00369C  8FBE0004   LW S8, 4(SP)
9D0036A0  27BD0008   ADDIU SP, SP, 8
9D0036A4  03E00008   JR RA
9D0036A8  00000000   NOP
32:                  
33:                  BOOL DigipotReadingReady(void)
34:                  {
9D0036AC  27BDFFF8   ADDIU SP, SP, -8
9D0036B0  AFBE0004   SW S8, 4(SP)
9D0036B4  03A0F021   ADDU S8, SP, ZERO
35:                      return digipotStatus.readingReady;
9D0036B8  8F828060   LW V0, -32672(GP)
9D0036BC  7C4201C0   EXT V0, V0, 7, 1
9D0036C0  304200FF   ANDI V0, V0, 255
36:                  }
9D0036C4  03C0E821   ADDU SP, S8, ZERO
9D0036C8  8FBE0004   LW S8, 4(SP)
9D0036CC  27BD0008   ADDIU SP, SP, 8
9D0036D0  03E00008   JR RA
9D0036D4  00000000   NOP
37:                  
38:                  BOOL DigipotStartReadingAll(void)
39:                  {
9D0036D8  27BDFFF8   ADDIU SP, SP, -8
9D0036DC  AFBE0004   SW S8, 4(SP)
9D0036E0  03A0F021   ADDU S8, SP, ZERO
40:                      if(!digipotStatus.reading&&!digipotStatus.readAll&&!digipotStatus.readIndividual)
9D0036E4  8F828060   LW V0, -32672(GP)
9D0036E8  30420040   ANDI V0, V0, 64
9D0036EC  14400013   BNE V0, ZERO, 0x9D00373C
9D0036F0  00000000   NOP
9D0036F4  8F828060   LW V0, -32672(GP)
9D0036F8  30420010   ANDI V0, V0, 16
9D0036FC  1440000F   BNE V0, ZERO, 0x9D00373C
9D003700  00000000   NOP
9D003704  8F828060   LW V0, -32672(GP)
9D003708  30420020   ANDI V0, V0, 32
9D00370C  1440000B   BNE V0, ZERO, 0x9D00373C
9D003710  00000000   NOP
41:                      {
42:                          digipotStatus.readingReady=FALSE;
9D003714  8F828060   LW V0, -32672(GP)
9D003718  7C0239C4   INS V0, ZERO, 7, 1
9D00371C  AF828060   SW V0, -32672(GP)
43:                          digipotStatus.readAll=TRUE;
9D003720  8F828060   LW V0, -32672(GP)
9D003724  24030001   ADDIU V1, ZERO, 1
9D003728  7C622104   INS V0, V1, 4, 1
9D00372C  AF828060   SW V0, -32672(GP)
44:                          return TRUE;
9D003730  24020001   ADDIU V0, ZERO, 1
9D003734  0B400DD0   J 0x9D003740
9D003738  00000000   NOP
45:                      }
46:                      return FALSE;
9D00373C  00001021   ADDU V0, ZERO, ZERO
47:                  }
9D003740  03C0E821   ADDU SP, S8, ZERO
9D003744  8FBE0004   LW S8, 4(SP)
9D003748  27BD0008   ADDIU SP, SP, 8
9D00374C  03E00008   JR RA
9D003750  00000000   NOP
48:                  
49:                  BOOL DigipotStartReading(UINT8 channelToRead)
50:                  {
9D003754  27BDFFF8   ADDIU SP, SP, -8
9D003758  AFBE0004   SW S8, 4(SP)
9D00375C  03A0F021   ADDU S8, SP, ZERO
9D003760  00801021   ADDU V0, A0, ZERO
9D003764  A3C20008   SB V0, 8(S8)
51:                      if(!digipotStatus.reading&&!digipotStatus.readAll&&!digipotStatus.readIndividual)
9D003768  8F828060   LW V0, -32672(GP)
9D00376C  30420040   ANDI V0, V0, 64
9D003770  1440001D   BNE V0, ZERO, 0x9D0037E8
9D003774  00000000   NOP
9D003778  8F828060   LW V0, -32672(GP)
9D00377C  30420010   ANDI V0, V0, 16
9D003780  14400019   BNE V0, ZERO, 0x9D0037E8
9D003784  00000000   NOP
9D003788  8F828060   LW V0, -32672(GP)
9D00378C  30420020   ANDI V0, V0, 32
9D003790  14400015   BNE V0, ZERO, 0x9D0037E8
9D003794  00000000   NOP
52:                      {
53:                          if(channelToRead<4)
9D003798  93C20008   LBU V0, 8(S8)
9D00379C  2C420004   SLTIU V0, V0, 4
9D0037A0  10400011   BEQ V0, ZERO, 0x9D0037E8
9D0037A4  00000000   NOP
54:                          {
55:                              digipotStatus.readingReady=FALSE;
9D0037A8  8F828060   LW V0, -32672(GP)
9D0037AC  7C0239C4   INS V0, ZERO, 7, 1
9D0037B0  AF828060   SW V0, -32672(GP)
56:                              digipotStatus.channel=channelToRead;
9D0037B4  93C20008   LBU V0, 8(S8)
9D0037B8  30420003   ANDI V0, V0, 3
9D0037BC  304300FF   ANDI V1, V0, 255
9D0037C0  8F828060   LW V0, -32672(GP)
9D0037C4  7C625244   INS V0, V1, 9, 2
9D0037C8  AF828060   SW V0, -32672(GP)
57:                              digipotStatus.readIndividual=TRUE;
9D0037CC  8F828060   LW V0, -32672(GP)
9D0037D0  24030001   ADDIU V1, ZERO, 1
9D0037D4  7C622944   INS V0, V1, 5, 1
9D0037D8  AF828060   SW V0, -32672(GP)
58:                              return TRUE;
9D0037DC  24020001   ADDIU V0, ZERO, 1
9D0037E0  0B400DFB   J 0x9D0037EC
9D0037E4  00000000   NOP
59:                          }
60:                      }
61:                      return FALSE;
9D0037E8  00001021   ADDU V0, ZERO, ZERO
62:                  }
9D0037EC  03C0E821   ADDU SP, S8, ZERO
9D0037F0  8FBE0004   LW S8, 4(SP)
9D0037F4  27BD0008   ADDIU SP, SP, 8
9D0037F8  03E00008   JR RA
9D0037FC  00000000   NOP
63:                  
64:                  BOOL DigipotSubsystemInitialize(void)
65:                  {
9D003800  27BDFFF0   ADDIU SP, SP, -16
9D003804  AFBE000C   SW S8, 12(SP)
9D003808  03A0F021   ADDU S8, SP, ZERO
66:                      int index;
67:                      digipotStatus.w=0;
9D00380C  A7808060   SH ZERO, -32672(GP)
68:                      for(index=0;index<4;index++)
9D003810  AFC00000   SW ZERO, 0(S8)
9D003814  0B400E10   J 0x9D003840
9D003818  00000000   NOP
9D003834  8FC20000   LW V0, 0(S8)
9D003838  24420001   ADDIU V0, V0, 1
9D00383C  AFC20000   SW V0, 0(S8)
9D003840  8FC20000   LW V0, 0(S8)
9D003844  28420004   SLTI V0, V0, 4
9D003848  1440FFF4   BNE V0, ZERO, 0x9D00381C
9D00384C  00000000   NOP
69:                      {
70:                          digipot.value[index].word.Val=0;
9D00381C  3C02A000   LUI V0, -24576
9D003820  8FC30000   LW V1, 0(S8)
9D003824  00031880   SLL V1, V1, 2
9D003828  24420400   ADDIU V0, V0, 1024
9D00382C  00621021   ADDU V0, V1, V0
9D003830  A4400000   SH ZERO, 0(V0)
71:                      }
72:                      for(index=0;index<5;index++)
9D003850  AFC00000   SW ZERO, 0(S8)
9D003854  0B400E21   J 0x9D003884
9D003858  00000000   NOP
9D003878  8FC20000   LW V0, 0(S8)
9D00387C  24420001   ADDIU V0, V0, 1
9D003880  AFC20000   SW V0, 0(S8)
9D003884  8FC20000   LW V0, 0(S8)
9D003888  28420005   SLTI V0, V0, 5
9D00388C  1440FFF3   BNE V0, ZERO, 0x9D00385C
9D003890  00000000   NOP
73:                      {
74:                          digipot.data[index].word.Val=0;
9D00385C  3C02A000   LUI V0, -24576
9D003860  8FC30000   LW V1, 0(S8)
9D003864  24630004   ADDIU V1, V1, 4
9D003868  00031880   SLL V1, V1, 2
9D00386C  24420400   ADDIU V0, V0, 1024
9D003870  00621021   ADDU V0, V1, V0
9D003874  A4400000   SH ZERO, 0(V0)
75:                      }
76:                      return TRUE;
9D003894  24020001   ADDIU V0, ZERO, 1
77:                  }
9D003898  03C0E821   ADDU SP, S8, ZERO
9D00389C  8FBE000C   LW S8, 12(SP)
9D0038A0  27BD0010   ADDIU SP, SP, 16
9D0038A4  03E00008   JR RA
9D0038A8  00000000   NOP
78:                  
79:                  BOOL DoDigipot(void)
80:                  {
9D0038AC  27BDFFE0   ADDIU SP, SP, -32
9D0038B0  AFBF001C   SW RA, 28(SP)
9D0038B4  AFBE0018   SW S8, 24(SP)
9D0038B8  03A0F021   ADDU S8, SP, ZERO
81:                      /* shouldn't need to be static- just a big structure that I see no need   */
82:                      /* to build up and take down with every pass through this function */
83:                      static I2CBUS_COMMAND_TYPE command;
84:                      static enum DIGIPOT_STATE_TYPE state=DIGIPOT_STATE_IDLE;
85:                  
86:                      if(!MasterI2CHasPort(DIGIPOT))
9D0038BC  24040001   ADDIU A0, ZERO, 1
9D0038C0  0F400513   JAL MasterI2CHasPort
9D0038C4  00000000   NOP
9D0038C8  14400010   BNE V0, ZERO, 0x9D00390C
9D0038CC  00000000   NOP
87:                      {
88:                          if(MasterI2CAvailable())
9D0038D0  0F400504   JAL MasterI2CAvailable
9D0038D4  00000000   NOP
9D0038D8  10400009   BEQ V0, ZERO, 0x9D003900
9D0038DC  00000000   NOP
89:                          {
90:                              /* if the port is available, claim it */
91:                              if(!MasterI2CClaimPort(DIGIPOT))
9D0038E0  24040001   ADDIU A0, ZERO, 1
9D0038E4  0F4004DF   JAL MasterI2CClaimPort
9D0038E8  00000000   NOP
9D0038EC  14400007   BNE V0, ZERO, 0x9D00390C
9D0038F0  00000000   NOP
92:                              {
93:                                  return FALSE;
9D0038F4  00001021   ADDU V0, ZERO, ZERO
9D0038F8  0B400F7F   J 0x9D003DFC
9D0038FC  00000000   NOP
94:                              }
95:                          }
96:                          else
97:                          {
98:                              /* port not available */
99:                              return FALSE;
9D003900  00001021   ADDU V0, ZERO, ZERO
9D003904  0B400F7F   J 0x9D003DFC
9D003908  00000000   NOP
100:                         }
101:                     }
102:                     /* only get here if the port is claimed by the digipot subsystem */
103:                 
104:                    switch(state)
9D00390C  8F828024   LW V0, -32732(GP)
9D003910  24030001   ADDIU V1, ZERO, 1
9D003914  1043002F   BEQ V0, V1, 0x9D0039D4
9D003918  00000000   NOP
9D00391C  2C430001   SLTIU V1, V0, 1
9D003920  14600009   BNE V1, ZERO, 0x9D003948
9D003924  00000000   NOP
9D003928  24030002   ADDIU V1, ZERO, 2
9D00392C  10430090   BEQ V0, V1, 0x9D003B70
9D003930  00000000   NOP
9D003934  24030003   ADDIU V1, ZERO, 3
9D003938  10430112   BEQ V0, V1, 0x9D003D84
9D00393C  00000000   NOP
9D003940  0B400F6F   J 0x9D003DBC
9D003944  00000000   NOP
105:                     {
106:                         case DIGIPOT_STATE_IDLE:
107:                         {
108:                             if (digipotStatus.readAll)
9D003948  8F828060   LW V0, -32672(GP)
9D00394C  30420010   ANDI V0, V0, 16
9D003950  1040000C   BEQ V0, ZERO, 0x9D003984
9D003954  00000000   NOP
109:                             {
110:                                 digipotStatus.reading = TRUE;
9D003958  8F828060   LW V0, -32672(GP)
9D00395C  24030001   ADDIU V1, ZERO, 1
9D003960  7C623184   INS V0, V1, 6, 1
9D003964  AF828060   SW V0, -32672(GP)
111:                                 digipotStatus.channel = 0;
9D003968  8F828060   LW V0, -32672(GP)
9D00396C  7C025244   INS V0, ZERO, 9, 2
9D003970  AF828060   SW V0, -32672(GP)
112:                                 state = DIGIPOT_STATE_READ;
9D003974  24020001   ADDIU V0, ZERO, 1
9D003978  AF828024   SW V0, -32732(GP)
9D00397C  0B400E75   J 0x9D0039D4
9D003980  00000000   NOP
113:                             } 
114:                             else if (digipotStatus.readIndividual || digipotStatus.readStatus)
9D003984  8F828060   LW V0, -32672(GP)
9D003988  30420020   ANDI V0, V0, 32
9D00398C  14400005   BNE V0, ZERO, 0x9D0039A4
9D003990  00000000   NOP
9D003994  8F828060   LW V0, -32672(GP)
9D003998  30420100   ANDI V0, V0, 256
9D00399C  10400009   BEQ V0, ZERO, 0x9D0039C4
9D0039A0  00000000   NOP
115:                             {
116:                                 digipotStatus.reading = TRUE;
9D0039A4  8F828060   LW V0, -32672(GP)
9D0039A8  24030001   ADDIU V1, ZERO, 1
9D0039AC  7C623184   INS V0, V1, 6, 1
9D0039B0  AF828060   SW V0, -32672(GP)
117:                                 state = DIGIPOT_STATE_READ;
9D0039B4  24020001   ADDIU V0, ZERO, 1
9D0039B8  AF828024   SW V0, -32732(GP)
9D0039BC  0B400E75   J 0x9D0039D4
9D0039C0  00000000   NOP
118:                             } 
119:                             else
120:                             {
121:                                 /* don't be greedy */
122:                                 MasterI2CReleasePort();
9D0039C4  0F4004FB   JAL MasterI2CReleasePort
9D0039C8  00000000   NOP
123:                                 break;
9D0039CC  0B400F7E   J 0x9D003DF8
9D0039D0  00000000   NOP
124:                             }
125:                             /* no break */
126:                         }
127:                         case DIGIPOT_STATE_READ:
128:                         {
129:                             if (!MasterI2CIsBusy())
9D0039D4  0F40039B   JAL MasterI2CIsBusy
9D0039D8  00000000   NOP
9D0039DC  144000FC   BNE V0, ZERO, 0x9D003DD0
9D0039E0  00000000   NOP
130:                             {
131:                                 UINT8 digipotCommand = 0;
9D0039E4  A3C00010   SB ZERO, 16(S8)
132:                                 if (digipotStatus.readAll || digipotStatus.readIndividual)
9D0039E8  8F828060   LW V0, -32672(GP)
9D0039EC  30420010   ANDI V0, V0, 16
9D0039F0  14400005   BNE V0, ZERO, 0x9D003A08
9D0039F4  00000000   NOP
9D0039F8  8F828060   LW V0, -32672(GP)
9D0039FC  30420020   ANDI V0, V0, 32
9D003A00  1040002E   BEQ V0, ZERO, 0x9D003ABC
9D003A04  00000000   NOP
133:                                 {
134:                                     switch (digipotStatus.channel)
9D003A08  8F828060   LW V0, -32672(GP)
9D003A0C  7C420A40   EXT V0, V0, 9, 2
9D003A10  304200FF   ANDI V0, V0, 255
9D003A14  24030001   ADDIU V1, ZERO, 1
9D003A18  10430013   BEQ V0, V1, 0x9D003A68
9D003A1C  00000000   NOP
9D003A20  28430002   SLTI V1, V0, 2
9D003A24  10600005   BEQ V1, ZERO, 0x9D003A3C
9D003A28  00000000   NOP
9D003A2C  1040000B   BEQ V0, ZERO, 0x9D003A5C
9D003A30  00000000   NOP
9D003A34  0B400EA6   J 0x9D003A98
9D003A38  00000000   NOP
9D003A3C  24030002   ADDIU V1, ZERO, 2
9D003A40  1043000D   BEQ V0, V1, 0x9D003A78
9D003A44  00000000   NOP
9D003A48  24030003   ADDIU V1, ZERO, 3
9D003A4C  1043000E   BEQ V0, V1, 0x9D003A88
9D003A50  00000000   NOP
9D003A54  0B400EA6   J 0x9D003A98
9D003A58  00000000   NOP
135:                                     {
136:                                         case 0:
137:                                         {
138:                                             digipotCommand = MCP4461_VOLATILE_WIPER_0;
9D003A5C  A3C00010   SB ZERO, 16(S8)
139:                                             break;
9D003A60  0B400EAA   J 0x9D003AA8
9D003A64  00000000   NOP
140:                                         }
141:                                         case 1:
142:                                         {
143:                                             digipotCommand = MCP4461_VOLATILE_WIPER_1;
9D003A68  24020010   ADDIU V0, ZERO, 16
9D003A6C  A3C20010   SB V0, 16(S8)
144:                                             break;
9D003A70  0B400EAA   J 0x9D003AA8
9D003A74  00000000   NOP
145:                                         }
146:                                         case 2:
147:                                         {
148:                                             digipotCommand = MCP4461_VOLATILE_WIPER_2;
9D003A78  24020060   ADDIU V0, ZERO, 96
9D003A7C  A3C20010   SB V0, 16(S8)
149:                                             break;
9D003A80  0B400EAA   J 0x9D003AA8
9D003A84  00000000   NOP
150:                                         }
151:                                         case 3:
152:                                         {
153:                                             digipotCommand = MCP4461_VOLATILE_WIPER_3;
9D003A88  24020070   ADDIU V0, ZERO, 112
9D003A8C  A3C20010   SB V0, 16(S8)
154:                                             break;
9D003A90  0B400EAA   J 0x9D003AA8
9D003A94  00000000   NOP
155:                                         }
156:                                         default:
157:                                         {
158:                                             digipotStatus.channel = 0;
9D003A98  8F828060   LW V0, -32672(GP)
9D003A9C  7C025244   INS V0, ZERO, 9, 2
9D003AA0  AF828060   SW V0, -32672(GP)
159:                                             break;
9D003AA4  00000000   NOP
160:                                         }
161:                                     }
162:                                     digipotCommand |= MCP4461_COMMAND_READ;
9D003AA8  93C20010   LBU V0, 16(S8)
9D003AAC  3442000C   ORI V0, V0, 12
9D003AB0  A3C20010   SB V0, 16(S8)
9D003AB4  0B400EBB   J 0x9D003AEC
9D003AB8  00000000   NOP
163:                                 } 
164:                                 else if (digipotStatus.readStatus)
9D003ABC  8F828060   LW V0, -32672(GP)
9D003AC0  30420100   ANDI V0, V0, 256
9D003AC4  10400005   BEQ V0, ZERO, 0x9D003ADC
9D003AC8  00000000   NOP
165:                                 {
166:                                     digipotCommand = MCP4461_STATUS;
9D003ACC  24020050   ADDIU V0, ZERO, 80
9D003AD0  A3C20010   SB V0, 16(S8)
9D003AD4  0B400EBB   J 0x9D003AEC
9D003AD8  00000000   NOP
167:                                 } 
168:                                 else
169:                                 {
170:                                     /* not quite sure what is happening */
171:                                     state = DIGIPOT_STATE_CLEANUP;
9D003ADC  24020003   ADDIU V0, ZERO, 3
9D003AE0  AF828024   SW V0, -32732(GP)
172:                                     break;
9D003AE4  0B400F7E   J 0x9D003DF8
9D003AE8  00000000   NOP
173:                                 }
174:                                 command.status.flags.I2C_read = TRUE;
9D003AEC  3C03A000   LUI V1, -24576
9D003AF0  8C62058C   LW V0, 1420(V1)
9D003AF4  24040001   ADDIU A0, ZERO, 1
9D003AF8  7C821084   INS V0, A0, 2, 1
9D003AFC  AC62058C   SW V0, 1420(V1)
175:                                 command.target_address = DIGIPOT_ADDRESS;
9D003B00  3C02A000   LUI V0, -24576
9D003B04  2442058C   ADDIU V0, V0, 1420
9D003B08  2403005E   ADDIU V1, ZERO, 94
9D003B0C  A0430004   SB V1, 4(V0)
176:                                 command.Word[0] = digipotCommand;
9D003B10  3C02A000   LUI V0, -24576
9D003B14  2442058C   ADDIU V0, V0, 1420
9D003B18  93C30010   LBU V1, 16(S8)
9D003B1C  A0430005   SB V1, 5(V0)
177:                                 command.WordSize = 1;
9D003B20  3C02A000   LUI V0, -24576
9D003B24  2442058C   ADDIU V0, V0, 1420
9D003B28  24030001   ADDIU V1, ZERO, 1
9D003B2C  A043001A   SB V1, 26(V0)
178:                                 command.DataSize = 2;
9D003B30  3C02A000   LUI V0, -24576
9D003B34  2442058C   ADDIU V0, V0, 1420
9D003B38  24030002   ADDIU V1, ZERO, 2
9D003B3C  A0430019   SB V1, 25(V0)
179:                                 if (MasterI2CQueueCommand(&command))
9D003B40  3C02A000   LUI V0, -24576
9D003B44  2444058C   ADDIU A0, V0, 1420
9D003B48  0F400271   JAL MasterI2CQueueCommand
9D003B4C  00000000   NOP
9D003B50  10400003   BEQ V0, ZERO, 0x9D003B60
9D003B54  00000000   NOP
180:                                 {
181:                                     state = DIGIPOT_STATE_READ_WAIT;
9D003B58  24020002   ADDIU V0, ZERO, 2
9D003B5C  AF828024   SW V0, -32732(GP)
182:                                 }
183:                                 command.status.all = 0; /* just in case */
9D003B60  3C02A000   LUI V0, -24576
9D003B64  AC40058C   SW ZERO, 1420(V0)
184:                             }
185:                             break;
9D003B68  0B400F7E   J 0x9D003DF8
9D003B6C  00000000   NOP
9D003DD0  00000000   NOP
9D003DD4  0B400F7E   J 0x9D003DF8
9D003DD8  00000000   NOP
186:                         }
187:                         case DIGIPOT_STATE_READ_WAIT:
188:                         {
189:                             if (MasterI2CIsQueuedCommandDone())
9D003B70  0F4003BF   JAL MasterI2CIsQueuedCommandDone
9D003B74  00000000   NOP
9D003B78  10400098   BEQ V0, ZERO, 0x9D003DDC
9D003B7C  00000000   NOP
190:                             {
191:                                 if (MasterI2CUpdateQueuedCommand(&command))
9D003B80  3C02A000   LUI V0, -24576
9D003B84  2444058C   ADDIU A0, V0, 1420
9D003B88  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D003B8C  00000000   NOP
9D003B90  10400061   BEQ V0, ZERO, 0x9D003D18
9D003B94  00000000   NOP
192:                                 {
193:                                     if (digipotStatus.readStatus)
9D003B98  8F828060   LW V0, -32672(GP)
9D003B9C  30420100   ANDI V0, V0, 256
9D003BA0  1040000F   BEQ V0, ZERO, 0x9D003BE0
9D003BA4  00000000   NOP
194:                                     {
195:                                         digipot.STATUS.b = command.Data[1];
9D003BA8  3C02A000   LUI V0, -24576
9D003BAC  2442058C   ADDIU V0, V0, 1420
9D003BB0  90430010   LBU V1, 16(V0)
9D003BB4  3C02A000   LUI V0, -24576
9D003BB8  24420400   ADDIU V0, V0, 1024
9D003BBC  A043002C   SB V1, 44(V0)
196:                                         digipotStatus.readingReady = TRUE;
9D003BC0  8F828060   LW V0, -32672(GP)
9D003BC4  24030001   ADDIU V1, ZERO, 1
9D003BC8  7C6239C4   INS V0, V1, 7, 1
9D003BCC  AF828060   SW V0, -32672(GP)
197:                                         state = DIGIPOT_STATE_CLEANUP;
9D003BD0  24020003   ADDIU V0, ZERO, 3
9D003BD4  AF828024   SW V0, -32732(GP)
198:                                     } 
199:                                     else
200:                                     {
201:                                         digipot.value[digipotStatus.channel].word.byte.HB = command.Data[0];
9D003BE0  8F828060   LW V0, -32672(GP)
9D003BE4  7C420A40   EXT V0, V0, 9, 2
9D003BE8  304200FF   ANDI V0, V0, 255
9D003BEC  00402021   ADDU A0, V0, ZERO
9D003BF0  3C02A000   LUI V0, -24576
9D003BF4  2442058C   ADDIU V0, V0, 1420
9D003BF8  9043000F   LBU V1, 15(V0)
9D003BFC  3C02A000   LUI V0, -24576
9D003C00  00042080   SLL A0, A0, 2
9D003C04  24420400   ADDIU V0, V0, 1024
9D003C08  00821021   ADDU V0, A0, V0
9D003C0C  A0430001   SB V1, 1(V0)
202:                                         digipot.value[digipotStatus.channel].word.byte.LB = command.Data[1];
9D003C10  8F828060   LW V0, -32672(GP)
9D003C14  7C420A40   EXT V0, V0, 9, 2
9D003C18  304200FF   ANDI V0, V0, 255
9D003C1C  00402021   ADDU A0, V0, ZERO
9D003C20  3C02A000   LUI V0, -24576
9D003C24  2442058C   ADDIU V0, V0, 1420
9D003C28  90430010   LBU V1, 16(V0)
9D003C2C  3C02A000   LUI V0, -24576
9D003C30  00042080   SLL A0, A0, 2
9D003C34  24420400   ADDIU V0, V0, 1024
9D003C38  00821021   ADDU V0, A0, V0
9D003C3C  A0430000   SB V1, 0(V0)
203:                                         digipot.value[digipotStatus.channel].goodRead = TRUE;
9D003C40  8F828060   LW V0, -32672(GP)
9D003C44  7C420A40   EXT V0, V0, 9, 2
9D003C48  304200FF   ANDI V0, V0, 255
9D003C4C  00401821   ADDU V1, V0, ZERO
9D003C50  3C02A000   LUI V0, -24576
9D003C54  00031880   SLL V1, V1, 2
9D003C58  24420400   ADDIU V0, V0, 1024
9D003C5C  00621821   ADDU V1, V1, V0
9D003C60  8C620000   LW V0, 0(V1)
9D003C64  24040001   ADDIU A0, ZERO, 1
9D003C68  7C827384   INS V0, A0, 14, 1
9D003C6C  AC620000   SW V0, 0(V1)
204:                                         if (digipotStatus.readIndividual)
9D003C70  8F828060   LW V0, -32672(GP)
9D003C74  30420020   ANDI V0, V0, 32
9D003C78  10400009   BEQ V0, ZERO, 0x9D003CA0
9D003C7C  00000000   NOP
205:                                         {
206:                                             digipotStatus.readingReady = TRUE;
9D003C80  8F828060   LW V0, -32672(GP)
9D003C84  24030001   ADDIU V1, ZERO, 1
9D003C88  7C6239C4   INS V0, V1, 7, 1
9D003C8C  AF828060   SW V0, -32672(GP)
207:                                             state = DIGIPOT_STATE_CLEANUP;
9D003C90  24020003   ADDIU V0, ZERO, 3
9D003C94  AF828024   SW V0, -32732(GP)
208:                                         } 
209:                                         else if (digipotStatus.readAll)
9D003CA0  8F828060   LW V0, -32672(GP)
9D003CA4  30420010   ANDI V0, V0, 16
9D003CA8  1040004F   BEQ V0, ZERO, 0x9D003DE8
9D003CAC  00000000   NOP
210:                                         {
211:                                             if (digipotStatus.channel == 3)
9D003CB0  8F828060   LW V0, -32672(GP)
9D003CB4  30430600   ANDI V1, V0, 1536
9D003CB8  24020600   ADDIU V0, ZERO, 1536
9D003CBC  14620009   BNE V1, V0, 0x9D003CE4
9D003CC0  00000000   NOP
212:                                             {
213:                                                 digipotStatus.readingReady = TRUE;
9D003CC4  8F828060   LW V0, -32672(GP)
9D003CC8  24030001   ADDIU V1, ZERO, 1
9D003CCC  7C6239C4   INS V0, V1, 7, 1
9D003CD0  AF828060   SW V0, -32672(GP)
214:                                                 state = DIGIPOT_STATE_CLEANUP;
9D003CD4  24020003   ADDIU V0, ZERO, 3
9D003CD8  AF828024   SW V0, -32732(GP)
215:                                             } 
216:                                             else
217:                                             {
218:                                                 digipotStatus.channel++;
9D003CE4  8F828060   LW V0, -32672(GP)
9D003CE8  7C420A40   EXT V0, V0, 9, 2
9D003CEC  304200FF   ANDI V0, V0, 255
9D003CF0  24420001   ADDIU V0, V0, 1
9D003CF4  30420003   ANDI V0, V0, 3
9D003CF8  304300FF   ANDI V1, V0, 255
9D003CFC  8F828060   LW V0, -32672(GP)
9D003D00  7C625244   INS V0, V1, 9, 2
9D003D04  AF828060   SW V0, -32672(GP)
219:                                                 state = DIGIPOT_STATE_READ;
9D003D08  24020001   ADDIU V0, ZERO, 1
9D003D0C  AF828024   SW V0, -32732(GP)
220:                                             }
221:                                         }
222:                                     }
223:                                 } 
224:                                 else if (command.status.flags.I2C_error)
9D003D18  3C02A000   LUI V0, -24576
9D003D1C  8C42058C   LW V0, 1420(V0)
9D003D20  30420040   ANDI V0, V0, 64
9D003D24  10400033   BEQ V0, ZERO, 0x9D003DF4
9D003D28  00000000   NOP
225:                                 {
226:                                     digipotStatus.error = TRUE;
9D003D2C  8F828060   LW V0, -32672(GP)
9D003D30  24030001   ADDIU V1, ZERO, 1
9D003D34  7C620004   INS V0, V1, 0, 1
9D003D38  AF828060   SW V0, -32672(GP)
227:                                     digipotStatus.errorNoACK = command.status.flags.I2C_no_slave_addr_ack;
9D003D3C  3C02A000   LUI V0, -24576
9D003D40  8C42058C   LW V0, 1420(V0)
9D003D44  7C420100   EXT V0, V0, 4, 1
9D003D48  304300FF   ANDI V1, V0, 255
9D003D4C  8F828060   LW V0, -32672(GP)
9D003D50  7C620844   INS V0, V1, 1, 1
9D003D54  AF828060   SW V0, -32672(GP)
228:                                     digipotStatus.errorOnRead = TRUE;
9D003D58  8F828060   LW V0, -32672(GP)
9D003D5C  24030001   ADDIU V1, ZERO, 1
9D003D60  7C621084   INS V0, V1, 2, 1
9D003D64  AF828060   SW V0, -32672(GP)
229:                                     digipotStatus.readingReady = FALSE;
9D003D68  8F828060   LW V0, -32672(GP)
9D003D6C  7C0239C4   INS V0, ZERO, 7, 1
9D003D70  AF828060   SW V0, -32672(GP)
230:                                     state = DIGIPOT_STATE_CLEANUP;
9D003D74  24020003   ADDIU V0, ZERO, 3
9D003D78  AF828024   SW V0, -32732(GP)
231:                                 }
232:                             }
233:                             break;
9D003BD8  0B400F7E   J 0x9D003DF8
9D003BDC  00000000   NOP
9D003C98  0B400F7E   J 0x9D003DF8
9D003C9C  00000000   NOP
9D003CDC  0B400F7E   J 0x9D003DF8
9D003CE0  00000000   NOP
9D003D10  0B400F7E   J 0x9D003DF8
9D003D14  00000000   NOP
9D003D7C  0B400F7E   J 0x9D003DF8
9D003D80  00000000   NOP
9D003DDC  00000000   NOP
9D003DE0  0B400F7E   J 0x9D003DF8
9D003DE4  00000000   NOP
9D003DE8  00000000   NOP
9D003DEC  0B400F7E   J 0x9D003DF8
9D003DF0  00000000   NOP
9D003DF4  00000000   NOP
234:                         }
235:                         case DIGIPOT_STATE_CLEANUP:
236:                         {
237:                             digipotStatus.readIndividual = FALSE;
9D003D84  8F828060   LW V0, -32672(GP)
9D003D88  7C022944   INS V0, ZERO, 5, 1
9D003D8C  AF828060   SW V0, -32672(GP)
238:                             digipotStatus.readAll = FALSE;
9D003D90  8F828060   LW V0, -32672(GP)
9D003D94  7C022104   INS V0, ZERO, 4, 1
9D003D98  AF828060   SW V0, -32672(GP)
239:                             digipotStatus.readStatus = FALSE;
9D003D9C  8F828060   LW V0, -32672(GP)
9D003DA0  7C024204   INS V0, ZERO, 8, 1
9D003DA4  AF828060   SW V0, -32672(GP)
240:                             MasterI2CReleasePort();
9D003DA8  0F4004FB   JAL MasterI2CReleasePort
9D003DAC  00000000   NOP
241:                             state = DIGIPOT_STATE_IDLE;
9D003DB0  AF808024   SW ZERO, -32732(GP)
242:                             break;
9D003DB4  0B400F7E   J 0x9D003DF8
9D003DB8  00000000   NOP
243:                         }
244:                         default:
245:                         {
246:                             MasterI2CReleasePort();
9D003DBC  0F4004FB   JAL MasterI2CReleasePort
9D003DC0  00000000   NOP
247:                             state = DIGIPOT_STATE_IDLE;
9D003DC4  AF808024   SW ZERO, -32732(GP)
248:                             break;
9D003DC8  0B400F7E   J 0x9D003DF8
9D003DCC  00000000   NOP
249:                         }
250:                     }
251:                     return TRUE;
9D003DF8  24020001   ADDIU V0, ZERO, 1
252:                 }
9D003DFC  03C0E821   ADDU SP, S8, ZERO
9D003E00  8FBF001C   LW RA, 28(SP)
9D003E04  8FBE0018   LW S8, 24(SP)
9D003E08  27BD0020   ADDIU SP, SP, 32
9D003E0C  03E00008   JR RA
9D003E10  00000000   NOP
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/LED.c  ----------------------------------------
1:                   /******************************************************************************/
2:                   #include <common.h>
3:                   #include <tick.h>
4:                   #include <TRISThis.h>
5:                   #include <LED.h>
6:                   BOOL autoMode;
7:                   enum LED_STATE_TYPE LEDState;
8:                   extern TRISTHIS_DATA_TYPE TRISThisData;
9:                   
10:                  /******************************************************************************/
11:                  
12:                  BOOL LEDInitialize(void)
13:                  {
9D004C74  27BDFFF8   ADDIU SP, SP, -8
9D004C78  AFBE0004   SW S8, 4(SP)
9D004C7C  03A0F021   ADDU S8, SP, ZERO
14:                      LED_ALL_OFF;
9D004C80  3C02BF88   LUI V0, -16504
9D004C84  3403E000   ORI V1, ZERO, -8192
9D004C88  AC4360E8   SW V1, 24808(V0)
9D004C8C  3C02BF88   LUI V0, -16504
9D004C90  2403013C   ADDIU V1, ZERO, 316
9D004C94  AC436168   SW V1, 24936(V0)
15:                      SET_LED_DIRECTION;
9D004C98  3C02BF88   LUI V0, -16504
9D004C9C  3403E000   ORI V1, ZERO, -8192
9D004CA0  AC4360C4   SW V1, 24772(V0)
9D004CA4  3C02BF88   LUI V0, -16504
9D004CA8  2403013C   ADDIU V1, ZERO, 316
9D004CAC  AC436144   SW V1, 24900(V0)
16:                      //LED1_DIRECTION=TRIS_OUT;
17:                      //LED2_DIRECTION=TRIS_OUT;
18:                      //LED3_DIRECTION=TRIS_OUT;
19:                      //LED4_DIRECTION=TRIS_OUT;
20:                      //LED5_DIRECTION=TRIS_OUT;
21:                      //LED6_DIRECTION=TRIS_OUT;
22:                      //LED7_DIRECTION=TRIS_OUT;
23:                      //LED8_DIRECTION=TRIS_OUT;
24:                      //LEDState=LED_STATE_MANUAL;
25:                      LEDState=LED_STATE_ALL_OFF;
9D004CB0  AF808040   SW ZERO, -32704(GP)
26:                      autoMode=TRUE;
9D004CB4  24020001   ADDIU V0, ZERO, 1
9D004CB8  AF828044   SW V0, -32700(GP)
27:                      TRISThisData.status.autoLEDmode=autoMode;
9D004CBC  8F828044   LW V0, -32700(GP)
9D004CC0  304200FF   ANDI V0, V0, 255
9D004CC4  30420001   ANDI V0, V0, 1
9D004CC8  304400FF   ANDI A0, V0, 255
9D004CCC  3C03A000   LUI V1, -24576
9D004CD0  8C620544   LW V0, 1348(V1)
9D004CD4  7C821084   INS V0, A0, 2, 1
9D004CD8  AC620544   SW V0, 1348(V1)
28:                      TRISThisData.LEDs.w.Val=0;
9D004CDC  3C02A000   LUI V0, -24576
9D004CE0  24420544   ADDIU V0, V0, 1348
9D004CE4  AC400004   SW ZERO, 4(V0)
29:                      return TRUE;
9D004CE8  24020001   ADDIU V0, ZERO, 1
30:                  }
9D004CEC  03C0E821   ADDU SP, S8, ZERO
9D004CF0  8FBE0004   LW S8, 4(SP)
9D004CF4  27BD0008   ADDIU SP, SP, 8
9D004CF8  03E00008   JR RA
9D004CFC  00000000   NOP
31:                  
32:                  /******************************************************************************/
33:                  
34:                  UINT8 ReadLEDs(void)
35:                  {
9D004D00  27BDFFF0   ADDIU SP, SP, -16
9D004D04  AFBE000C   SW S8, 12(SP)
9D004D08  03A0F021   ADDU S8, SP, ZERO
36:                      UINT8_VAL LEDTemp;
37:                      LEDTemp.bits.b0=!LED1_OUT;
9D004D0C  3C02BF88   LUI V0, -16504
9D004D10  8C4260E0   LW V0, 24800(V0)
9D004D14  30424000   ANDI V0, V0, 16384
9D004D18  2C420001   SLTIU V0, V0, 1
9D004D1C  304300FF   ANDI V1, V0, 255
9D004D20  93C20000   LBU V0, 0(S8)
9D004D24  7C620004   INS V0, V1, 0, 1
9D004D28  A3C20000   SB V0, 0(S8)
38:                      LEDTemp.bits.b1=!LED2_OUT;
9D004D2C  3C02BF88   LUI V0, -16504
9D004D30  8C4260E0   LW V0, 24800(V0)
9D004D34  30428000   ANDI V0, V0, -32768
9D004D38  2C420001   SLTIU V0, V0, 1
9D004D3C  304300FF   ANDI V1, V0, 255
9D004D40  93C20000   LBU V0, 0(S8)
9D004D44  7C620844   INS V0, V1, 1, 1
9D004D48  A3C20000   SB V0, 0(S8)
39:                      LEDTemp.bits.b2=!LED3_OUT;
9D004D4C  3C02BF88   LUI V0, -16504
9D004D50  8C426160   LW V0, 24928(V0)
9D004D54  30420010   ANDI V0, V0, 16
9D004D58  2C420001   SLTIU V0, V0, 1
9D004D5C  304300FF   ANDI V1, V0, 255
9D004D60  93C20000   LBU V0, 0(S8)
9D004D64  7C621084   INS V0, V1, 2, 1
9D004D68  A3C20000   SB V0, 0(S8)
40:                      LEDTemp.bits.b3=!LED4_OUT;
9D004D6C  3C02BF88   LUI V0, -16504
9D004D70  8C426160   LW V0, 24928(V0)
9D004D74  30420020   ANDI V0, V0, 32
9D004D78  2C420001   SLTIU V0, V0, 1
9D004D7C  304300FF   ANDI V1, V0, 255
9D004D80  93C20000   LBU V0, 0(S8)
9D004D84  7C6218C4   INS V0, V1, 3, 1
9D004D88  A3C20000   SB V0, 0(S8)
41:                      LEDTemp.bits.b4=!LED5_OUT;
9D004D8C  3C02BF88   LUI V0, -16504
9D004D90  8C426160   LW V0, 24928(V0)
9D004D94  30420008   ANDI V0, V0, 8
9D004D98  2C420001   SLTIU V0, V0, 1
9D004D9C  304300FF   ANDI V1, V0, 255
9D004DA0  93C20000   LBU V0, 0(S8)
9D004DA4  7C622104   INS V0, V1, 4, 1
9D004DA8  A3C20000   SB V0, 0(S8)
42:                      LEDTemp.bits.b5=!LED6_OUT;
9D004DAC  3C02BF88   LUI V0, -16504
9D004DB0  8C426160   LW V0, 24928(V0)
9D004DB4  30420004   ANDI V0, V0, 4
9D004DB8  2C420001   SLTIU V0, V0, 1
9D004DBC  304300FF   ANDI V1, V0, 255
9D004DC0  93C20000   LBU V0, 0(S8)
9D004DC4  7C622944   INS V0, V1, 5, 1
9D004DC8  A3C20000   SB V0, 0(S8)
43:                      LEDTemp.bits.b6=!LED7_OUT;
9D004DCC  3C02BF88   LUI V0, -16504
9D004DD0  8C426160   LW V0, 24928(V0)
9D004DD4  30420100   ANDI V0, V0, 256
9D004DD8  2C420001   SLTIU V0, V0, 1
9D004DDC  304300FF   ANDI V1, V0, 255
9D004DE0  93C20000   LBU V0, 0(S8)
9D004DE4  7C623184   INS V0, V1, 6, 1
9D004DE8  A3C20000   SB V0, 0(S8)
44:                      LEDTemp.bits.b7=!LED8_OUT;
9D004DEC  3C02BF88   LUI V0, -16504
9D004DF0  8C4260E0   LW V0, 24800(V0)
9D004DF4  30422000   ANDI V0, V0, 8192
9D004DF8  2C420001   SLTIU V0, V0, 1
9D004DFC  304300FF   ANDI V1, V0, 255
9D004E00  93C20000   LBU V0, 0(S8)
9D004E04  7C6239C4   INS V0, V1, 7, 1
9D004E08  A3C20000   SB V0, 0(S8)
45:                      return LEDTemp.Val;
9D004E0C  93C20000   LBU V0, 0(S8)
46:                  }
9D004E10  03C0E821   ADDU SP, S8, ZERO
9D004E14  8FBE000C   LW S8, 12(SP)
9D004E18  27BD0010   ADDIU SP, SP, 16
9D004E1C  03E00008   JR RA
9D004E20  00000000   NOP
47:                  
48:                  /******************************************************************************/
49:                  
50:                  void SetLEDs(UINT8 toSet)
51:                  {
9D004E24  27BDFFF0   ADDIU SP, SP, -16
9D004E28  AFBE000C   SW S8, 12(SP)
9D004E2C  03A0F021   ADDU S8, SP, ZERO
9D004E30  00801021   ADDU V0, A0, ZERO
9D004E34  A3C20010   SB V0, 16(S8)
52:                      UINT8_VAL tempLEDs;
53:                      tempLEDs.Val=toSet;
9D004E38  93C20010   LBU V0, 16(S8)
9D004E3C  A3C20000   SB V0, 0(S8)
54:                      LED1_OUT=!tempLEDs.bits.b0;
9D004E40  93C20000   LBU V0, 0(S8)
9D004E44  30420001   ANDI V0, V0, 1
9D004E48  304200FF   ANDI V0, V0, 255
9D004E4C  2C420001   SLTIU V0, V0, 1
9D004E50  304400FF   ANDI A0, V0, 255
9D004E54  3C03BF88   LUI V1, -16504
9D004E58  8C6260E0   LW V0, 24800(V1)
9D004E5C  7C827384   INS V0, A0, 14, 1
9D004E60  AC6260E0   SW V0, 24800(V1)
55:                      LED2_OUT=!tempLEDs.bits.b1;
9D004E64  93C20000   LBU V0, 0(S8)
9D004E68  30420002   ANDI V0, V0, 2
9D004E6C  304200FF   ANDI V0, V0, 255
9D004E70  2C420001   SLTIU V0, V0, 1
9D004E74  304400FF   ANDI A0, V0, 255
9D004E78  3C03BF88   LUI V1, -16504
9D004E7C  8C6260E0   LW V0, 24800(V1)
9D004E80  7C827BC4   INS V0, A0, 15, 1
9D004E84  AC6260E0   SW V0, 24800(V1)
56:                      LED3_OUT=!tempLEDs.bits.b2;
9D004E88  93C20000   LBU V0, 0(S8)
9D004E8C  30420004   ANDI V0, V0, 4
9D004E90  304200FF   ANDI V0, V0, 255
9D004E94  2C420001   SLTIU V0, V0, 1
9D004E98  304400FF   ANDI A0, V0, 255
9D004E9C  3C03BF88   LUI V1, -16504
9D004EA0  8C626160   LW V0, 24928(V1)
9D004EA4  7C822104   INS V0, A0, 4, 1
9D004EA8  AC626160   SW V0, 24928(V1)
57:                      LED4_OUT=!tempLEDs.bits.b3;
9D004EAC  93C20000   LBU V0, 0(S8)
9D004EB0  30420008   ANDI V0, V0, 8
9D004EB4  304200FF   ANDI V0, V0, 255
9D004EB8  2C420001   SLTIU V0, V0, 1
9D004EBC  304400FF   ANDI A0, V0, 255
9D004EC0  3C03BF88   LUI V1, -16504
9D004EC4  8C626160   LW V0, 24928(V1)
9D004EC8  7C822944   INS V0, A0, 5, 1
9D004ECC  AC626160   SW V0, 24928(V1)
58:                      LED5_OUT=!tempLEDs.bits.b4;
9D004ED0  93C20000   LBU V0, 0(S8)
9D004ED4  30420010   ANDI V0, V0, 16
9D004ED8  304200FF   ANDI V0, V0, 255
9D004EDC  2C420001   SLTIU V0, V0, 1
9D004EE0  304400FF   ANDI A0, V0, 255
9D004EE4  3C03BF88   LUI V1, -16504
9D004EE8  8C626160   LW V0, 24928(V1)
9D004EEC  7C8218C4   INS V0, A0, 3, 1
9D004EF0  AC626160   SW V0, 24928(V1)
59:                      LED6_OUT=!tempLEDs.bits.b5;
9D004EF4  93C20000   LBU V0, 0(S8)
9D004EF8  30420020   ANDI V0, V0, 32
9D004EFC  304200FF   ANDI V0, V0, 255
9D004F00  2C420001   SLTIU V0, V0, 1
9D004F04  304400FF   ANDI A0, V0, 255
9D004F08  3C03BF88   LUI V1, -16504
9D004F0C  8C626160   LW V0, 24928(V1)
9D004F10  7C821084   INS V0, A0, 2, 1
9D004F14  AC626160   SW V0, 24928(V1)
60:                      LED7_OUT=!tempLEDs.bits.b6;
9D004F18  93C20000   LBU V0, 0(S8)
9D004F1C  30420040   ANDI V0, V0, 64
9D004F20  304200FF   ANDI V0, V0, 255
9D004F24  2C420001   SLTIU V0, V0, 1
9D004F28  304400FF   ANDI A0, V0, 255
9D004F2C  3C03BF88   LUI V1, -16504
9D004F30  8C626160   LW V0, 24928(V1)
9D004F34  7C824204   INS V0, A0, 8, 1
9D004F38  AC626160   SW V0, 24928(V1)
61:                      LED8_OUT=!tempLEDs.bits.b7;
9D004F3C  93C20000   LBU V0, 0(S8)
9D004F40  7C021420   SEB V0, V0
9D004F44  00021027   NOR V0, ZERO, V0
9D004F48  304200FF   ANDI V0, V0, 255
9D004F4C  000211C2   SRL V0, V0, 7
9D004F50  304400FF   ANDI A0, V0, 255
9D004F54  3C03BF88   LUI V1, -16504
9D004F58  8C6260E0   LW V0, 24800(V1)
9D004F5C  7C826B44   INS V0, A0, 13, 1
9D004F60  AC6260E0   SW V0, 24800(V1)
62:                  }
9D004F64  03C0E821   ADDU SP, S8, ZERO
9D004F68  8FBE000C   LW S8, 12(SP)
9D004F6C  27BD0010   ADDIU SP, SP, 16
9D004F70  03E00008   JR RA
9D004F74  00000000   NOP
63:                  
64:                  /******************************************************************************/
65:                  
66:                  void DoLEDs(void)
67:                  {
9D004F78  27BDFFE0   ADDIU SP, SP, -32
9D004F7C  AFBF001C   SW RA, 28(SP)
9D004F80  AFBE0018   SW S8, 24(SP)
9D004F84  03A0F021   ADDU S8, SP, ZERO
68:                      static TICK_TYPE timeoutTime=0;
69:                      TICK_TYPE now;
70:                      if(LEDState!=LED_STATE_MANUAL)
9D004F88  8F838040   LW V1, -32704(GP)
9D004F8C  24020009   ADDIU V0, ZERO, 9
9D004F90  10620073   BEQ V1, V0, 0x9D005160
9D004F94  00000000   NOP
71:                      {
72:                          now=TickGet();
9D004F98  0F4014DC   JAL TickGet
9D004F9C  00000000   NOP
9D004FA0  AFC20010   SW V0, 16(S8)
9D004FA4  AFC30014   SW V1, 20(S8)
73:                          if(now<timeoutTime)
9D004FA8  8F828018   LW V0, -32744(GP)
9D004FAC  8F83801C   LW V1, -32740(GP)
9D004FB0  8FC40014   LW A0, 20(S8)
9D004FB4  0083202B   SLTU A0, A0, V1
9D004FB8  14800071   BNE A0, ZERO, 0x9D005180
9D004FBC  00000000   NOP
9D004FC0  8FC50014   LW A1, 20(S8)
9D004FC4  00602021   ADDU A0, V1, ZERO
9D004FC8  14A40005   BNE A1, A0, 0x9D004FE0
9D004FCC  00000000   NOP
9D004FD0  8FC40010   LW A0, 16(S8)
9D004FD4  0082102B   SLTU V0, A0, V0
9D004FD8  1440006C   BNE V0, ZERO, 0x9D00518C
9D004FDC  00000000   NOP
74:                          {
75:                              return;
9D005180  00000000   NOP
9D005184  0B401464   J 0x9D005190
9D005188  00000000   NOP
9D00518C  00000000   NOP
76:                          }
77:                          else
78:                          {
79:                              timeoutTime = now + LED_CASCADE_DELAY;
9D004FE0  8FC40010   LW A0, 16(S8)
9D004FE4  8FC50014   LW A1, 20(S8)
9D004FE8  24060064   ADDIU A2, ZERO, 100
9D004FEC  00003821   ADDU A3, ZERO, ZERO
9D004FF0  00861021   ADDU V0, A0, A2
9D004FF4  0044402B   SLTU T0, V0, A0
9D004FF8  00A71821   ADDU V1, A1, A3
9D004FFC  01032021   ADDU A0, T0, V1
9D005000  00801821   ADDU V1, A0, ZERO
9D005004  AF828018   SW V0, -32744(GP)
9D005008  AF83801C   SW V1, -32740(GP)
80:                          }
81:                          switch(LEDState)
9D00500C  8F828040   LW V0, -32704(GP)
9D005010  2C430009   SLTIU V1, V0, 9
9D005014  10600049   BEQ V1, ZERO, 0x9D00513C
9D005018  00000000   NOP
9D00501C  00021880   SLL V1, V0, 2
9D005020  3C029D00   LUI V0, -25344
9D005024  24425038   ADDIU V0, V0, 20536
9D005028  00621021   ADDU V0, V1, V0
9D00502C  8C420000   LW V0, 0(V0)
9D005030  00400008   JR V0
9D005034  00000000   NOP
82:                          {
83:                              case LED_STATE_LED1_TOGGLE:
84:                              {
85:                                  LED1_TOGGLE;
9D00505C  3C02BF88   LUI V0, -16504
9D005060  24034000   ADDIU V1, ZERO, 16384
9D005064  AC4360EC   SW V1, 24812(V0)
86:                                  LEDState = LED_STATE_LED2_TOGGLE;
9D005068  24020002   ADDIU V0, ZERO, 2
9D00506C  AF828040   SW V0, -32704(GP)
87:                                  break;
9D005070  0B401458   J 0x9D005160
9D005074  00000000   NOP
88:                              }
89:                              case LED_STATE_LED2_TOGGLE:
90:                              {
91:                                  LED2_TOGGLE;
9D005078  3C02BF88   LUI V0, -16504
9D00507C  34038000   ORI V1, ZERO, -32768
9D005080  AC4360EC   SW V1, 24812(V0)
92:                                  LEDState = LED_STATE_LED3_TOGGLE;
9D005084  24020003   ADDIU V0, ZERO, 3
9D005088  AF828040   SW V0, -32704(GP)
93:                                  break;
9D00508C  0B401458   J 0x9D005160
9D005090  00000000   NOP
94:                              }
95:                              case LED_STATE_LED3_TOGGLE:
96:                              {
97:                                  LED3_TOGGLE;
9D005094  3C02BF88   LUI V0, -16504
9D005098  24030010   ADDIU V1, ZERO, 16
9D00509C  AC43616C   SW V1, 24940(V0)
98:                                  LEDState = LED_STATE_LED4_TOGGLE;
9D0050A0  24020004   ADDIU V0, ZERO, 4
9D0050A4  AF828040   SW V0, -32704(GP)
99:                                  break;
9D0050A8  0B401458   J 0x9D005160
9D0050AC  00000000   NOP
100:                             }
101:                             case LED_STATE_LED4_TOGGLE:
102:                             {
103:                                 LED4_TOGGLE;
9D0050B0  3C02BF88   LUI V0, -16504
9D0050B4  24030020   ADDIU V1, ZERO, 32
9D0050B8  AC43616C   SW V1, 24940(V0)
104:                                 LEDState = LED_STATE_LED5_TOGGLE;
9D0050BC  24020005   ADDIU V0, ZERO, 5
9D0050C0  AF828040   SW V0, -32704(GP)
105:                                 break;
9D0050C4  0B401458   J 0x9D005160
9D0050C8  00000000   NOP
106:                             }
107:                             case LED_STATE_LED5_TOGGLE:
108:                             {
109:                                 LED5_TOGGLE;
9D0050CC  3C02BF88   LUI V0, -16504
9D0050D0  24030008   ADDIU V1, ZERO, 8
9D0050D4  AC43616C   SW V1, 24940(V0)
110:                                 LEDState = LED_STATE_LED6_TOGGLE;
9D0050D8  24020006   ADDIU V0, ZERO, 6
9D0050DC  AF828040   SW V0, -32704(GP)
111:                                 break;
9D0050E0  0B401458   J 0x9D005160
9D0050E4  00000000   NOP
112:                             }
113:                             case LED_STATE_LED6_TOGGLE:
114:                             {
115:                                 LED6_TOGGLE;
9D0050E8  3C02BF88   LUI V0, -16504
9D0050EC  24030004   ADDIU V1, ZERO, 4
9D0050F0  AC43616C   SW V1, 24940(V0)
116:                                 LEDState = LED_STATE_LED7_TOGGLE;
9D0050F4  24020007   ADDIU V0, ZERO, 7
9D0050F8  AF828040   SW V0, -32704(GP)
117:                                 break;
9D0050FC  0B401458   J 0x9D005160
9D005100  00000000   NOP
118:                             }
119:                             case LED_STATE_LED7_TOGGLE:
120:                             {
121:                                 LED7_TOGGLE;
9D005104  3C02BF88   LUI V0, -16504
9D005108  24030100   ADDIU V1, ZERO, 256
9D00510C  AC43616C   SW V1, 24940(V0)
122:                                 LEDState = LED_STATE_LED8_TOGGLE;
9D005110  24020008   ADDIU V0, ZERO, 8
9D005114  AF828040   SW V0, -32704(GP)
123:                                 break;
9D005118  0B401458   J 0x9D005160
9D00511C  00000000   NOP
124:                             }
125:                             case LED_STATE_LED8_TOGGLE:
126:                             {
127:                                 LED8_TOGGLE;
9D005120  3C02BF88   LUI V0, -16504
9D005124  24032000   ADDIU V1, ZERO, 8192
9D005128  AC4360EC   SW V1, 24812(V0)
128:                                 LEDState = LED_STATE_LED1_TOGGLE;
9D00512C  24020001   ADDIU V0, ZERO, 1
9D005130  AF828040   SW V0, -32704(GP)
129:                                 break;
9D005134  0B401458   J 0x9D005160
9D005138  00000000   NOP
130:                             }
131:                             case LED_STATE_ALL_OFF:
132:                             default:
133:                             {
134:                                 LED_ALL_OFF;
9D00513C  3C02BF88   LUI V0, -16504
9D005140  3403E000   ORI V1, ZERO, -8192
9D005144  AC4360E8   SW V1, 24808(V0)
9D005148  3C02BF88   LUI V0, -16504
9D00514C  2403013C   ADDIU V1, ZERO, 316
9D005150  AC436168   SW V1, 24936(V0)
135:                                 LEDState = LED_STATE_LED1_TOGGLE;
9D005154  24020001   ADDIU V0, ZERO, 1
9D005158  AF828040   SW V0, -32704(GP)
136:                                 break;
9D00515C  00000000   NOP
137:                             }
138:                         }
139:                     }
140:                     TRISThisData.LEDs.w.byte.LB=ReadLEDs();
9D005160  0F401340   JAL ReadLEDs
9D005164  00000000   NOP
9D005168  00401821   ADDU V1, V0, ZERO
9D00516C  3C02A000   LUI V0, -24576
9D005170  24420544   ADDIU V0, V0, 1348
9D005174  A0430004   SB V1, 4(V0)
9D005178  0B401464   J 0x9D005190
9D00517C  00000000   NOP
141:                 }
9D005190  03C0E821   ADDU SP, S8, ZERO
9D005194  8FBF001C   LW RA, 28(SP)
9D005198  8FBE0018   LW S8, 24(SP)
9D00519C  27BD0020   ADDIU SP, SP, 32
9D0051A0  03E00008   JR RA
9D0051A4  00000000   NOP
142:                 
143:                 /******************************************************************************/
144:                 
145:                 BOOL LEDAutoMode(BOOL toSet)
146:                 {
9D0051A8  27BDFFF0   ADDIU SP, SP, -16
9D0051AC  AFBE000C   SW S8, 12(SP)
9D0051B0  03A0F021   ADDU S8, SP, ZERO
9D0051B4  AFC40010   SW A0, 16(S8)
147:                     BOOL returnValue=FALSE;
9D0051B8  AFC00000   SW ZERO, 0(S8)
148:                     if(toSet)
9D0051BC  8FC20010   LW V0, 16(S8)
9D0051C0  10400006   BEQ V0, ZERO, 0x9D0051DC
9D0051C4  00000000   NOP
149:                     {
150:                         returnValue=TRUE;
9D0051C8  24020001   ADDIU V0, ZERO, 1
9D0051CC  AFC20000   SW V0, 0(S8)
151:                         LEDState=LED_STATE_ALL_OFF;
9D0051D0  AF808040   SW ZERO, -32704(GP)
9D0051D4  0B401479   J 0x9D0051E4
9D0051D8  00000000   NOP
152:                     }
153:                     else
154:                     {
155:                         LEDState=LED_STATE_MANUAL;
9D0051DC  24020009   ADDIU V0, ZERO, 9
9D0051E0  AF828040   SW V0, -32704(GP)
156:                     }
157:                     return returnValue;
9D0051E4  8FC20000   LW V0, 0(S8)
158:                 }
9D0051E8  03C0E821   ADDU SP, S8, ZERO
9D0051EC  8FBE000C   LW S8, 12(SP)
9D0051F0  27BD0010   ADDIU SP, SP, 16
9D0051F4  03E00008   JR RA
9D0051F8  00000000   NOP
159:                 
160:                 BOOL GetLEDAutoMode(void)
161:                 {
9D0051FC  27BDFFF8   ADDIU SP, SP, -8
9D005200  AFBE0004   SW S8, 4(SP)
9D005204  03A0F021   ADDU S8, SP, ZERO
162:                     return autoMode;
9D005208  8F828044   LW V0, -32700(GP)
163:                 }
9D00520C  03C0E821   ADDU SP, S8, ZERO
9D005210  8FBE0004   LW S8, 4(SP)
9D005214  27BD0008   ADDIU SP, SP, 8
9D005218  03E00008   JR RA
9D00521C  00000000   NOP
164:                 /******************************************************************************/
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/I2C_Bus_Master.c  -----------------------------
1:                   /******************************************************************************/
2:                   /* File: I2C_Bus_Master.c                                                     */
3:                   /* Author: Matt Bennett                                                       */
4:                   /* Date: December 26, 2011                                                    */
5:                   /* Version: 0.95                                                              */
6:                   /*                                                                            */
7:                   /* Description: Interrupt driven code for an I2C master. State based.         */
8:                   /*  Queue a command, wait for it to be complete, copy the data from the       */
9:                   /*  interrupt accessible variables.                                           */
10:                  /*                                                                            */
11:                  /******************************************************************************/
12:                  
13:                  #include <common.h>
14:                  #include <i2c.h>
15:                  #include <int.h>
16:                  #include <delay.h>
17:                  #include <I2C_Bus_Master.h>
18:                  
19:                  /******************************************************************************/
20:                  
21:                  I2C_MASTER_PORT_TYPE MasterI2CPort;
22:                  
23:                  /* just here for being able to see this in a watch window                     */
24:                  //extern I2CBUS_COMMAND_TYPE I2CCommand;
25:                  
26:                  /******************************************************************************/
27:                  
28:                  #ifdef I2C_USE_TIMEOUT
29:                  /******************************************************************************/
30:                  /* Timeout interrupt                                                          */
31:                  /******************************************************************************/
32:                  
33:                  void __ISR(/*INT_TIMER_VECTOR(I2C_TIMEOUT_TIMER)*/_TIMER_5_VECTOR,TIMEOUT_INT_PRIORITY_ISR) I2CTimeoutInterrupt(void)
34:                  {
9D000020  415DE800   RDPGPR SP, SP
9D000024  401A7000   MFC0 K0, EPC
9D000028  401B6000   MFC0 K1, Status
9D00002C  27BDFF88   ADDIU SP, SP, -120
9D000030  AFBA0074   SW K0, 116(SP)
9D000034  401A6002   MFC0 K0, SRSCtl
9D000038  AFBB0070   SW K1, 112(SP)
9D00003C  AFBA006C   SW K0, 108(SP)
9D000040  7C1B7844   INS K1, ZERO, 1, 15
9D000044  377B1000   ORI K1, K1, 4096
9D000048  409B6000   MTC0 K1, Status
9D00004C  AFBF005C   SW RA, 92(SP)
9D000050  AFBE0058   SW S8, 88(SP)
9D000054  AFB90054   SW T9, 84(SP)
9D000058  AFB80050   SW T8, 80(SP)
9D00005C  AFAF004C   SW T7, 76(SP)
9D000060  AFAE0048   SW T6, 72(SP)
9D000064  AFAD0044   SW T5, 68(SP)
9D000068  AFAC0040   SW T4, 64(SP)
9D00006C  AFAB003C   SW T3, 60(SP)
9D000070  AFAA0038   SW T2, 56(SP)
9D000074  AFA90034   SW T1, 52(SP)
9D000078  AFA80030   SW T0, 48(SP)
9D00007C  AFA7002C   SW A3, 44(SP)
9D000080  AFA60028   SW A2, 40(SP)
9D000084  AFA50024   SW A1, 36(SP)
9D000088  AFA40020   SW A0, 32(SP)
9D00008C  AFA3001C   SW V1, 28(SP)
9D000090  AFA20018   SW V0, 24(SP)
9D000094  AFA10014   SW AT, 20(SP)
9D000098  00001012   MFLO V0, 0
9D00009C  AFA20064   SW V0, 100(SP)
9D0000A0  00001810   MFHI V1, 0
9D0000A4  AFA30060   SW V1, 96(SP)
9D0000A8  03A0F021   ADDU S8, SP, ZERO
35:                      INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D0000AC  2404000C   ADDIU A0, ZERO, 12
9D0000B0  0F4017B8   JAL INTClearFlag
9D0000B4  00000000   NOP
36:                      MasterI2CPort.status.flags.I2C_timeout=TRUE;
9D0000B8  3C03A000   LUI V1, -24576
9D0000BC  8C6203E4   LW V0, 996(V1)
9D0000C0  24040001   ADDIU A0, ZERO, 1
9D0000C4  7C825AC4   INS V0, A0, 11, 1
9D0000C8  AC6203E4   SW V0, 996(V1)
37:                      MasterI2CPort.status.flags.I2C_error=TRUE;
9D0000CC  3C03A000   LUI V1, -24576
9D0000D0  8C6203E4   LW V0, 996(V1)
9D0000D4  24040001   ADDIU A0, ZERO, 1
9D0000D8  7C823184   INS V0, A0, 6, 1
9D0000DC  AC6203E4   SW V0, 996(V1)
38:                      MasterI2CPort.status.flags.I2C_action_complete=TRUE;
9D0000E0  3C03A000   LUI V1, -24576
9D0000E4  8C6203E4   LW V0, 996(V1)
9D0000E8  24040001   ADDIU A0, ZERO, 1
9D0000EC  7C825284   INS V0, A0, 10, 1
9D0000F0  AC6203E4   SW V0, 996(V1)
39:                      MasterI2CPort.status.flags.I2C_busy=FALSE;
9D0000F4  3C03A000   LUI V1, -24576
9D0000F8  8C6203E4   LW V0, 996(V1)
9D0000FC  7C0218C4   INS V0, ZERO, 3, 1
9D000100  AC6203E4   SW V0, 996(V1)
40:                      mMasterI2CTimeoutStopTimer();
9D000104  3C03BF80   LUI V1, -16512
9D000108  8C620E00   LW V0, 3584(V1)
9D00010C  7C027BC4   INS V0, ZERO, 15, 1
9D000110  AC620E00   SW V0, 3584(V1)
41:                      INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000114  2404003D   ADDIU A0, ZERO, 61
9D000118  00002821   ADDU A1, ZERO, ZERO
9D00011C  0F4016DD   JAL INTEnable
9D000120  00000000   NOP
42:                  }
9D000124  03C0E821   ADDU SP, S8, ZERO
9D000128  8FA20064   LW V0, 100(SP)
9D00012C  00400013   MTLO V0, 0
9D000130  8FA30060   LW V1, 96(SP)
9D000134  00600011   MTHI V1, 0
9D000138  8FBF005C   LW RA, 92(SP)
9D00013C  8FBE0058   LW S8, 88(SP)
9D000140  8FB90054   LW T9, 84(SP)
9D000144  8FB80050   LW T8, 80(SP)
9D000148  8FAF004C   LW T7, 76(SP)
9D00014C  8FAE0048   LW T6, 72(SP)
9D000150  8FAD0044   LW T5, 68(SP)
9D000154  8FAC0040   LW T4, 64(SP)
9D000158  8FAB003C   LW T3, 60(SP)
9D00015C  8FAA0038   LW T2, 56(SP)
9D000160  8FA90034   LW T1, 52(SP)
9D000164  8FA80030   LW T0, 48(SP)
9D000168  8FA7002C   LW A3, 44(SP)
9D00016C  8FA60028   LW A2, 40(SP)
9D000170  8FA50024   LW A1, 36(SP)
9D000174  8FA40020   LW A0, 32(SP)
9D000178  8FA3001C   LW V1, 28(SP)
9D00017C  8FA20018   LW V0, 24(SP)
9D000180  8FA10014   LW AT, 20(SP)
9D000184  41606000   DI ZERO
9D000188  000000C0   EHB
9D00018C  8FBA0074   LW K0, 116(SP)
9D000190  8FBB0070   LW K1, 112(SP)
9D000194  409A7000   MTC0 K0, EPC
9D000198  8FBA006C   LW K0, 108(SP)
9D00019C  27BD0078   ADDIU SP, SP, 120
9D0001A0  409A6002   MTC0 K0, SRSCtl
9D0001A4  41DDE800   WRPGPR SP, SP
9D0001A8  409B6000   MTC0 K1, Status
9D0001AC  42000018   ERET
43:                  #endif
44:                  
45:                  /******************************************************************************/
46:                  /* I2C Master interrupt                                                       */
47:                  /******************************************************************************/
48:                  
49:                  void __ISR (_I2C_2_VECTOR,MI2C_INT_PRIORITY_ISR) _MI2C2Interrupt(void)
50:                  {
9D0001B0  415DE800   RDPGPR SP, SP
9D0001B4  401A7000   MFC0 K0, EPC
9D0001B8  401B6000   MFC0 K1, Status
9D0001BC  27BDFF88   ADDIU SP, SP, -120
9D0001C0  AFBA0074   SW K0, 116(SP)
9D0001C4  401A6002   MFC0 K0, SRSCtl
9D0001C8  AFBB0070   SW K1, 112(SP)
9D0001CC  AFBA006C   SW K0, 108(SP)
9D0001D0  7C1B7844   INS K1, ZERO, 1, 15
9D0001D4  377B1800   ORI K1, K1, 6144
9D0001D8  409B6000   MTC0 K1, Status
9D0001DC  AFBF005C   SW RA, 92(SP)
9D0001E0  AFBE0058   SW S8, 88(SP)
9D0001E4  AFB90054   SW T9, 84(SP)
9D0001E8  AFB80050   SW T8, 80(SP)
9D0001EC  AFAF004C   SW T7, 76(SP)
9D0001F0  AFAE0048   SW T6, 72(SP)
9D0001F4  AFAD0044   SW T5, 68(SP)
9D0001F8  AFAC0040   SW T4, 64(SP)
9D0001FC  AFAB003C   SW T3, 60(SP)
9D000200  AFAA0038   SW T2, 56(SP)
9D000204  AFA90034   SW T1, 52(SP)
9D000208  AFA80030   SW T0, 48(SP)
9D00020C  AFA7002C   SW A3, 44(SP)
9D000210  AFA60028   SW A2, 40(SP)
9D000214  AFA50024   SW A1, 36(SP)
9D000218  AFA40020   SW A0, 32(SP)
9D00021C  AFA3001C   SW V1, 28(SP)
9D000220  AFA20018   SW V0, 24(SP)
9D000224  AFA10014   SW AT, 20(SP)
9D000228  00001012   MFLO V0, 0
9D00022C  AFA20064   SW V0, 100(SP)
9D000230  00001810   MFHI V1, 0
9D000234  AFA30060   SW V1, 96(SP)
9D000238  03A0F021   ADDU S8, SP, ZERO
51:                      static UINT8 temp; /* used by dummy read to clear RBF flag */
52:                      INTClearFlag(INT_SOURCE_I2C_MASTER(I2C_PORT));
9D00023C  2404003D   ADDIU A0, ZERO, 61
9D000240  0F4017B8   JAL INTClearFlag
9D000244  00000000   NOP
53:                      /* save a copy of I2C2STAT */
54:                      MasterI2CPort.STATShadow.w=I2C_STATUS;
9D000248  3C02BF80   LUI V0, -16512
9D00024C  8C435410   LW V1, 21520(V0)
9D000250  3C02A000   LUI V0, -24576
9D000254  244203E4   ADDIU V0, V0, 996
9D000258  AC430018   SW V1, 24(V0)
55:                      #ifdef I2C_USE_TIMEOUT
56:                          mMasterI2CTimeoutClearTimer();
9D00025C  3C03BF80   LUI V1, -16512
9D000260  8C620E00   LW V0, 3584(V1)
9D000264  7C027BC4   INS V0, ZERO, 15, 1
9D000268  AC620E00   SW V0, 3584(V1)
9D00026C  3C02BF80   LUI V0, -16512
9D000270  AC400E10   SW ZERO, 3600(V0)
9D000274  3C03BF80   LUI V1, -16512
9D000278  8C620E00   LW V0, 3584(V1)
9D00027C  24040001   ADDIU A0, ZERO, 1
9D000280  7C827BC4   INS V0, A0, 15, 1
9D000284  AC620E00   SW V0, 3584(V1)
57:                          /* if we get an I2C interrupt, there wasn't a timeout*/
58:                          INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D000288  2404000C   ADDIU A0, ZERO, 12
9D00028C  0F4017B8   JAL INTClearFlag
9D000290  00000000   NOP
59:                      #endif /* #ifdef I2C_USE_TIMEOUT */
60:                      if((MasterI2CPort.STATShadow.I2COV==TRUE) ||
9D000294  3C02A000   LUI V0, -24576
9D000298  244203E4   ADDIU V0, V0, 996
9D00029C  8C420018   LW V0, 24(V0)
9D0002A0  30420040   ANDI V0, V0, 64
9D0002A4  14400007   BNE V0, ZERO, 0x9D0002C4
9D0002A8  00000000   NOP
9D0002BC  1040000F   BEQ V0, ZERO, 0x9D0002FC
9D0002C0  00000000   NOP
61:                         (MasterI2CPort.STATShadow.IWCOL==TRUE))
9D0002AC  3C02A000   LUI V0, -24576
9D0002B0  244203E4   ADDIU V0, V0, 996
9D0002B4  8C420018   LW V0, 24(V0)
9D0002B8  30420080   ANDI V0, V0, 128
62:                      {
63:                          MasterI2CPort.status.flags.I2C_error = TRUE;
9D0002C4  3C03A000   LUI V1, -24576
9D0002C8  8C6203E4   LW V0, 996(V1)
9D0002CC  24040001   ADDIU A0, ZERO, 1
9D0002D0  7C823184   INS V0, A0, 6, 1
9D0002D4  AC6203E4   SW V0, 996(V1)
64:                          MasterI2CPort.status.flags.I2C_error_overrun = TRUE;
9D0002D8  3C03A000   LUI V1, -24576
9D0002DC  8C6203E4   LW V0, 996(V1)
9D0002E0  24040001   ADDIU A0, ZERO, 1
9D0002E4  7C824A44   INS V0, A0, 9, 1
9D0002E8  AC6203E4   SW V0, 996(V1)
65:                          /* the STOP state does all the shutdown we need                       */
66:                          MasterI2CPort.state = MI2CINT_STOP;
9D0002EC  3C02A000   LUI V0, -24576
9D0002F0  244203E4   ADDIU V0, V0, 996
9D0002F4  24030008   ADDIU V1, ZERO, 8
9D0002F8  AC430014   SW V1, 20(V0)
67:                      }
68:                      switch(MasterI2CPort.state)
9D0002FC  3C02A000   LUI V0, -24576
9D000300  244203E4   ADDIU V0, V0, 996
9D000304  8C420014   LW V0, 20(V0)
9D000308  2C430009   SLTIU V1, V0, 9
9D00030C  10600174   BEQ V1, ZERO, 0x9D0008E0
9D000310  00000000   NOP
9D000314  00021880   SLL V1, V0, 2
9D000318  3C029D00   LUI V0, -25344
9D00031C  24420330   ADDIU V0, V0, 816
9D000320  00621021   ADDU V0, V1, V0
9D000324  8C420000   LW V0, 0(V0)
9D000328  00400008   JR V0
9D00032C  00000000   NOP
69:                      {
70:                          case MI2CINT_START:
71:                          {
72:                              /* send the address ... which one?                                */
73:                              if (MasterI2CPort.status.flags.I2C_receive)
9D000354  3C02A000   LUI V0, -24576
9D000358  8C4203E4   LW V0, 996(V0)
9D00035C  30420001   ANDI V0, V0, 1
9D000360  1040000F   BEQ V0, ZERO, 0x9D0003A0
9D000364  00000000   NOP
74:                              {
75:                                  /* send read address                                          */
76:                                  I2C2TRN = MasterI2CPort.target_address | I2C_READ_BIT;
9D000368  3C02A000   LUI V0, -24576
9D00036C  244203E4   ADDIU V0, V0, 996
9D000370  90420005   LBU V0, 5(V0)
9D000374  34420001   ORI V0, V0, 1
9D000378  304200FF   ANDI V0, V0, 255
9D00037C  00401821   ADDU V1, V0, ZERO
9D000380  3C02BF80   LUI V0, -16512
9D000384  AC435450   SW V1, 21584(V0)
77:                                  MasterI2CPort.state = MI2CINT_RX_ADDRESS_ACK;
9D000388  3C02A000   LUI V0, -24576
9D00038C  244203E4   ADDIU V0, V0, 996
9D000390  24030003   ADDIU V1, ZERO, 3
9D000394  AC430014   SW V1, 20(V0)
78:                              } 
79:                              else
80:                              {
81:                                  /* send write address                                         */
82:                                  I2C2TRN = MasterI2CPort.target_address | I2C_WRITE_BIT;
9D0003A0  3C02A000   LUI V0, -24576
9D0003A4  244203E4   ADDIU V0, V0, 996
9D0003A8  90420005   LBU V0, 5(V0)
9D0003AC  00401821   ADDU V1, V0, ZERO
9D0003B0  3C02BF80   LUI V0, -16512
9D0003B4  AC435450   SW V1, 21584(V0)
83:                                  MasterI2CPort.state = MI2CINT_TX_ADDRESS_ACK;
9D0003B8  3C02A000   LUI V0, -24576
9D0003BC  244203E4   ADDIU V0, V0, 996
9D0003C0  24030001   ADDIU V1, ZERO, 1
9D0003C4  AC430014   SW V1, 20(V0)
84:                              }
85:                              break;
9D000398  0B40024E   J 0x9D000938
9D00039C  00000000   NOP
9D0003C8  0B40024E   J 0x9D000938
9D0003CC  00000000   NOP
86:                          }
87:                          case MI2CINT_TX_ADDRESS_ACK:
88:                          {
89:                              if (MasterI2CPort.STATShadow.ACKSTAT == I2C_NAK)
9D0003D0  3C02A000   LUI V0, -24576
9D0003D4  244203E4   ADDIU V0, V0, 996
9D0003D8  8C420018   LW V0, 24(V0)
9D0003DC  30428000   ANDI V0, V0, -32768
9D0003E0  10400014   BEQ V0, ZERO, 0x9D000434
9D0003E4  00000000   NOP
90:                              {
91:                                  /* if NAK, nobody acknowledged                                */
92:                                  MasterI2CPort.status.flags.I2C_error = TRUE;
9D0003E8  3C03A000   LUI V1, -24576
9D0003EC  8C6203E4   LW V0, 996(V1)
9D0003F0  24040001   ADDIU A0, ZERO, 1
9D0003F4  7C823184   INS V0, A0, 6, 1
9D0003F8  AC6203E4   SW V0, 996(V1)
93:                                  MasterI2CPort.status.flags.I2C_no_slave_addr_ack = TRUE;
9D0003FC  3C03A000   LUI V1, -24576
9D000400  8C6203E4   LW V0, 996(V1)
9D000404  24040001   ADDIU A0, ZERO, 1
9D000408  7C822104   INS V0, A0, 4, 1
9D00040C  AC6203E4   SW V0, 996(V1)
94:                                  I2CStop(I2C_PORT);
9D000410  24040001   ADDIU A0, ZERO, 1
9D000414  0F4017F4   JAL I2CStop
9D000418  00000000   NOP
95:                                  MasterI2CPort.state = MI2CINT_STOP;
9D00041C  3C02A000   LUI V0, -24576
9D000420  244203E4   ADDIU V0, V0, 996
9D000424  24030008   ADDIU V1, ZERO, 8
9D000428  AC430014   SW V1, 20(V0)
96:                              } 
97:                              else
98:                              {
99:                                  /* there was an acknowledge, send the first byte              */
100:                                 I2C2TRN = MasterI2CPort.Word[0];
9D000434  3C02A000   LUI V0, -24576
9D000438  244203E4   ADDIU V0, V0, 996
9D00043C  8C420008   LW V0, 8(V0)
9D000440  90420000   LBU V0, 0(V0)
9D000444  00401821   ADDU V1, V0, ZERO
9D000448  3C02BF80   LUI V0, -16512
9D00044C  AC435450   SW V1, 21584(V0)
101:                                 /* point to the next piece of data to send                    */
102:                                 MasterI2CPort.data_index = 1;
9D000450  3C02A000   LUI V0, -24576
9D000454  244203E4   ADDIU V0, V0, 996
9D000458  24030001   ADDIU V1, ZERO, 1
9D00045C  A0430004   SB V1, 4(V0)
103:                                 MasterI2CPort.state = MI2CINT_TX_DATA_ACK;
9D000460  3C02A000   LUI V0, -24576
9D000464  244203E4   ADDIU V0, V0, 996
9D000468  24030002   ADDIU V1, ZERO, 2
9D00046C  AC430014   SW V1, 20(V0)
104:                             }
105:                             break;
9D00042C  0B40024E   J 0x9D000938
9D000430  00000000   NOP
9D000470  0B40024E   J 0x9D000938
9D000474  00000000   NOP
106:                         }
107:                         case MI2CINT_TX_DATA_ACK:
108:                         {
109:                             if (MasterI2CPort.STATShadow.ACKSTAT == I2C_NAK)
9D000478  3C02A000   LUI V0, -24576
9D00047C  244203E4   ADDIU V0, V0, 996
9D000480  8C420018   LW V0, 24(V0)
9D000484  30428000   ANDI V0, V0, -32768
9D000488  10400014   BEQ V0, ZERO, 0x9D0004DC
9D00048C  00000000   NOP
110:                             {
111:                                 /* if NAK, nobody acknowledged                                */
112:                                 MasterI2CPort.status.flags.I2C_error = TRUE;
9D000490  3C03A000   LUI V1, -24576
9D000494  8C6203E4   LW V0, 996(V1)
9D000498  24040001   ADDIU A0, ZERO, 1
9D00049C  7C823184   INS V0, A0, 6, 1
9D0004A0  AC6203E4   SW V0, 996(V1)
113:                                 MasterI2CPort.status.flags.I2C_no_slave_data_ack = TRUE;
9D0004A4  3C03A000   LUI V1, -24576
9D0004A8  8C6203E4   LW V0, 996(V1)
9D0004AC  24040001   ADDIU A0, ZERO, 1
9D0004B0  7C822944   INS V0, A0, 5, 1
9D0004B4  AC6203E4   SW V0, 996(V1)
114:                                 I2CStop(I2C_PORT);
9D0004B8  24040001   ADDIU A0, ZERO, 1
9D0004BC  0F4017F4   JAL I2CStop
9D0004C0  00000000   NOP
115:                                 //mMasterI2CStopStart(); /* Send the Stop condition            */
116:                                 MasterI2CPort.state = MI2CINT_STOP;
9D0004C4  3C02A000   LUI V0, -24576
9D0004C8  244203E4   ADDIU V0, V0, 996
9D0004CC  24030008   ADDIU V1, ZERO, 8
9D0004D0  AC430014   SW V1, 20(V0)
117:                             } 
118:                             else /* there was an ACK                                          */
119:                             {
120:                                 /* have I written all the data?                               */
121:                                 if (MasterI2CPort.data_index >= MasterI2CPort.WordSize)
9D0004DC  3C02A000   LUI V0, -24576
9D0004E0  244203E4   ADDIU V0, V0, 996
9D0004E4  90430004   LBU V1, 4(V0)
9D0004E8  3C02A000   LUI V0, -24576
9D0004EC  244203E4   ADDIU V0, V0, 996
9D0004F0  90420011   LBU V0, 17(V0)
9D0004F4  0062102B   SLTU V0, V1, V0
9D0004F8  1440001C   BNE V0, ZERO, 0x9D00056C
9D0004FC  00000000   NOP
122:                                 {
123:                                     /* done with what we're going to write                    */
124:                                     if (MasterI2CPort.status.flags.I2C_read)
9D000500  3C02A000   LUI V0, -24576
9D000504  8C4203E4   LW V0, 996(V0)
9D000508  30420004   ANDI V0, V0, 4
9D00050C  1040000E   BEQ V0, ZERO, 0x9D000548
9D000510  00000000   NOP
125:                                     {
126:                                         mMasterI2CClearRBF();
9D000514  3C02BF80   LUI V0, -16512
9D000518  8C425460   LW V0, 21600(V0)
9D00051C  304200FF   ANDI V0, V0, 255
9D000520  A3828014   SB V0, -32748(GP)
127:                                         I2CRepeatStart(I2C_PORT);
9D000524  24040001   ADDIU A0, ZERO, 1
9D000528  0F401796   JAL I2CRepeatStart
9D00052C  00000000   NOP
128:                                         MasterI2CPort.state = MI2CINT_RESTART_END;
9D000530  3C02A000   LUI V0, -24576
9D000534  244203E4   ADDIU V0, V0, 996
9D000538  24030004   ADDIU V1, ZERO, 4
9D00053C  AC430014   SW V1, 20(V0)
129:                                     } 
130:                                     else
131:                                     {
132:                                         /* must be a write, and we're done                    */
133:                                         I2CStop(I2C_PORT);
9D000548  24040001   ADDIU A0, ZERO, 1
9D00054C  0F4017F4   JAL I2CStop
9D000550  00000000   NOP
134:                                         MasterI2CPort.state = MI2CINT_STOP;
9D000554  3C02A000   LUI V0, -24576
9D000558  244203E4   ADDIU V0, V0, 996
9D00055C  24030008   ADDIU V1, ZERO, 8
9D000560  AC430014   SW V1, 20(V0)
135:                                     }
136:                                 } 
137:                                 else
138:                                 {
139:                                     /* bounds check so we don't overrun the .Word array       */
140:                                     if (MasterI2CPort.data_index < I2CBUS_WORD_LENGTH)
9D00056C  3C02A000   LUI V0, -24576
9D000570  244203E4   ADDIU V0, V0, 996
9D000574  90420004   LBU V0, 4(V0)
9D000578  2C42000A   SLTIU V0, V0, 10
9D00057C  10400016   BEQ V0, ZERO, 0x9D0005D8
9D000580  00000000   NOP
141:                                     {
142:                                         I2C2TRN = MasterI2CPort.Word[MasterI2CPort.data_index];
9D000584  3C02A000   LUI V0, -24576
9D000588  244203E4   ADDIU V0, V0, 996
9D00058C  8C430008   LW V1, 8(V0)
9D000590  3C02A000   LUI V0, -24576
9D000594  244203E4   ADDIU V0, V0, 996
9D000598  90420004   LBU V0, 4(V0)
9D00059C  00621021   ADDU V0, V1, V0
9D0005A0  90420000   LBU V0, 0(V0)
9D0005A4  00401821   ADDU V1, V0, ZERO
9D0005A8  3C02BF80   LUI V0, -16512
9D0005AC  AC435450   SW V1, 21584(V0)
143:                                         /* point at next bit of data to send                  */
144:                                         MasterI2CPort.data_index++;
9D0005B0  3C02A000   LUI V0, -24576
9D0005B4  244203E4   ADDIU V0, V0, 996
9D0005B8  90420004   LBU V0, 4(V0)
9D0005BC  24420001   ADDIU V0, V0, 1
9D0005C0  304300FF   ANDI V1, V0, 255
9D0005C4  3C02A000   LUI V0, -24576
9D0005C8  244203E4   ADDIU V0, V0, 996
9D0005CC  A0430004   SB V1, 4(V0)
145:                                         /* and stay in this state                             */
146:                                     } 
147:                                     else
148:                                     {
149:                                         /* something is making us overrun the .Word array     */
150:                                         MasterI2CPort.status.flags.I2C_error = TRUE;
9D0005D8  3C03A000   LUI V1, -24576
9D0005DC  8C6203E4   LW V0, 996(V1)
9D0005E0  24040001   ADDIU A0, ZERO, 1
9D0005E4  7C823184   INS V0, A0, 6, 1
9D0005E8  AC6203E4   SW V0, 996(V1)
151:                                         MasterI2CPort.status.flags.I2C_FUBAR_error = TRUE;
9D0005EC  3C03A000   LUI V1, -24576
9D0005F0  8C6203E4   LW V0, 996(V1)
9D0005F4  24040001   ADDIU A0, ZERO, 1
9D0005F8  7C8239C4   INS V0, A0, 7, 1
9D0005FC  AC6203E4   SW V0, 996(V1)
152:                                         I2CStop(I2C_PORT);
9D000600  24040001   ADDIU A0, ZERO, 1
9D000604  0F4017F4   JAL I2CStop
9D000608  00000000   NOP
153:                                         MasterI2CPort.state = MI2CINT_STOP;
9D00060C  3C02A000   LUI V0, -24576
9D000610  244203E4   ADDIU V0, V0, 996
9D000614  24030008   ADDIU V1, ZERO, 8
9D000618  AC430014   SW V1, 20(V0)
154:                                     }
155:                                 }
156:                             }
157:                             break;
9D0004D4  0B40024E   J 0x9D000938
9D0004D8  00000000   NOP
9D000540  0B40024E   J 0x9D000938
9D000544  00000000   NOP
9D000564  0B40024E   J 0x9D000938
9D000568  00000000   NOP
9D0005D0  0B40024E   J 0x9D000938
9D0005D4  00000000   NOP
9D00061C  0B40024E   J 0x9D000938
9D000620  00000000   NOP
158:                         }
159:                         case MI2CINT_RESTART_END:
160:                         {
161:                             /* send read address                                              */
162:                             I2C2TRN = MasterI2CPort.target_address | I2C_READ_BIT;
9D000624  3C02A000   LUI V0, -24576
9D000628  244203E4   ADDIU V0, V0, 996
9D00062C  90420005   LBU V0, 5(V0)
9D000630  34420001   ORI V0, V0, 1
9D000634  304200FF   ANDI V0, V0, 255
9D000638  00401821   ADDU V1, V0, ZERO
9D00063C  3C02BF80   LUI V0, -16512
9D000640  AC435450   SW V1, 21584(V0)
163:                             MasterI2CPort.state = MI2CINT_RX_ADDRESS_ACK;
9D000644  3C02A000   LUI V0, -24576
9D000648  244203E4   ADDIU V0, V0, 996
9D00064C  24030003   ADDIU V1, ZERO, 3
9D000650  AC430014   SW V1, 20(V0)
164:                             break;
9D000654  0B40024E   J 0x9D000938
9D000658  00000000   NOP
165:                         }
166:                         case MI2CINT_RX_ADDRESS_ACK:
167:                         {
168:                             if (MasterI2CPort.STATShadow.ACKSTAT == I2C_NAK)
9D00065C  3C02A000   LUI V0, -24576
9D000660  244203E4   ADDIU V0, V0, 996
9D000664  8C420018   LW V0, 24(V0)
9D000668  30428000   ANDI V0, V0, -32768
9D00066C  10400014   BEQ V0, ZERO, 0x9D0006C0
9D000670  00000000   NOP
169:                             {
170:                                 /* if NAK, nobody acknowledged                                */
171:                                 MasterI2CPort.status.flags.I2C_error = TRUE;
9D000674  3C03A000   LUI V1, -24576
9D000678  8C6203E4   LW V0, 996(V1)
9D00067C  24040001   ADDIU A0, ZERO, 1
9D000680  7C823184   INS V0, A0, 6, 1
9D000684  AC6203E4   SW V0, 996(V1)
172:                                 MasterI2CPort.status.flags.I2C_no_slave_addr_ack = TRUE;
9D000688  3C03A000   LUI V1, -24576
9D00068C  8C6203E4   LW V0, 996(V1)
9D000690  24040001   ADDIU A0, ZERO, 1
9D000694  7C822104   INS V0, A0, 4, 1
9D000698  AC6203E4   SW V0, 996(V1)
173:                                 /* Send the Stop condition                                    */
174:                                 I2CStop(I2C_PORT);
9D00069C  24040001   ADDIU A0, ZERO, 1
9D0006A0  0F4017F4   JAL I2CStop
9D0006A4  00000000   NOP
175:                                 MasterI2CPort.state = MI2CINT_STOP;
9D0006A8  3C02A000   LUI V0, -24576
9D0006AC  244203E4   ADDIU V0, V0, 996
9D0006B0  24030008   ADDIU V1, ZERO, 8
9D0006B4  AC430014   SW V1, 20(V0)
176:                             } 
177:                             else
178:                             {
179:                                 MasterI2CPort.data_index = 0;
9D0006C0  3C02A000   LUI V0, -24576
9D0006C4  244203E4   ADDIU V0, V0, 996
9D0006C8  A0400004   SB ZERO, 4(V0)
180:                                 mMasterI2CClearRBF();
9D0006CC  3C02BF80   LUI V0, -16512
9D0006D0  8C425460   LW V0, 21600(V0)
9D0006D4  304200FF   ANDI V0, V0, 255
9D0006D8  A3828014   SB V0, -32748(GP)
181:                                 I2CReceiverEnable(I2C_PORT,TRUE);
9D0006DC  24040001   ADDIU A0, ZERO, 1
9D0006E0  24050001   ADDIU A1, ZERO, 1
9D0006E4  0F40176F   JAL I2CReceiverEnable
9D0006E8  00000000   NOP
182:                                 MasterI2CPort.state = MI2CINT_RX_DATA;
9D0006EC  3C02A000   LUI V0, -24576
9D0006F0  244203E4   ADDIU V0, V0, 996
9D0006F4  24030005   ADDIU V1, ZERO, 5
9D0006F8  AC430014   SW V1, 20(V0)
183:                             }
184:                             break;
9D0006B8  0B40024E   J 0x9D000938
9D0006BC  00000000   NOP
9D0006FC  0B40024E   J 0x9D000938
9D000700  00000000   NOP
185:                         }
186:                         case MI2CINT_RX_DATA:
187:                         {
188:                             /* Bounds check data_index for safe access of .Data[]             */
189:                             if (MasterI2CPort.data_index < I2CBUS_DATA_LENGTH)
9D000704  3C02A000   LUI V0, -24576
9D000708  244203E4   ADDIU V0, V0, 996
9D00070C  90420004   LBU V0, 4(V0)
9D000710  2C42000A   SLTIU V0, V0, 10
9D000714  1040002E   BEQ V0, ZERO, 0x9D0007D0
9D000718  00000000   NOP
190:                             {
191:                                 MasterI2CPort.Data[MasterI2CPort.data_index++] = I2C2RCV;
9D00071C  3C02A000   LUI V0, -24576
9D000720  244203E4   ADDIU V0, V0, 996
9D000724  8C44000C   LW A0, 12(V0)
9D000728  3C02A000   LUI V0, -24576
9D00072C  244203E4   ADDIU V0, V0, 996
9D000730  90420004   LBU V0, 4(V0)
9D000734  00401821   ADDU V1, V0, ZERO
9D000738  00831821   ADDU V1, A0, V1
9D00073C  3C04BF80   LUI A0, -16512
9D000740  8C845460   LW A0, 21600(A0)
9D000744  308400FF   ANDI A0, A0, 255
9D000748  A0640000   SB A0, 0(V1)
9D00074C  24420001   ADDIU V0, V0, 1
9D000750  304300FF   ANDI V1, V0, 255
9D000754  3C02A000   LUI V0, -24576
9D000758  244203E4   ADDIU V0, V0, 996
9D00075C  A0430004   SB V1, 4(V0)
192:                                 if (MasterI2CPort.data_index == MasterI2CPort.DataSize) 
9D000760  3C02A000   LUI V0, -24576
9D000764  244203E4   ADDIU V0, V0, 996
9D000768  90430004   LBU V1, 4(V0)
9D00076C  3C02A000   LUI V0, -24576
9D000770  244203E4   ADDIU V0, V0, 996
9D000774  90420010   LBU V0, 16(V0)
9D000778  1462000B   BNE V1, V0, 0x9D0007A8
9D00077C  00000000   NOP
193:                                 {
194:                                     I2CAcknowledgeByte(I2C_PORT,FALSE);
9D000780  24040001   ADDIU A0, ZERO, 1
9D000784  00002821   ADDU A1, ZERO, ZERO
9D000788  0F4016F1   JAL I2CAcknowledgeByte
9D00078C  00000000   NOP
195:                                     MasterI2CPort.state = MI2CINT_RX_DATA_NAK;
9D000790  3C02A000   LUI V0, -24576
9D000794  244203E4   ADDIU V0, V0, 996
9D000798  24030007   ADDIU V1, ZERO, 7
9D00079C  AC430014   SW V1, 20(V0)
196:                                 } 
197:                                 else
198:                                 {
199:                                     /* send ACK to signify there will be more                 */
200:                                     I2CAcknowledgeByte(I2C_PORT,TRUE);
9D0007A8  24040001   ADDIU A0, ZERO, 1
9D0007AC  24050001   ADDIU A1, ZERO, 1
9D0007B0  0F4016F1   JAL I2CAcknowledgeByte
9D0007B4  00000000   NOP
201:                                     MasterI2CPort.state = MI2CINT_RX_DATA_ACK;
9D0007B8  3C02A000   LUI V0, -24576
9D0007BC  244203E4   ADDIU V0, V0, 996
9D0007C0  24030006   ADDIU V1, ZERO, 6
9D0007C4  AC430014   SW V1, 20(V0)
202:                                 }
203:                             } 
204:                             else
205:                             {
206:                                 MasterI2CPort.state = MI2CINT_RX_DATA_NAK;
9D0007D0  3C02A000   LUI V0, -24576
9D0007D4  244203E4   ADDIU V0, V0, 996
9D0007D8  24030007   ADDIU V1, ZERO, 7
9D0007DC  AC430014   SW V1, 20(V0)
207:                                 MasterI2CPort.status.flags.I2C_error = TRUE;
9D0007E0  3C03A000   LUI V1, -24576
9D0007E4  8C6203E4   LW V0, 996(V1)
9D0007E8  24040001   ADDIU A0, ZERO, 1
9D0007EC  7C823184   INS V0, A0, 6, 1
9D0007F0  AC6203E4   SW V0, 996(V1)
208:                                 MasterI2CPort.status.flags.I2C_FUBAR_error = TRUE;
9D0007F4  3C03A000   LUI V1, -24576
9D0007F8  8C6203E4   LW V0, 996(V1)
9D0007FC  24040001   ADDIU A0, ZERO, 1
9D000800  7C8239C4   INS V0, A0, 7, 1
9D000804  AC6203E4   SW V0, 996(V1)
209:                                 I2CAcknowledgeByte(I2C_PORT,FALSE);
9D000808  24040001   ADDIU A0, ZERO, 1
9D00080C  00002821   ADDU A1, ZERO, ZERO
9D000810  0F4016F1   JAL I2CAcknowledgeByte
9D000814  00000000   NOP
210:                             }
211:                             break;
9D0007A0  0B40024E   J 0x9D000938
9D0007A4  00000000   NOP
9D0007C8  0B40024E   J 0x9D000938
9D0007CC  00000000   NOP
9D000818  0B40024E   J 0x9D000938
9D00081C  00000000   NOP
212:                         }
213:                         case MI2CINT_RX_DATA_ACK:
214:                         {
215:                             /* still have more to recieve- start another RX cycle             */
216:                             I2CReceiverEnable(I2C_PORT,TRUE);
9D000820  24040001   ADDIU A0, ZERO, 1
9D000824  24050001   ADDIU A1, ZERO, 1
9D000828  0F40176F   JAL I2CReceiverEnable
9D00082C  00000000   NOP
217:                             MasterI2CPort.state = MI2CINT_RX_DATA;
9D000830  3C02A000   LUI V0, -24576
9D000834  244203E4   ADDIU V0, V0, 996
9D000838  24030005   ADDIU V1, ZERO, 5
9D00083C  AC430014   SW V1, 20(V0)
218:                             break;
9D000840  0B40024E   J 0x9D000938
9D000844  00000000   NOP
219:                         }
220:                         case MI2CINT_RX_DATA_NAK:
221:                         {
222:                             /* No more to send, or an error case- send the Stop condition     */
223:                             I2CStop(I2C_PORT);
9D000848  24040001   ADDIU A0, ZERO, 1
9D00084C  0F4017F4   JAL I2CStop
9D000850  00000000   NOP
224:                             MasterI2CPort.state = MI2CINT_STOP;
9D000854  3C02A000   LUI V0, -24576
9D000858  244203E4   ADDIU V0, V0, 996
9D00085C  24030008   ADDIU V1, ZERO, 8
9D000860  AC430014   SW V1, 20(V0)
225:                             break;
9D000864  0B40024E   J 0x9D000938
9D000868  00000000   NOP
226:                         }
227:                         case MI2CINT_STOP:
228:                         {
229:                             MasterI2CPort.status.flags.I2C_action_complete = TRUE;
9D00086C  3C03A000   LUI V1, -24576
9D000870  8C6203E4   LW V0, 996(V1)
9D000874  24040001   ADDIU A0, ZERO, 1
9D000878  7C825284   INS V0, A0, 10, 1
9D00087C  AC6203E4   SW V0, 996(V1)
230:                             MasterI2CPort.status.flags.I2C_busy = FALSE;
9D000880  3C03A000   LUI V1, -24576
9D000884  8C6203E4   LW V0, 996(V1)
9D000888  7C0218C4   INS V0, ZERO, 3, 1
9D00088C  AC6203E4   SW V0, 996(V1)
231:                             INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000890  2404003D   ADDIU A0, ZERO, 61
9D000894  00002821   ADDU A1, ZERO, ZERO
9D000898  0F4016DD   JAL INTEnable
9D00089C  00000000   NOP
232:                             #ifdef I2C_USE_TIMEOUT
233:                                 mMasterI2CTimeoutStopTimer();
9D0008A0  3C03BF80   LUI V1, -16512
9D0008A4  8C620E00   LW V0, 3584(V1)
9D0008A8  7C027BC4   INS V0, ZERO, 15, 1
9D0008AC  AC620E00   SW V0, 3584(V1)
234:                                 INTEnable(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER),INT_DISABLED);
9D0008B0  2404000C   ADDIU A0, ZERO, 12
9D0008B4  00002821   ADDU A1, ZERO, ZERO
9D0008B8  0F4016DD   JAL INTEnable
9D0008BC  00000000   NOP
235:                                 INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D0008C0  2404000C   ADDIU A0, ZERO, 12
9D0008C4  0F4017B8   JAL INTClearFlag
9D0008C8  00000000   NOP
236:                             #endif
237:                             /* prepare the state machine for next round                       */
238:                             MasterI2CPort.state = MI2CINT_START;
9D0008CC  3C02A000   LUI V0, -24576
9D0008D0  244203E4   ADDIU V0, V0, 996
9D0008D4  AC400014   SW ZERO, 20(V0)
239:                             break;
9D0008D8  0B40024E   J 0x9D000938
9D0008DC  00000000   NOP
240:                         }
241:                         default:
242:                         {
243:                             mMasterI2CClearRBF();
9D0008E0  3C02BF80   LUI V0, -16512
9D0008E4  8C425460   LW V0, 21600(V0)
9D0008E8  304200FF   ANDI V0, V0, 255
9D0008EC  A3828014   SB V0, -32748(GP)
244:                             /* Start a 'STOP' cycle                                           */
245:                             I2CStop(I2C_PORT);
9D0008F0  24040001   ADDIU A0, ZERO, 1
9D0008F4  0F4017F4   JAL I2CStop
9D0008F8  00000000   NOP
246:                             MasterI2CPort.status.flags.I2C_error = TRUE;
9D0008FC  3C03A000   LUI V1, -24576
9D000900  8C6203E4   LW V0, 996(V1)
9D000904  24040001   ADDIU A0, ZERO, 1
9D000908  7C823184   INS V0, A0, 6, 1
9D00090C  AC6203E4   SW V0, 996(V1)
247:                             /* set a flag for debugging                                       */
248:                             MasterI2CPort.status.flags.I2C_error_default_state = TRUE;
9D000910  3C03A000   LUI V1, -24576
9D000914  8C6203E4   LW V0, 996(V1)
9D000918  24040001   ADDIU A0, ZERO, 1
9D00091C  7C824204   INS V0, A0, 8, 1
9D000920  AC6203E4   SW V0, 996(V1)
249:                             MasterI2CPort.state = MI2CINT_STOP;
9D000924  3C02A000   LUI V0, -24576
9D000928  244203E4   ADDIU V0, V0, 996
9D00092C  24030008   ADDIU V1, ZERO, 8
9D000930  AC430014   SW V1, 20(V0)
250:                             break;
9D000934  00000000   NOP
251:                         }
252:                     }
253:                 }
9D000938  03C0E821   ADDU SP, S8, ZERO
9D00093C  8FA20064   LW V0, 100(SP)
9D000940  00400013   MTLO V0, 0
9D000944  8FA30060   LW V1, 96(SP)
9D000948  00600011   MTHI V1, 0
9D00094C  8FBF005C   LW RA, 92(SP)
9D000950  8FBE0058   LW S8, 88(SP)
9D000954  8FB90054   LW T9, 84(SP)
9D000958  8FB80050   LW T8, 80(SP)
9D00095C  8FAF004C   LW T7, 76(SP)
9D000960  8FAE0048   LW T6, 72(SP)
9D000964  8FAD0044   LW T5, 68(SP)
9D000968  8FAC0040   LW T4, 64(SP)
9D00096C  8FAB003C   LW T3, 60(SP)
9D000970  8FAA0038   LW T2, 56(SP)
9D000974  8FA90034   LW T1, 52(SP)
9D000978  8FA80030   LW T0, 48(SP)
9D00097C  8FA7002C   LW A3, 44(SP)
9D000980  8FA60028   LW A2, 40(SP)
9D000984  8FA50024   LW A1, 36(SP)
9D000988  8FA40020   LW A0, 32(SP)
9D00098C  8FA3001C   LW V1, 28(SP)
9D000990  8FA20018   LW V0, 24(SP)
9D000994  8FA10014   LW AT, 20(SP)
9D000998  41606000   DI ZERO
9D00099C  000000C0   EHB
9D0009A0  8FBA0074   LW K0, 116(SP)
9D0009A4  8FBB0070   LW K1, 112(SP)
9D0009A8  409A7000   MTC0 K0, EPC
9D0009AC  8FBA006C   LW K0, 108(SP)
9D0009B0  27BD0078   ADDIU SP, SP, 120
9D0009B4  409A6002   MTC0 K0, SRSCtl
9D0009B8  41DDE800   WRPGPR SP, SP
9D0009BC  409B6000   MTC0 K1, Status
9D0009C0  42000018   ERET
254:                 
255:                 /******************************************************************************/
256:                 /* BOOL MasterI2CQueueCommand(I2CBUS_COMMAND_TYPE *command)                   */
257:                 /* kicks off an I2C transaction as specified by the *command structure        */
258:                 /******************************************************************************/
259:                 
260:                 BOOL MasterI2CQueueCommand(I2CBUS_COMMAND_TYPE *command)
261:                 {
9D0009C4  27BDFFE8   ADDIU SP, SP, -24
9D0009C8  AFBF0014   SW RA, 20(SP)
9D0009CC  AFBE0010   SW S8, 16(SP)
9D0009D0  03A0F021   ADDU S8, SP, ZERO
9D0009D4  AFC40018   SW A0, 24(S8)
262:                     if(!MasterI2CPort.status.flags.I2C_busy)
9D0009D8  3C02A000   LUI V0, -24576
9D0009DC  8C4203E4   LW V0, 996(V0)
9D0009E0  30420008   ANDI V0, V0, 8
9D0009E4  14400075   BNE V0, ZERO, 0x9D000BBC
9D0009E8  00000000   NOP
263:                     {
264:                         /* this port is not already doing something                           */
265:                         /* just in case, disable interrupts                                   */
266:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D0009EC  2404003D   ADDIU A0, ZERO, 61
9D0009F0  00002821   ADDU A1, ZERO, ZERO
9D0009F4  0F4016DD   JAL INTEnable
9D0009F8  00000000   NOP
267:                         #ifdef I2C_USE_TIMEOUT
268:                             mMasterI2CTimeoutStopTimer();
9D0009FC  3C03BF80   LUI V1, -16512
9D000A00  8C620E00   LW V0, 3584(V1)
9D000A04  7C027BC4   INS V0, ZERO, 15, 1
9D000A08  AC620E00   SW V0, 3584(V1)
269:                             INTEnable(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER),INT_DISABLED);
9D000A0C  2404000C   ADDIU A0, ZERO, 12
9D000A10  00002821   ADDU A1, ZERO, ZERO
9D000A14  0F4016DD   JAL INTEnable
9D000A18  00000000   NOP
270:                         #endif
271:                         /* clear out the status                                               */
272:                         MasterI2CPort.status.all = 0;
9D000A1C  3C02A000   LUI V0, -24576
9D000A20  AC4003E4   SW ZERO, 996(V0)
273:                         /* copy the relevant portions to the port's status register           */
274:                         MasterI2CPort.status.flags.I2C_action_complete = FALSE;
9D000A24  3C03A000   LUI V1, -24576
9D000A28  8C6203E4   LW V0, 996(V1)
9D000A2C  7C025284   INS V0, ZERO, 10, 1
9D000A30  AC6203E4   SW V0, 996(V1)
275:                         MasterI2CPort.status.flags.I2C_busy = TRUE;
9D000A34  3C03A000   LUI V1, -24576
9D000A38  8C6203E4   LW V0, 996(V1)
9D000A3C  24040001   ADDIU A0, ZERO, 1
9D000A40  7C8218C4   INS V0, A0, 3, 1
9D000A44  AC6203E4   SW V0, 996(V1)
276:                         MasterI2CPort.status.flags.I2C_receive = command->status.flags.I2C_receive;
9D000A48  8FC20018   LW V0, 24(S8)
9D000A4C  8C420000   LW V0, 0(V0)
9D000A50  7C420000   EXT V0, V0, 0, 1
9D000A54  304400FF   ANDI A0, V0, 255
9D000A58  3C03A000   LUI V1, -24576
9D000A5C  8C6203E4   LW V0, 996(V1)
9D000A60  7C820004   INS V0, A0, 0, 1
9D000A64  AC6203E4   SW V0, 996(V1)
277:                         MasterI2CPort.status.flags.I2C_write = command->status.flags.I2C_write;
9D000A68  8FC20018   LW V0, 24(S8)
9D000A6C  8C420000   LW V0, 0(V0)
9D000A70  7C420040   EXT V0, V0, 1, 1
9D000A74  304400FF   ANDI A0, V0, 255
9D000A78  3C03A000   LUI V1, -24576
9D000A7C  8C6203E4   LW V0, 996(V1)
9D000A80  7C820844   INS V0, A0, 1, 1
9D000A84  AC6203E4   SW V0, 996(V1)
278:                         MasterI2CPort.status.flags.I2C_read = command->status.flags.I2C_read;
9D000A88  8FC20018   LW V0, 24(S8)
9D000A8C  8C420000   LW V0, 0(V0)
9D000A90  7C420080   EXT V0, V0, 2, 1
9D000A94  304400FF   ANDI A0, V0, 255
9D000A98  3C03A000   LUI V1, -24576
9D000A9C  8C6203E4   LW V0, 996(V1)
9D000AA0  7C821084   INS V0, A0, 2, 1
9D000AA4  AC6203E4   SW V0, 996(V1)
279:                         MasterI2CPort.target_address = command->target_address;
9D000AA8  8FC20018   LW V0, 24(S8)
9D000AAC  90430004   LBU V1, 4(V0)
9D000AB0  3C02A000   LUI V0, -24576
9D000AB4  244203E4   ADDIU V0, V0, 996
9D000AB8  A0430005   SB V1, 5(V0)
280:                         MasterI2CPort.DataSize = command->DataSize;
9D000ABC  8FC20018   LW V0, 24(S8)
9D000AC0  90430019   LBU V1, 25(V0)
9D000AC4  3C02A000   LUI V0, -24576
9D000AC8  244203E4   ADDIU V0, V0, 996
9D000ACC  A0430010   SB V1, 16(V0)
281:                         MasterI2CPort.WordSize = command->WordSize;
9D000AD0  8FC20018   LW V0, 24(S8)
9D000AD4  9043001A   LBU V1, 26(V0)
9D000AD8  3C02A000   LUI V0, -24576
9D000ADC  244203E4   ADDIU V0, V0, 996
9D000AE0  A0430011   SB V1, 17(V0)
282:                         MasterI2CPort.Word = command->Word; /* just make these pointers to the  */
9D000AE4  8FC20018   LW V0, 24(S8)
9D000AE8  24430005   ADDIU V1, V0, 5
9D000AEC  3C02A000   LUI V0, -24576
9D000AF0  244203E4   ADDIU V0, V0, 996
9D000AF4  AC430008   SW V1, 8(V0)
283:                         MasterI2CPort.Data = command->Data; /* data in the structure that was   */
9D000AF8  8FC20018   LW V0, 24(S8)
9D000AFC  2443000F   ADDIU V1, V0, 15
9D000B00  3C02A000   LUI V0, -24576
9D000B04  244203E4   ADDIU V0, V0, 996
9D000B08  AC43000C   SW V1, 12(V0)
284:                         /* sent here                        */
285:                         MasterI2CPort.data_index = 0;
9D000B0C  3C02A000   LUI V0, -24576
9D000B10  244203E4   ADDIU V0, V0, 996
9D000B14  A0400004   SB ZERO, 4(V0)
286:                         #ifdef I2C_USE_TIMEOUT
287:                             mMasterI2CTimeoutClearTimer();
9D000B18  3C03BF80   LUI V1, -16512
9D000B1C  8C620E00   LW V0, 3584(V1)
9D000B20  7C027BC4   INS V0, ZERO, 15, 1
9D000B24  AC620E00   SW V0, 3584(V1)
9D000B28  3C02BF80   LUI V0, -16512
9D000B2C  AC400E10   SW ZERO, 3600(V0)
9D000B30  3C03BF80   LUI V1, -16512
9D000B34  8C620E00   LW V0, 3584(V1)
9D000B38  24040001   ADDIU A0, ZERO, 1
9D000B3C  7C827BC4   INS V0, A0, 15, 1
9D000B40  AC620E00   SW V0, 3584(V1)
288:                             mMasterI2CTimeoutStartTimer();
9D000B44  3C03BF80   LUI V1, -16512
9D000B48  8C620E00   LW V0, 3584(V1)
9D000B4C  24040001   ADDIU A0, ZERO, 1
9D000B50  7C827BC4   INS V0, A0, 15, 1
9D000B54  AC620E00   SW V0, 3584(V1)
289:                             INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D000B58  2404000C   ADDIU A0, ZERO, 12
9D000B5C  0F4017B8   JAL INTClearFlag
9D000B60  00000000   NOP
290:                             //mMasterI2CTimeoutClearInterruptFlag();
291:                             //mMasterI2CTimeoutEnableInterrupt();
292:                             INTEnable(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER),INT_ENABLED);
9D000B64  2404000C   ADDIU A0, ZERO, 12
9D000B68  24050001   ADDIU A1, ZERO, 1
9D000B6C  0F4016DD   JAL INTEnable
9D000B70  00000000   NOP
293:                         #endif
294:                 
295:                         INTClearFlag(INT_SOURCE_I2C_MASTER(I2C_PORT));
9D000B74  2404003D   ADDIU A0, ZERO, 61
9D000B78  0F4017B8   JAL INTClearFlag
9D000B7C  00000000   NOP
296:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_ENABLED);
9D000B80  2404003D   ADDIU A0, ZERO, 61
9D000B84  24050001   ADDIU A1, ZERO, 1
9D000B88  0F4016DD   JAL INTEnable
9D000B8C  00000000   NOP
297:                         if (I2CBusIsIdle(I2C_PORT))
9D000B90  24040001   ADDIU A0, ZERO, 1
9D000B94  0F4016C8   JAL I2CBusIsIdle
9D000B98  00000000   NOP
9D000B9C  10400007   BEQ V0, ZERO, 0x9D000BBC
9D000BA0  00000000   NOP
298:                         {
299:                             I2CStart(I2C_PORT);
9D000BA4  24040001   ADDIU A0, ZERO, 1
9D000BA8  0F40177D   JAL I2CStart
9D000BAC  00000000   NOP
300:                             return SUCCESS;
9D000BB0  24020001   ADDIU V0, ZERO, 1
9D000BB4  0B4002F0   J 0x9D000BC0
9D000BB8  00000000   NOP
301:                         }
302:                     }
303:                     return FAIL;
9D000BBC  00001021   ADDU V0, ZERO, ZERO
304:                 }
9D000BC0  03C0E821   ADDU SP, S8, ZERO
9D000BC4  8FBF0014   LW RA, 20(SP)
9D000BC8  8FBE0010   LW S8, 16(SP)
9D000BCC  27BD0018   ADDIU SP, SP, 24
9D000BD0  03E00008   JR RA
9D000BD4  00000000   NOP
305:                 
306:                 /******************************************************************************/
307:                 /* BOOL MasterI2CUpdateQueuedCommand(I2CBUS_COMMAND_TYPE *command)            */
308:                 /* if the I2C transaction is complete, copies the status and the size of the  */
309:                 /* data read into the *command structure. The *command structure was already  */
310:                 /* where the interrupt had written the data to.                               */
311:                 /******************************************************************************/
312:                 
313:                 BOOL MasterI2CUpdateQueuedCommand(I2CBUS_COMMAND_TYPE *command)
314:                 {
9D000BD8  27BDFFF8   ADDIU SP, SP, -8
9D000BDC  AFBE0004   SW S8, 4(SP)
9D000BE0  03A0F021   ADDU S8, SP, ZERO
9D000BE4  AFC40008   SW A0, 8(S8)
315:                     if(MasterI2CPort.status.flags.I2C_action_complete)
9D000BE8  3C02A000   LUI V0, -24576
9D000BEC  8C4203E4   LW V0, 996(V0)
9D000BF0  30420400   ANDI V0, V0, 1024
9D000BF4  10400019   BEQ V0, ZERO, 0x9D000C5C
9D000BF8  00000000   NOP
316:                     {
317:                         /* just in case */
318:                         #ifdef I2C_USE_TIMEOUT
319:                         mMasterI2CTimeoutStopTimer();
9D000BFC  3C03BF80   LUI V1, -16512
9D000C00  8C620E00   LW V0, 3584(V1)
9D000C04  7C027BC4   INS V0, ZERO, 15, 1
9D000C08  AC620E00   SW V0, 3584(V1)
320:                         #endif
321:                         command->status=MasterI2CPort.status;
9D000C0C  8FC20008   LW V0, 8(S8)
9D000C10  3C03A000   LUI V1, -24576
9D000C14  8C6303E4   LW V1, 996(V1)
9D000C18  AC430000   SW V1, 0(V0)
322:                         command->DataSize=MasterI2CPort.data_index;
9D000C1C  3C02A000   LUI V0, -24576
9D000C20  244203E4   ADDIU V0, V0, 996
9D000C24  90430004   LBU V1, 4(V0)
9D000C28  8FC20008   LW V0, 8(S8)
9D000C2C  A0430019   SB V1, 25(V0)
323:                         if(MasterI2CPort.status.flags.I2C_error)
9D000C30  3C02A000   LUI V0, -24576
9D000C34  8C4203E4   LW V0, 996(V0)
9D000C38  30420040   ANDI V0, V0, 64
9D000C3C  10400004   BEQ V0, ZERO, 0x9D000C50
9D000C40  00000000   NOP
324:                         {
325:                             return FAIL;
9D000C44  00001021   ADDU V0, ZERO, ZERO
9D000C48  0B400318   J 0x9D000C60
9D000C4C  00000000   NOP
326:                         }
327:                         else
328:                         {
329:                             return SUCCESS;
9D000C50  24020001   ADDIU V0, ZERO, 1
9D000C54  0B400318   J 0x9D000C60
9D000C58  00000000   NOP
330:                         }
331:                     }
332:                     else
333:                     {
334:                         return FAIL;  /* this port has not gone through a full I2C transaction*/
9D000C5C  00001021   ADDU V0, ZERO, ZERO
335:                                       /* cycle                                                */
336:                     }
337:                 }
9D000C60  03C0E821   ADDU SP, S8, ZERO
9D000C64  8FBE0004   LW S8, 4(SP)
9D000C68  27BD0008   ADDIU SP, SP, 8
9D000C6C  03E00008   JR RA
9D000C70  00000000   NOP
338:                 
339:                 #ifdef I2C_PARANOID_INIT
340:                 /******************************************************************************/
341:                 /* void I2CInitCommand(I2CBUS_COMMAND_TYPE *command)                          */
342:                 /* initializes and clears out the I2C command structure passed by *command    */
343:                 /* could be simplified, but is useful to clear out the structure in the       */
344:                 /* development process to be absolutely sure of what data is being written    */
345:                 /* into the structure by the I2C engine                                       */
346:                 /******************************************************************************/
347:                 
348:                 void I2CInitCommand(I2CBUS_COMMAND_TYPE *command)
349:                 {
350:                     int index;
351:                     command->status.all=0;
352:                     for(index=0;index<I2CBUS_WORD_LENGTH;index++)
353:                     {
354:                         command->Word[index]=0;
355:                     }
356:                     for(index=0;index<I2CBUS_DATA_LENGTH;index++)
357:                     {
358:                         command->Data[index]=0;
359:                     }
360:                     command->DataSize=0;
361:                     command->WordSize=0;
362:                     command->target_address=0;
363:                 }
364:                 #endif
365:                 /******************************************************************************/
366:                 /* BOOL MasterI2CStartup(BOOL repairIO)                                       */
367:                 /* configures I2C port and timeout timer. if repairIO is TRUE, check to see   */
368:                 /* if the I2C pins are high- if they are not, attempt to fix it. Returns      */
369:                 /* FALSE if there was a recovery attempt that was unsuccessful                */
370:                 /******************************************************************************/
371:                 
372:                 BOOL MasterI2CStartup(void)
373:                 {
9D000C74  27BDFFE8   ADDIU SP, SP, -24
9D000C78  AFBF0014   SW RA, 20(SP)
9D000C7C  AFBE0010   SW S8, 16(SP)
9D000C80  03A0F021   ADDU S8, SP, ZERO
374:                     I2CEnable(I2C_PORT,FALSE);
9D000C84  24040001   ADDIU A0, ZERO, 1
9D000C88  00002821   ADDU A1, ZERO, ZERO
9D000C8C  0F4017EA   JAL I2CEnable
9D000C90  00000000   NOP
375:                     //I2C2CONbits.ON=FALSE;
376:                     INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000C94  2404003D   ADDIU A0, ZERO, 61
9D000C98  00002821   ADDU A1, ZERO, ZERO
9D000C9C  0F4016DD   JAL INTEnable
9D000CA0  00000000   NOP
377:                     if(!MasterI2CIOCheck())
9D000CA4  0F40036F   JAL MasterI2CIOCheck
9D000CA8  00000000   NOP
9D000CAC  14400004   BNE V0, ZERO, 0x9D000CC0
9D000CB0  00000000   NOP
378:                     {
379:                         return FALSE;
9D000CB4  00001021   ADDU V0, ZERO, ZERO
9D000CB8  0B400369   J 0x9D000DA4
9D000CBC  00000000   NOP
380:                     }
381:                     MasterI2CPort.status.all=0;
9D000CC0  3C02A000   LUI V0, -24576
9D000CC4  AC4003E4   SW ZERO, 996(V0)
382:                     #ifdef I2C_USE_TIMEOUT
383:                     OpenTimer5(
9D000CC8  3C02BF80   LUI V0, -16512
9D000CCC  24030070   ADDIU V1, ZERO, 112
9D000CD0  AC430E00   SW V1, 3584(V0)
9D000CD4  3C02BF80   LUI V0, -16512
9D000CD8  AC400E10   SW ZERO, 3600(V0)
9D000CDC  3C02BF80   LUI V0, -16512
9D000CE0  24033888   ADDIU V1, ZERO, 14472
9D000CE4  AC430E20   SW V1, 3616(V0)
9D000CE8  3C02BF80   LUI V0, -16512
9D000CEC  AC400E08   SW ZERO, 3592(V0)
384:                         T5_OFF|
385:                         T5_IDLE_CON|
386:                         T5_GATE_OFF|
387:                         I2C_TIMEOUT_PRESCALER|
388:                         T5_SOURCE_INT,
389:                         I2C_TIMEOUT_INTERVAL);
390:                     INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D000CF0  2404000C   ADDIU A0, ZERO, 12
9D000CF4  0F4017B8   JAL INTClearFlag
9D000CF8  00000000   NOP
391:                     INTSetVectorPriority(INT_VECTOR_TIMER(I2C_TIMEOUT_TIMER),I2C_TIMEOUT_TIMER_INT_PRIORITY);
9D000CFC  2404000C   ADDIU A0, ZERO, 12
9D000D00  24050004   ADDIU A1, ZERO, 4
9D000D04  0F401753   JAL INTSetVectorPriority
9D000D08  00000000   NOP
392:                     INTSetVectorSubPriority(INT_VECTOR_I2C(I2C_TIMEOUT_TIMER),I2C_TIMEOUT_TIMER_INT_SUB_PRIORITY);
9D000D0C  24040025   ADDIU A0, ZERO, 37
9D000D10  24050001   ADDIU A1, ZERO, 1
9D000D14  0F401761   JAL INTSetVectorSubPriority
9D000D18  00000000   NOP
393:                     INTEnable(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER),INT_DISABLED);
9D000D1C  2404000C   ADDIU A0, ZERO, 12
9D000D20  00002821   ADDU A1, ZERO, ZERO
9D000D24  0F4016DD   JAL INTEnable
9D000D28  00000000   NOP
394:                     //SetPriorityIntT5(T5_INT_OFF|TIMEOUT_INT_PRIORITY|T5_INT_SUB_PRIOR_1);
395:                     #endif
396:                     MasterI2CPort.state=MI2CINT_START;
9D000D2C  3C02A000   LUI V0, -24576
9D000D30  244203E4   ADDIU V0, V0, 996
9D000D34  AC400014   SW ZERO, 20(V0)
397:                     //I2C2CON=0; /* clear to a known state */
398:                     //DelayMs(10);
399:                     //I2C2BRG=BRG_VAL;
400:                     //I2C2STAT=0;
401:                     //I2C2CONbits.SIDL=TRUE;   /* stop when in idle mode */
402:                     //I2C2CONbits.SCLREL=TRUE; /* SCL release (doesn't really matter as master) */
403:                     //I2C2CONbits.STRICT=FALSE;/* do not strictly interpret I2C addresses*/
404:                     //I2C2CONbits.A10M=FALSE;  /* use 7 bit addressing */
405:                     //I2C2CONbits.DISSLW=TRUE; /* disable slew rate control */
406:                     //I2C2CONbits.SMEN=FALSE;  /* do not use SMBUS levels */
407:                     I2CConfigure(I2C_PORT,0);
9D000D38  24040001   ADDIU A0, ZERO, 1
9D000D3C  00002821   ADDU A1, ZERO, ZERO
9D000D40  0F4017FD   JAL I2CConfigure
9D000D44  00000000   NOP
408:                     I2CSetFrequency(I2C_PORT, GetPeripheralClock(), Fsck);
9D000D48  24040001   ADDIU A0, ZERO, 1
9D000D4C  3C0204C4   LUI V0, 1220
9D000D50  3445B400   ORI A1, V0, -19456
9D000D54  3C020001   LUI V0, 1
9D000D58  344686A0   ORI A2, V0, -31072
9D000D5C  0F401704   JAL I2CSetFrequency
9D000D60  00000000   NOP
409:                     I2CEnable(I2C_PORT, TRUE);
9D000D64  24040001   ADDIU A0, ZERO, 1
9D000D68  24050001   ADDIU A1, ZERO, 1
9D000D6C  0F4017EA   JAL I2CEnable
9D000D70  00000000   NOP
410:                     //I2C2CONbits.ON=TRUE;     /* turn I2C module on */
411:                     INTClearFlag(INT_SOURCE_I2C_MASTER(I2C_PORT));
9D000D74  2404003D   ADDIU A0, ZERO, 61
9D000D78  0F4017B8   JAL INTClearFlag
9D000D7C  00000000   NOP
412:                     INTSetVectorPriority(INT_VECTOR_I2C(I2C_PORT),MI2C_INT_PRIORITY);
9D000D80  24040022   ADDIU A0, ZERO, 34
9D000D84  24050006   ADDIU A1, ZERO, 6
9D000D88  0F401753   JAL INTSetVectorPriority
9D000D8C  00000000   NOP
413:                     INTSetVectorSubPriority(INT_VECTOR_I2C(I2C_PORT),MI2C_INT_SUB_PRIORITY);
9D000D90  24040022   ADDIU A0, ZERO, 34
9D000D94  24050001   ADDIU A1, ZERO, 1
9D000D98  0F401761   JAL INTSetVectorSubPriority
9D000D9C  00000000   NOP
414:                     //SetPriorityIntI2C2(I2C_INT_OFF|MI2C_INT_PRIORITY|I2C_INT_SUB_PRI_1);
415:                     return TRUE;
9D000DA0  24020001   ADDIU V0, ZERO, 1
416:                 }
9D000DA4  03C0E821   ADDU SP, S8, ZERO
9D000DA8  8FBF0014   LW RA, 20(SP)
9D000DAC  8FBE0010   LW S8, 16(SP)
9D000DB0  27BD0018   ADDIU SP, SP, 24
9D000DB4  03E00008   JR RA
9D000DB8  00000000   NOP
417:                 
418:                 /******************************************************************************/
419:                 /* MasterI2CIOCheck()                                                         */
420:                 /******************************************************************************/
421:                 
422:                 BOOL MasterI2CIOCheck(void)
423:                 {
9D000DBC  27BDFFE0   ADDIU SP, SP, -32
9D000DC0  AFBF001C   SW RA, 28(SP)
9D000DC4  AFBE0018   SW S8, 24(SP)
9D000DC8  03A0F021   ADDU S8, SP, ZERO
424:                     BOOL returnValue=FALSE;
9D000DCC  AFC00010   SW ZERO, 16(S8)
425:                     /* make sure I2C port is off */
426:                     I2CEnable(I2C_PORT,FALSE);
9D000DD0  24040001   ADDIU A0, ZERO, 1
9D000DD4  00002821   ADDU A1, ZERO, ZERO
9D000DD8  0F4017EA   JAL I2CEnable
9D000DDC  00000000   NOP
427:                     //I2C2CONbits.ON=FALSE;
428:                     I2C2_SCL_DIRECTION=TRIS_IN;
9D000DE0  3C03BF88   LUI V1, -16504
9D000DE4  8C626000   LW V0, 24576(V1)
9D000DE8  24040001   ADDIU A0, ZERO, 1
9D000DEC  7C821084   INS V0, A0, 2, 1
9D000DF0  AC626000   SW V0, 24576(V1)
429:                     I2C2_SDA_DIRECTION=TRIS_IN;
9D000DF4  3C03BF88   LUI V1, -16504
9D000DF8  8C626000   LW V0, 24576(V1)
9D000DFC  24040001   ADDIU A0, ZERO, 1
9D000E00  7C8218C4   INS V0, A0, 3, 1
9D000E04  AC626000   SW V0, 24576(V1)
430:                     /* wait a little while */
431:                     DelayMs(10);
9D000E08  2404000A   ADDIU A0, ZERO, 10
9D000E0C  0F4015E6   JAL DelayMs
9D000E10  00000000   NOP
432:                     returnValue=((I2C2_SCL_IN==1)&&(I2C2_SDA_IN==1));
9D000E14  3C02BF88   LUI V0, -16504
9D000E18  8C426010   LW V0, 24592(V0)
9D000E1C  30420004   ANDI V0, V0, 4
9D000E20  10400009   BEQ V0, ZERO, 0x9D000E48
9D000E24  00000000   NOP
9D000E28  3C02BF88   LUI V0, -16504
9D000E2C  8C426010   LW V0, 24592(V0)
9D000E30  30420008   ANDI V0, V0, 8
9D000E34  10400004   BEQ V0, ZERO, 0x9D000E48
9D000E38  00000000   NOP
9D000E3C  24020001   ADDIU V0, ZERO, 1
9D000E40  0B400393   J 0x9D000E4C
9D000E44  00000000   NOP
9D000E48  00001021   ADDU V0, ZERO, ZERO
9D000E4C  AFC20010   SW V0, 16(S8)
433:                     return returnValue;
9D000E50  8FC20010   LW V0, 16(S8)
434:                 }
9D000E54  03C0E821   ADDU SP, S8, ZERO
9D000E58  8FBF001C   LW RA, 28(SP)
9D000E5C  8FBE0018   LW S8, 24(SP)
9D000E60  27BD0020   ADDIU SP, SP, 32
9D000E64  03E00008   JR RA
9D000E68  00000000   NOP
435:                 
436:                 /******************************************************************************/
437:                 /* accessor function for I2C_busy                                             */
438:                 /*   attempting to be interrupt safe                                          */
439:                 /******************************************************************************/
440:                 
441:                 inline BOOL MasterI2CIsBusy(void)
442:                 {
9D000E6C  27BDFFE0   ADDIU SP, SP, -32
9D000E70  AFBF001C   SW RA, 28(SP)
9D000E74  AFBE0018   SW S8, 24(SP)
9D000E78  03A0F021   ADDU S8, SP, ZERO
443:                     BOOL returnValue;
444:                     if(INTGetEnable(INT_SOURCE_I2C_MASTER(I2C_PORT)))
9D000E7C  2404003D   ADDIU A0, ZERO, 61
9D000E80  0F4017D6   JAL INTGetEnable
9D000E84  00000000   NOP
9D000E88  10400010   BEQ V0, ZERO, 0x9D000ECC
9D000E8C  00000000   NOP
445:                     {
446:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000E90  2404003D   ADDIU A0, ZERO, 61
9D000E94  00002821   ADDU A1, ZERO, ZERO
9D000E98  0F4016DD   JAL INTEnable
9D000E9C  00000000   NOP
447:                         returnValue=MasterI2CPort.status.flags.I2C_busy;
9D000EA0  3C02A000   LUI V0, -24576
9D000EA4  8C4203E4   LW V0, 996(V0)
9D000EA8  7C4200C0   EXT V0, V0, 3, 1
9D000EAC  304200FF   ANDI V0, V0, 255
9D000EB0  AFC20010   SW V0, 16(S8)
448:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_ENABLED);
9D000EB4  2404003D   ADDIU A0, ZERO, 61
9D000EB8  24050001   ADDIU A1, ZERO, 1
9D000EBC  0F4016DD   JAL INTEnable
9D000EC0  00000000   NOP
9D000EC4  0B4003B8   J 0x9D000EE0
9D000EC8  00000000   NOP
449:                     }
450:                     else
451:                     {
452:                         returnValue=MasterI2CPort.status.flags.I2C_busy;
9D000ECC  3C02A000   LUI V0, -24576
9D000ED0  8C4203E4   LW V0, 996(V0)
9D000ED4  7C4200C0   EXT V0, V0, 3, 1
9D000ED8  304200FF   ANDI V0, V0, 255
9D000EDC  AFC20010   SW V0, 16(S8)
453:                     }
454:                     return returnValue;
9D000EE0  8FC20010   LW V0, 16(S8)
455:                 }
9D000EE4  03C0E821   ADDU SP, S8, ZERO
9D000EE8  8FBF001C   LW RA, 28(SP)
9D000EEC  8FBE0018   LW S8, 24(SP)
9D000EF0  27BD0020   ADDIU SP, SP, 32
9D000EF4  03E00008   JR RA
9D000EF8  00000000   NOP
456:                 
457:                 /******************************************************************************/
458:                 /* accessor function for I2C_action_complete                                  */
459:                 /******************************************************************************/
460:                 
461:                 inline BOOL MasterI2CIsQueuedCommandDone(void)
462:                 {
9D000EFC  27BDFFE0   ADDIU SP, SP, -32
9D000F00  AFBF001C   SW RA, 28(SP)
9D000F04  AFBE0018   SW S8, 24(SP)
9D000F08  03A0F021   ADDU S8, SP, ZERO
463:                     BOOL returnValue;
464:                     if(INTGetEnable(INT_SOURCE_I2C_MASTER(I2C_PORT)))
9D000F0C  2404003D   ADDIU A0, ZERO, 61
9D000F10  0F4017D6   JAL INTGetEnable
9D000F14  00000000   NOP
9D000F18  10400010   BEQ V0, ZERO, 0x9D000F5C
9D000F1C  00000000   NOP
465:                     {
466:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000F20  2404003D   ADDIU A0, ZERO, 61
9D000F24  00002821   ADDU A1, ZERO, ZERO
9D000F28  0F4016DD   JAL INTEnable
9D000F2C  00000000   NOP
467:                         returnValue=MasterI2CPort.status.flags.I2C_action_complete;
9D000F30  3C02A000   LUI V0, -24576
9D000F34  8C4203E4   LW V0, 996(V0)
9D000F38  7C420280   EXT V0, V0, 10, 1
9D000F3C  304200FF   ANDI V0, V0, 255
9D000F40  AFC20010   SW V0, 16(S8)
468:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_ENABLED);
9D000F44  2404003D   ADDIU A0, ZERO, 61
9D000F48  24050001   ADDIU A1, ZERO, 1
9D000F4C  0F4016DD   JAL INTEnable
9D000F50  00000000   NOP
9D000F54  0B4003DC   J 0x9D000F70
9D000F58  00000000   NOP
469:                     }
470:                     else
471:                     {
472:                         returnValue = MasterI2CPort.status.flags.I2C_action_complete;
9D000F5C  3C02A000   LUI V0, -24576
9D000F60  8C4203E4   LW V0, 996(V0)
9D000F64  7C420280   EXT V0, V0, 10, 1
9D000F68  304200FF   ANDI V0, V0, 255
9D000F6C  AFC20010   SW V0, 16(S8)
473:                     }
474:                     return returnValue;
9D000F70  8FC20010   LW V0, 16(S8)
475:                 }
9D000F74  03C0E821   ADDU SP, S8, ZERO
9D000F78  8FBF001C   LW RA, 28(SP)
9D000F7C  8FBE0018   LW S8, 24(SP)
9D000F80  27BD0020   ADDIU SP, SP, 32
9D000F84  03E00008   JR RA
9D000F88  00000000   NOP
476:                 
477:                 BOOL MasterI2CReadByte(UINT8 address, UINT8 toReadRegister, UINT8 *dataRead)
478:                 {
9D000F8C  27BDFFC8   ADDIU SP, SP, -56
9D000F90  AFBF0034   SW RA, 52(SP)
9D000F94  AFBE0030   SW S8, 48(SP)
9D000F98  03A0F021   ADDU S8, SP, ZERO
9D000F9C  00801821   ADDU V1, A0, ZERO
9D000FA0  00A01021   ADDU V0, A1, ZERO
9D000FA4  AFC60040   SW A2, 64(S8)
9D000FA8  A3C30038   SB V1, 56(S8)
9D000FAC  A3C2003C   SB V0, 60(S8)
479:                     I2CBUS_COMMAND_TYPE RI2CCommand;
480:                     #ifdef I2C_PARANOID_INIT
481:                         I2CInitCommand(&RI2CCommand);
482:                     #else
483:                         RI2CCommand.status.all=0;
9D000FB0  AFC00010   SW ZERO, 16(S8)
484:                     #endif
485:                     RI2CCommand.status.flags.I2C_read=TRUE;
9D000FB4  8FC20010   LW V0, 16(S8)
9D000FB8  24030001   ADDIU V1, ZERO, 1
9D000FBC  7C621084   INS V0, V1, 2, 1
9D000FC0  AFC20010   SW V0, 16(S8)
486:                     RI2CCommand.target_address=address;
9D000FC4  93C20038   LBU V0, 56(S8)
9D000FC8  A3C20014   SB V0, 20(S8)
487:                     RI2CCommand.Word[0]=toReadRegister;
9D000FCC  93C2003C   LBU V0, 60(S8)
9D000FD0  A3C20015   SB V0, 21(S8)
488:                     RI2CCommand.WordSize=1;
9D000FD4  24020001   ADDIU V0, ZERO, 1
9D000FD8  A3C2002A   SB V0, 42(S8)
489:                     RI2CCommand.DataSize=1;
9D000FDC  24020001   ADDIU V0, ZERO, 1
9D000FE0  A3C20029   SB V0, 41(S8)
490:                     if(MasterI2CQueueCommand(&RI2CCommand))
9D000FE4  27C20010   ADDIU V0, S8, 16
9D000FE8  00402021   ADDU A0, V0, ZERO
9D000FEC  0F400271   JAL MasterI2CQueueCommand
9D000FF0  00000000   NOP
9D000FF4  10400016   BEQ V0, ZERO, 0x9D001050
9D000FF8  00000000   NOP
491:                     {
492:                         while (MasterI2CIsBusy());
9D000FFC  00000000   NOP
9D001000  0F40039B   JAL MasterI2CIsBusy
9D001004  00000000   NOP
9D001008  1440FFFD   BNE V0, ZERO, 0x9D001000
9D00100C  00000000   NOP
493:                         if (MasterI2CUpdateQueuedCommand(&RI2CCommand))
9D001010  27C20010   ADDIU V0, S8, 16
9D001014  00402021   ADDU A0, V0, ZERO
9D001018  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D00101C  00000000   NOP
9D001020  1040000B   BEQ V0, ZERO, 0x9D001050
9D001024  00000000   NOP
494:                         {
495:                             /* was there an error? */
496:                             if (!RI2CCommand.status.flags.I2C_error)
9D001028  8FC20010   LW V0, 16(S8)
9D00102C  30420040   ANDI V0, V0, 64
9D001030  14400007   BNE V0, ZERO, 0x9D001050
9D001034  00000000   NOP
497:                             {
498:                                 *dataRead = RI2CCommand.Data[0];
9D001038  93C3001F   LBU V1, 31(S8)
9D00103C  8FC20040   LW V0, 64(S8)
9D001040  A0430000   SB V1, 0(V0)
499:                                 return TRUE;
9D001044  24020001   ADDIU V0, ZERO, 1
9D001048  0B400415   J 0x9D001054
9D00104C  00000000   NOP
500:                             }
501:                         }
502:                     }
503:                     return FALSE;
9D001050  00001021   ADDU V0, ZERO, ZERO
504:                 }
9D001054  03C0E821   ADDU SP, S8, ZERO
9D001058  8FBF0034   LW RA, 52(SP)
9D00105C  8FBE0030   LW S8, 48(SP)
9D001060  27BD0038   ADDIU SP, SP, 56
9D001064  03E00008   JR RA
9D001068  00000000   NOP
505:                 
506:                 BOOL MasterI2CReadWord(UINT8 address, UINT8 toReadRegister, UINT16 *dataRead)
507:                 {
9D00106C  27BDFFC8   ADDIU SP, SP, -56
9D001070  AFBF0034   SW RA, 52(SP)
9D001074  AFBE0030   SW S8, 48(SP)
9D001078  03A0F021   ADDU S8, SP, ZERO
9D00107C  00801821   ADDU V1, A0, ZERO
9D001080  00A01021   ADDU V0, A1, ZERO
9D001084  AFC60040   SW A2, 64(S8)
9D001088  A3C30038   SB V1, 56(S8)
9D00108C  A3C2003C   SB V0, 60(S8)
508:                     I2CBUS_COMMAND_TYPE RI2CCommand;
509:                     UINT16_VAL tempDataRead;
510:                     #ifdef I2C_PARANOID_INIT
511:                         I2CInitCommand(&RI2CCommand);
512:                     #else
513:                         RI2CCommand.status.all=0;
9D001090  AFC00010   SW ZERO, 16(S8)
514:                     #endif
515:                     RI2CCommand.status.flags.I2C_read=TRUE;
9D001094  8FC20010   LW V0, 16(S8)
9D001098  24030001   ADDIU V1, ZERO, 1
9D00109C  7C621084   INS V0, V1, 2, 1
9D0010A0  AFC20010   SW V0, 16(S8)
516:                     RI2CCommand.target_address=address;
9D0010A4  93C20038   LBU V0, 56(S8)
9D0010A8  A3C20014   SB V0, 20(S8)
517:                     RI2CCommand.Word[0]=toReadRegister;
9D0010AC  93C2003C   LBU V0, 60(S8)
9D0010B0  A3C20015   SB V0, 21(S8)
518:                     RI2CCommand.WordSize=1;
9D0010B4  24020001   ADDIU V0, ZERO, 1
9D0010B8  A3C2002A   SB V0, 42(S8)
519:                     RI2CCommand.DataSize=2;
9D0010BC  24020002   ADDIU V0, ZERO, 2
9D0010C0  A3C20029   SB V0, 41(S8)
520:                     if(MasterI2CQueueCommand(&RI2CCommand))
9D0010C4  27C20010   ADDIU V0, S8, 16
9D0010C8  00402021   ADDU A0, V0, ZERO
9D0010CC  0F400271   JAL MasterI2CQueueCommand
9D0010D0  00000000   NOP
9D0010D4  1040001A   BEQ V0, ZERO, 0x9D001140
9D0010D8  00000000   NOP
521:                     {
522:                         while(MasterI2CIsBusy());
9D0010DC  00000000   NOP
9D0010E0  0F40039B   JAL MasterI2CIsBusy
9D0010E4  00000000   NOP
9D0010E8  1440FFFD   BNE V0, ZERO, 0x9D0010E0
9D0010EC  00000000   NOP
523:                         if(MasterI2CUpdateQueuedCommand(&RI2CCommand))
9D0010F0  27C20010   ADDIU V0, S8, 16
9D0010F4  00402021   ADDU A0, V0, ZERO
9D0010F8  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D0010FC  00000000   NOP
9D001100  1040000F   BEQ V0, ZERO, 0x9D001140
9D001104  00000000   NOP
524:                         {
525:                             /* was there an error? */
526:                             if(!RI2CCommand.status.flags.I2C_error)
9D001108  8FC20010   LW V0, 16(S8)
9D00110C  30420040   ANDI V0, V0, 64
9D001110  1440000B   BNE V0, ZERO, 0x9D001140
9D001114  00000000   NOP
527:                             {
528:                                 tempDataRead.byte.LB=RI2CCommand.Data[0];
9D001118  93C2001F   LBU V0, 31(S8)
9D00111C  A3C2002C   SB V0, 44(S8)
529:                                 tempDataRead.byte.HB=RI2CCommand.Data[1];
9D001120  93C20020   LBU V0, 32(S8)
9D001124  A3C2002D   SB V0, 45(S8)
530:                                 *dataRead=tempDataRead.Val;
9D001128  97C3002C   LHU V1, 44(S8)
9D00112C  8FC20040   LW V0, 64(S8)
9D001130  A4430000   SH V1, 0(V0)
531:                                 return TRUE;
9D001134  24020001   ADDIU V0, ZERO, 1
9D001138  0B400451   J 0x9D001144
9D00113C  00000000   NOP
532:                             }
533:                         }
534:                     }
535:                     return FALSE;
9D001140  00001021   ADDU V0, ZERO, ZERO
536:                 }
9D001144  03C0E821   ADDU SP, S8, ZERO
9D001148  8FBF0034   LW RA, 52(SP)
9D00114C  8FBE0030   LW S8, 48(SP)
9D001150  27BD0038   ADDIU SP, SP, 56
9D001154  03E00008   JR RA
9D001158  00000000   NOP
537:                 
538:                 BOOL  MasterI2CWriteVerifyByteNoRetry(UINT8 address, UINT8 toWriteRegister, UINT8 toWriteData)
539:                 {
9D00115C  27BDFFC8   ADDIU SP, SP, -56
9D001160  AFBF0034   SW RA, 52(SP)
9D001164  AFBE0030   SW S8, 48(SP)
9D001168  03A0F021   ADDU S8, SP, ZERO
9D00116C  00A01821   ADDU V1, A1, ZERO
9D001170  00C01021   ADDU V0, A2, ZERO
9D001174  A3C40038   SB A0, 56(S8)
9D001178  A3C3003C   SB V1, 60(S8)
9D00117C  A3C20040   SB V0, 64(S8)
540:                     I2CBUS_COMMAND_TYPE WVI2CCommand;
541:                     UINT8 dataRead;
542:                     #ifdef I2C_PARANOID_INIT
543:                         I2CInitCommand(&WVI2CCommand);
544:                     #else
545:                         WVI2CCommand.status.all=0;
9D001180  AFC00010   SW ZERO, 16(S8)
546:                     #endif
547:                     WVI2CCommand.status.flags.I2C_write=TRUE;
9D001184  8FC20010   LW V0, 16(S8)
9D001188  24030001   ADDIU V1, ZERO, 1
9D00118C  7C620844   INS V0, V1, 1, 1
9D001190  AFC20010   SW V0, 16(S8)
548:                     WVI2CCommand.target_address=address;
9D001194  93C20038   LBU V0, 56(S8)
9D001198  A3C20014   SB V0, 20(S8)
549:                     WVI2CCommand.Word[0]=toWriteRegister;
9D00119C  93C2003C   LBU V0, 60(S8)
9D0011A0  A3C20015   SB V0, 21(S8)
550:                     WVI2CCommand.Word[1]=toWriteData;
9D0011A4  93C20040   LBU V0, 64(S8)
9D0011A8  A3C20016   SB V0, 22(S8)
551:                     WVI2CCommand.WordSize=2;
9D0011AC  24020002   ADDIU V0, ZERO, 2
9D0011B0  A3C2002A   SB V0, 42(S8)
552:                     if(MasterI2CQueueCommand(&WVI2CCommand))
9D0011B4  27C20010   ADDIU V0, S8, 16
9D0011B8  00402021   ADDU A0, V0, ZERO
9D0011BC  0F400271   JAL MasterI2CQueueCommand
9D0011C0  00000000   NOP
9D0011C4  10400020   BEQ V0, ZERO, 0x9D001248
9D0011C8  00000000   NOP
553:                     {
554:                         /* wait for the transaction to be done */
555:                         while(MasterI2CIsBusy());
9D0011CC  00000000   NOP
9D0011D0  0F40039B   JAL MasterI2CIsBusy
9D0011D4  00000000   NOP
9D0011D8  1440FFFD   BNE V0, ZERO, 0x9D0011D0
9D0011DC  00000000   NOP
556:                         if(MasterI2CUpdateQueuedCommand(&WVI2CCommand))
9D0011E0  27C20010   ADDIU V0, S8, 16
9D0011E4  00402021   ADDU A0, V0, ZERO
9D0011E8  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D0011EC  00000000   NOP
9D0011F0  10400015   BEQ V0, ZERO, 0x9D001248
9D0011F4  00000000   NOP
557:                         {
558:                             /* was there an error? */
559:                             if(!WVI2CCommand.status.flags.I2C_error)
9D0011F8  8FC20010   LW V0, 16(S8)
9D0011FC  30420040   ANDI V0, V0, 64
9D001200  14400011   BNE V0, ZERO, 0x9D001248
9D001204  00000000   NOP
560:                             {
561:                                 /* no error, now verify */
562:                                 if(MasterI2CReadByte(address,toWriteRegister,&dataRead))
9D001208  93C40038   LBU A0, 56(S8)
9D00120C  93C3003C   LBU V1, 60(S8)
9D001210  27C2002C   ADDIU V0, S8, 44
9D001214  00602821   ADDU A1, V1, ZERO
9D001218  00403021   ADDU A2, V0, ZERO
9D00121C  0F4003E3   JAL MasterI2CReadByte
9D001220  00000000   NOP
9D001224  10400008   BEQ V0, ZERO, 0x9D001248
9D001228  00000000   NOP
563:                                 {
564:                                     if(dataRead==toWriteData)
9D00122C  93C2002C   LBU V0, 44(S8)
9D001230  93C30040   LBU V1, 64(S8)
9D001234  14620004   BNE V1, V0, 0x9D001248
9D001238  00000000   NOP
565:                                     {
566:                                         return TRUE;
9D00123C  24020001   ADDIU V0, ZERO, 1
9D001240  0B400493   J 0x9D00124C
9D001244  00000000   NOP
567:                                     }
568:                                 }
569:                             }
570:                         }
571:                     }
572:                     return FALSE;
9D001248  00001021   ADDU V0, ZERO, ZERO
573:                 }
9D00124C  03C0E821   ADDU SP, S8, ZERO
9D001250  8FBF0034   LW RA, 52(SP)
9D001254  8FBE0030   LW S8, 48(SP)
9D001258  27BD0038   ADDIU SP, SP, 56
9D00125C  03E00008   JR RA
9D001260  00000000   NOP
574:                 
575:                 BOOL  MasterI2CWriteVerifyWordNoRetry(UINT8 address, UINT8 toWriteRegister, UINT16 toWriteData)
576:                 {
9D001264  27BDFFC8   ADDIU SP, SP, -56
9D001268  AFBF0034   SW RA, 52(SP)
9D00126C  AFBE0030   SW S8, 48(SP)
9D001270  03A0F021   ADDU S8, SP, ZERO
9D001274  00A01821   ADDU V1, A1, ZERO
9D001278  00C01021   ADDU V0, A2, ZERO
9D00127C  A3C40038   SB A0, 56(S8)
9D001280  A3C3003C   SB V1, 60(S8)
9D001284  A7C20040   SH V0, 64(S8)
577:                     I2CBUS_COMMAND_TYPE WVI2CCommand;
578:                     UINT16_VAL tempWord;
579:                     tempWord.Val=toWriteData;
9D001288  97C20040   LHU V0, 64(S8)
9D00128C  A7C2002C   SH V0, 44(S8)
580:                     #ifdef I2C_PARANOID_INIT
581:                         I2CInitCommand(&WVI2CCommand);
582:                     #else
583:                         WVI2CCommand.status.all=0;
9D001290  AFC00010   SW ZERO, 16(S8)
584:                     #endif
585:                     WVI2CCommand.status.flags.I2C_write=TRUE;
9D001294  8FC20010   LW V0, 16(S8)
9D001298  24030001   ADDIU V1, ZERO, 1
9D00129C  7C620844   INS V0, V1, 1, 1
9D0012A0  AFC20010   SW V0, 16(S8)
586:                     WVI2CCommand.target_address=address;
9D0012A4  93C20038   LBU V0, 56(S8)
9D0012A8  A3C20014   SB V0, 20(S8)
587:                     WVI2CCommand.Word[0]=toWriteRegister;
9D0012AC  93C2003C   LBU V0, 60(S8)
9D0012B0  A3C20015   SB V0, 21(S8)
588:                     WVI2CCommand.Word[1]=tempWord.byte.LB;
9D0012B4  93C2002C   LBU V0, 44(S8)
9D0012B8  A3C20016   SB V0, 22(S8)
589:                     WVI2CCommand.Word[2]=tempWord.byte.HB;
9D0012BC  93C2002D   LBU V0, 45(S8)
9D0012C0  A3C20017   SB V0, 23(S8)
590:                     WVI2CCommand.WordSize=3;
9D0012C4  24020003   ADDIU V0, ZERO, 3
9D0012C8  A3C2002A   SB V0, 42(S8)
591:                     if(MasterI2CQueueCommand(&WVI2CCommand))
9D0012CC  27C20010   ADDIU V0, S8, 16
9D0012D0  00402021   ADDU A0, V0, ZERO
9D0012D4  0F400271   JAL MasterI2CQueueCommand
9D0012D8  00000000   NOP
9D0012DC  10400020   BEQ V0, ZERO, 0x9D001360
9D0012E0  00000000   NOP
592:                     {
593:                         /* wait for the transaction to be done */
594:                         while(MasterI2CIsBusy());
9D0012E4  00000000   NOP
9D0012E8  0F40039B   JAL MasterI2CIsBusy
9D0012EC  00000000   NOP
9D0012F0  1440FFFD   BNE V0, ZERO, 0x9D0012E8
9D0012F4  00000000   NOP
595:                         if(MasterI2CUpdateQueuedCommand(&WVI2CCommand))
9D0012F8  27C20010   ADDIU V0, S8, 16
9D0012FC  00402021   ADDU A0, V0, ZERO
9D001300  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D001304  00000000   NOP
9D001308  10400015   BEQ V0, ZERO, 0x9D001360
9D00130C  00000000   NOP
596:                         {
597:                             /* was there an error? */
598:                             if(!WVI2CCommand.status.flags.I2C_error)
9D001310  8FC20010   LW V0, 16(S8)
9D001314  30420040   ANDI V0, V0, 64
9D001318  14400011   BNE V0, ZERO, 0x9D001360
9D00131C  00000000   NOP
599:                             {
600:                                 /* no error, now verify */
601:                                 if(MasterI2CReadWord(address,toWriteRegister,&tempWord.Val))
9D001320  93C40038   LBU A0, 56(S8)
9D001324  93C3003C   LBU V1, 60(S8)
9D001328  27C2002C   ADDIU V0, S8, 44
9D00132C  00602821   ADDU A1, V1, ZERO
9D001330  00403021   ADDU A2, V0, ZERO
9D001334  0F40041B   JAL MasterI2CReadWord
9D001338  00000000   NOP
9D00133C  10400008   BEQ V0, ZERO, 0x9D001360
9D001340  00000000   NOP
602:                                 {
603:                                     if(tempWord.Val==toWriteData)
9D001344  97C2002C   LHU V0, 44(S8)
9D001348  97C30040   LHU V1, 64(S8)
9D00134C  14620004   BNE V1, V0, 0x9D001360
9D001350  00000000   NOP
604:                                     {
605:                                         return TRUE;
9D001354  24020001   ADDIU V0, ZERO, 1
9D001358  0B4004D9   J 0x9D001364
9D00135C  00000000   NOP
606:                                     }
607:                                 }
608:                             }
609:                         }
610:                     }
611:                     return FALSE;
9D001360  00001021   ADDU V0, ZERO, ZERO
612:                 }
9D001364  03C0E821   ADDU SP, S8, ZERO
9D001368  8FBF0034   LW RA, 52(SP)
9D00136C  8FBE0030   LW S8, 48(SP)
9D001370  27BD0038   ADDIU SP, SP, 56
9D001374  03E00008   JR RA
9D001378  00000000   NOP
613:                 
614:                 enum MASTER_I2C_OWNER_TYPE currentOwner=NONE;
615:                 
616:                 BOOL MasterI2CClaimPort(enum MASTER_I2C_OWNER_TYPE owner)
617:                 {
9D00137C  27BDFFF0   ADDIU SP, SP, -16
9D001380  AFBE000C   SW S8, 12(SP)
9D001384  03A0F021   ADDU S8, SP, ZERO
9D001388  AFC40010   SW A0, 16(S8)
618:                     BOOL returnValue=FALSE;
9D00138C  AFC00000   SW ZERO, 0(S8)
619:                     if(currentOwner==NONE)
9D001390  8F828010   LW V0, -32752(GP)
9D001394  1440000F   BNE V0, ZERO, 0x9D0013D4
9D001398  00000000   NOP
620:                     {
621:                         switch(owner)
9D00139C  8FC20010   LW V0, 16(S8)
9D0013A0  2442FFFF   ADDIU V0, V0, -1
9D0013A4  2C420002   SLTIU V0, V0, 2
9D0013A8  10400007   BEQ V0, ZERO, 0x9D0013C8
9D0013AC  00000000   NOP
622:                         {
623:                             case DIGIPOT:
624:                             case POWER_MONITOR:
625:                             {
626:                                 currentOwner = owner;
9D0013B0  8FC20010   LW V0, 16(S8)
9D0013B4  AF828010   SW V0, -32752(GP)
627:                                 returnValue = TRUE;
9D0013B8  24020001   ADDIU V0, ZERO, 1
9D0013BC  AFC20000   SW V0, 0(S8)
628:                                 break;
9D0013C0  0B4004F5   J 0x9D0013D4
9D0013C4  00000000   NOP
629:                             }
630:                             case NONE:
631:                             default:
632:                             {
633:                                 returnValue = TRUE;
9D0013C8  24020001   ADDIU V0, ZERO, 1
9D0013CC  AFC20000   SW V0, 0(S8)
634:                                 break;
9D0013D0  00000000   NOP
635:                             }
636:                         }
637:                     }
638:                     return returnValue;
9D0013D4  8FC20000   LW V0, 0(S8)
639:                 }
9D0013D8  03C0E821   ADDU SP, S8, ZERO
9D0013DC  8FBE000C   LW S8, 12(SP)
9D0013E0  27BD0010   ADDIU SP, SP, 16
9D0013E4  03E00008   JR RA
9D0013E8  00000000   NOP
640:                 
641:                 void MasterI2CReleasePort(void)
642:                 {
9D0013EC  27BDFFF8   ADDIU SP, SP, -8
9D0013F0  AFBE0004   SW S8, 4(SP)
9D0013F4  03A0F021   ADDU S8, SP, ZERO
643:                     /* maybe check to see if the Master I2C is busy? */
644:                     currentOwner=NONE;
9D0013F8  AF808010   SW ZERO, -32752(GP)
645:                 }
9D0013FC  03C0E821   ADDU SP, S8, ZERO
9D001400  8FBE0004   LW S8, 4(SP)
9D001404  27BD0008   ADDIU SP, SP, 8
9D001408  03E00008   JR RA
9D00140C  00000000   NOP
646:                 
647:                 BOOL MasterI2CAvailable(void)
648:                 {
9D001410  27BDFFF0   ADDIU SP, SP, -16
9D001414  AFBE000C   SW S8, 12(SP)
9D001418  03A0F021   ADDU S8, SP, ZERO
649:                     BOOL returnValue=FALSE;
9D00141C  AFC00000   SW ZERO, 0(S8)
650:                     if(currentOwner==NONE)
9D001420  8F828010   LW V0, -32752(GP)
9D001424  14400003   BNE V0, ZERO, 0x9D001434
9D001428  00000000   NOP
651:                     {
652:                         returnValue=TRUE;
9D00142C  24020001   ADDIU V0, ZERO, 1
9D001430  AFC20000   SW V0, 0(S8)
653:                     }
654:                     return returnValue;
9D001434  8FC20000   LW V0, 0(S8)
655:                 }
9D001438  03C0E821   ADDU SP, S8, ZERO
9D00143C  8FBE000C   LW S8, 12(SP)
9D001440  27BD0010   ADDIU SP, SP, 16
9D001444  03E00008   JR RA
9D001448  00000000   NOP
656:                 
657:                 BOOL MasterI2CHasPort(enum MASTER_I2C_OWNER_TYPE owner)
658:                 {
9D00144C  27BDFFF8   ADDIU SP, SP, -8
9D001450  AFBE0004   SW S8, 4(SP)
9D001454  03A0F021   ADDU S8, SP, ZERO
9D001458  AFC40008   SW A0, 8(S8)
659:                     if(owner==currentOwner)
9D00145C  8F828010   LW V0, -32752(GP)
9D001460  8FC30008   LW V1, 8(S8)
9D001464  14620004   BNE V1, V0, 0x9D001478
9D001468  00000000   NOP
660:                     {
661:                         return TRUE;
9D00146C  24020001   ADDIU V0, ZERO, 1
9D001470  0B40051F   J 0x9D00147C
9D001474  00000000   NOP
662:                     }
663:                     return FALSE;
9D001478  00001021   ADDU V0, ZERO, ZERO
664:                 }
9D00147C  03C0E821   ADDU SP, S8, ZERO
9D001480  8FBE0004   LW S8, 4(SP)
9D001484  27BD0008   ADDIU SP, SP, 8
9D001488  03E00008   JR RA
9D00148C  00000000   NOP
