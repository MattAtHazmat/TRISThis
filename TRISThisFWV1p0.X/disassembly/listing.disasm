Disassembly Listing for TRISThisFWV1p0
Generated From:
/home/matt/Projects/TRISThis/TRISThisFWV1p0.X/dist/default/production/TRISThisFWV1p0.X.production.elf
Oct 3, 2013 5:59:12 PM

---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/system.h  -------------------------------------
1:                   /********************************************************************
2:                   
3:                   	System Library Interface Definition
4:                   	
5:                   	Summary:
6:                   		This file contains the interface definition for the System
7:                   		peripheral library.
8:                   		
9:                   	Description:
10:                  		This library provides functions for configuring the peripheral
11:                  		clock, cache settings, and wait states.  For details on the
12:                  		register and bit settings used by these functions, refer to the
13:                  		PIC32 Family Reference Manual.
14:                  
15:                  
16:                   ********************************************************************/
17:                  //DOM-IGNORE-BEGIN
18:                  /********************************************************************
19:                   * FileName:		System.h
20:                   * Dependencies:
21:                   * Processor:		PIC32
22:                   * Hardware:		N/A
23:                   * Assembler:		N/A
24:                   * Linker:		    N/A
25:                   * Company:		    Microchip Technology Inc.
26:                   *
27:                   * Software License Agreement:
28:                   * The software supplied herewith by Microchip Technology Incorporated
29:                   * (the Company) for its PICmicro® Microcontroller is intended and
30:                   * supplied to you, the Companys customer, for use solely and
31:                   * exclusively on Microchip PICmicro Microcontroller products. The
32:                   * software is owned by the Company and/or its supplier, and is
33:                   * protected under applicable copyright laws. All rights are reserved.
34:                   * Any use in violation of the foregoing restrictions may subject the
35:                   * user to criminal sanctions under applicable laws, as well as to
36:                   * civil liability for the breach of the terms and conditions of this
37:                   * license.
38:                   *
39:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
40:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
41:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
42:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
43:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
44:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
45:                   *
46:                   * $Id: CoreTimer.h,v 1.2 2006/11/03 15:07:21 C12923 Exp $
47:                   * $Name:  $
48:                   ********************************************************************/
49:                  //DOM-IGNORE-END
50:                   
51:                   
52:                  #ifndef _SYSTEM_HEADER_FILE
53:                  #define _SYSTEM_HEADER_FILE
54:                  
55:                  #include <xc.h>
56:                  #include <peripheral/int.h>
57:                  #include <peripheral/pcache.h>
58:                  #include <peripheral/osc.h>
59:                  #include <peripheral/dma.h>
60:                  #include <peripheral/bmx.h>
61:                  #include <peripheral/lock.h>
62:                  #ifdef __cplusplus
63:                  extern "C"
64:                    {
65:                  #endif
66:                  #define FLASH_SPEED_HZ          30000000 //Max Flash speed
67:                  #define PB_BUS_MAX_FREQ_HZ      80000000 //Max Peripheral bus speed
68:                  
69:                  /*********************************************************************
70:                   * SYSTEMConfig Flags
71:                   *********************************************************************/
72:                  #define SYS_CFG_WAIT_STATES     0x00000001 //SYSTEMConfig wait states
73:                  #define SYS_CFG_PB_BUS          0x00000002 //SYSTEMConfig pb bus
74:                  #define SYS_CFG_PCACHE          0x00000004 //SYSTEMConfig cache
75:                  #define SYS_CFG_ALL             0xFFFFFFFF //SYSTEMConfig All
76:                  
77:                  /*********************************************************************
78:                   Function:       
79:                  	unsigned int SYSTEMConfigPB(unsigned int sys_clock)
80:                   
81:                   Description:
82:                  	The function sets the PB divider to the optimum value.
83:                   
84:                   PreCondition:    
85:                  	None
86:                   
87:                   Parameters:           
88:                  	sys_clock - system clock in Hz
89:                   
90:                   Returns:          
91:                  	the PB clock frequency in Hz
92:                   
93:                   Side Effects:
94:                  	The PB clock may be changed
95:                  	
96:                   Overview:	    
97:                  	The function sets the PB divider to the optimum value.
98:                   
99:                   Remarks:            
100:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
101:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
102:                  
103:                  Example:
104:                 	<code>
105:                 	SYSTEMConfigPB(72000000);
106:                 	</code>
107:                  ********************************************************************/
108:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPB(unsigned int sys_clock)
109:                 {
110:                     unsigned int pb_div;
111:                     unsigned int pb_clock;
112:                 
113:                     pb_clock = sys_clock;
9D0048DC  8FC20028   LW V0, 40(S8)
9D0048E0  AFC2002C   SW V0, 44(S8)
114:                 
115:                     if(sys_clock > PB_BUS_MAX_FREQ_HZ)
9D0048E4  8FC30028   LW V1, 40(S8)
9D0048E8  3C0204C4   LUI V0, 1220
9D0048EC  3442B401   ORI V0, V0, -19455
9D0048F0  0062102B   SLTU V0, V1, V0
9D0048F4  14400008   BNE V0, ZERO, 0x9D004918
9D0048F8  00000000   NOP
116:                     {
117:                         pb_div=OSC_PB_DIV_2;
9D0048FC  3C020008   LUI V0, 8
9D004900  AFC20030   SW V0, 48(S8)
118:                         pb_clock >>= 1;
9D004904  8FC2002C   LW V0, 44(S8)
9D004908  00021042   SRL V0, V0, 1
9D00490C  AFC2002C   SW V0, 44(S8)
9D004910  0B401247   J 0x9D00491C
9D004914  00000000   NOP
119:                     }
120:                     else
121:                     {
122:                         pb_div=OSC_PB_DIV_1;
9D004918  AFC00030   SW ZERO, 48(S8)
9D00491C  8FC20030   LW V0, 48(S8)
9D004920  AFC20034   SW V0, 52(S8)
123:                     }
124:                 
125:                     OSCSetPBDIV(pb_div);
126:                 
127:                     return pb_clock;
128:                 }
129:                 
130:                 
131:                 /*********************************************************************
132:                   Function:        
133:                 	void SYSTEMConfigWaitStates(unsigned int sys_clock)
134:                  
135:                   Description:
136:                 	The function sets the Flash Wait states to the optimum value.
137:                  
138:                   PreCondition:    
139:                 	None
140:                  
141:                   Parameters:           
142:                 	sys_clock - system clock in Hz
143:                  
144:                   Returns:          
145:                 	None
146:                  
147:                   Side Effects:    
148:                 	The Wait States may be changed  
149:                  
150:                   Remarks:         
151:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
152:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
153:                  
154:                   Example:
155:                 	<code>
156:                 	SYSTEMConfigWaitStates(72000000);
157:                 	</code>
158:                  ********************************************************************/
159:                 extern inline void __attribute__((always_inline)) SYSTEMConfigWaitStates(unsigned int sys_clock)
160:                 {
161:                 #ifdef _PCACHE
162:                     unsigned int wait_states;
163:                     unsigned int int_status;
164:                 #endif
165:                 
166:                 #ifdef _PCACHE
167:                     wait_states = 0;
9D00485C  AFC00020   SW ZERO, 32(S8)
9D004860  0B401222   J 0x9D004888
9D004864  00000000   NOP
168:                 
169:                     while(sys_clock > FLASH_SPEED_HZ)
9D004888  8FC3001C   LW V1, 28(S8)
9D00488C  3C0201C9   LUI V0, 457
9D004890  3442C381   ORI V0, V0, -15487
9D004894  0062102B   SLTU V0, V1, V0
9D004898  1040FFF3   BEQ V0, ZERO, 0x9D004868
9D00489C  00000000   NOP
170:                     {
171:                         wait_states++;
9D004868  8FC20020   LW V0, 32(S8)
9D00486C  24420001   ADDIU V0, V0, 1
9D004870  AFC20020   SW V0, 32(S8)
172:                         sys_clock -= FLASH_SPEED_HZ;
9D004874  8FC3001C   LW V1, 28(S8)
9D004878  3C02FE36   LUI V0, -458
9D00487C  34423C80   ORI V0, V0, 15488
9D004880  00621021   ADDU V0, V1, V0
9D004884  AFC2001C   SW V0, 28(S8)
173:                     }
174:                 
175:                     int_status=INTDisableInterrupts();
9D0048A0  0F40182E   JAL INTDisableInterrupts
9D0048A4  00000000   NOP
9D0048A8  AFC20024   SW V0, 36(S8)
176:                     mCheConfigure(wait_states);
9D0048AC  3C02BF88   LUI V0, -16504
9D0048B0  8FC30020   LW V1, 32(S8)
9D0048B4  AC434000   SW V1, 16384(V0)
177:                     INTRestoreInterrupts(int_status);
9D0048B8  8FC40024   LW A0, 36(S8)
9D0048BC  0F401804   JAL INTRestoreInterrupts
9D0048C0  00000000   NOP
178:                 
179:                 #endif
180:                 }
181:                 
182:                 /*********************************************************************
183:                   Function:        
184:                 		unsigned int SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
185:                   
186:                   Description:
187:                 	The function sets the PB divider and the Flash Wait states to the optimum value.
188:                  
189:                   PreCondition:    
190:                 	None
191:                  
192:                   Parameters:           
193:                 	sys_clock - system clock in Hz
194:                  
195:                   Returns:          
196:                 	the PB clock frequency in Hz
197:                  
198:                   Side Effects:    
199:                 	The PB clock and wait states may be changed
200:                 
201:                   Remarks:            
202:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
203:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
204:                  
205:                   Example:
206:                 	<code>
207:                 	SYSTEMConfigWaitStatesAndPB(72000000);
208:                 	</code>
209:                  ********************************************************************/
210:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigWaitStatesAndPB(unsigned int sys_clock)
211:                 {
212:                 #ifdef _PCACHE
213:                     unsigned int wait_states;
214:                 #endif
215:                     unsigned int pb_clock;
216:                     unsigned int int_status;
217:                 
218:                     pb_clock = SYSTEMConfigPB(sys_clock);
219:                 
220:                 
221:                     // set the flash wait states based on 1 wait state
222:                     // for every 20 MHz
223:                 #ifdef _PCACHE
224:                     wait_states = 0;
225:                 
226:                     while(sys_clock > FLASH_SPEED_HZ)
227:                     {
228:                         wait_states++;
229:                         sys_clock -= FLASH_SPEED_HZ;
230:                     }
231:                 
232:                     int_status=INTDisableInterrupts();
233:                     mCheConfigure(wait_states);
234:                     INTRestoreInterrupts(int_status);
235:                 
236:                 #endif
237:                 
238:                     return pb_clock;
239:                 }
240:                 /*********************************************************************
241:                   Function:       
242:                 	unsigned int SYSTEMConfigPerformance(unsigned int sys_clock)
243:                  
244:                   Description:
245:                 	The function sets the PB divider, the Flash Wait states and the DRM wait states to the optimum value.
246:                     It also enables the cacheability for the K0 segment.
247:                 	
248:                   PreCondition:    
249:                 	None
250:                  
251:                   Parameters:           
252:                 	sys_clock - system clock in Hz
253:                  
254:                   Output:          
255:                 	the PB clock frequency in Hz
256:                  
257:                   Side Effects:    
258:                 	Sets the PB and Flash Wait states
259:                  	
260:                   Remarks:            
261:                 	The interrupts are disabled briefly, the DMA is suspended and the system is unlocked while performing the operation.
262:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
263:                  
264:                   Example:
265:                 	<code>
266:                 	SYSTEMConfigPerformance(72000000);
267:                 	</code>
268:                  ********************************************************************/
269:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfigPerformance(unsigned int sys_clock)
270:                 {
271:                     // set up the wait states
272:                     unsigned int pb_clk;
273:                 #ifdef _PCACHE
274:                     unsigned int cache_status;
275:                 #endif
276:                     unsigned int int_status;
277:                 
278:                     pb_clk = SYSTEMConfigWaitStatesAndPB(sys_clock);
279:                 
280:                     int_status=INTDisableInterrupts();
281:                 
282:                     mBMXDisableDRMWaitState();
283:                 
284:                 #ifdef _PCACHE
285:                     cache_status = mCheGetCon();
286:                     cache_status |= CHE_CONF_PF_ALL;
287:                     mCheConfigure(cache_status);
288:                     CheKseg0CacheOn();
289:                 #endif
290:                 
291:                     INTRestoreInterrupts(int_status);
292:                 
293:                     return pb_clk;
294:                 
295:                 }
296:                 /*********************************************************************
297:                   Function:       
298:                 	unsigned int SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
299:                  
300:                   Description:
301:                 	The function sets the PB divider, the Flash Wait states or the DRM wait states to the optimum value, 
302:                 	based on the flags selected and on the frequency of the system clock.
303:                     It also enables the cacheability for the K0 segment.
304:                 				   
305:                   PreCondition:    
306:                 	None
307:                  
308:                   Parameters:           
309:                 	sys_clock - system clock frequency in Hz
310:                     flags -
311:                 		*    SYS_CFG_WAIT_STATES  - configure the flash wait states from the system clock
312:                         *    SYS_CFG_PB_BUS       - configure the PB bus from the system clock
313:                         *    SYS_CFG_PCACHE      - configure the pCache (if used)
314:                         *    SYS_CFG_ALL          - configure all based on system clock
315:                  
316:                   Returns:          
317:                 	the PB clock frequency in Hz
318:                  
319:                   Side Effects:    
320:                 	Could change the wait state, pb clock and turn on the pre-fetch buffer and cache. Sets the RAM
321:                     wait state to 0.
322:                   
323:                  
324:                   Remarks:
325:                 	The interrupts are disabled shortly, the DMA is suspended and the system is unlocked while performing the operation.
326:                     Upon return the previous status of the interrupts and the DMA are restored. The system is re-locked.
327:                  
328:                   Example:
329:                 	<code>
330:                 	SYSTEMConfig(72000000, SYS_CFG_ALL);
331:                 	</code>
332:                  ********************************************************************/
333:                 extern inline unsigned int __attribute__((always_inline)) SYSTEMConfig(unsigned int sys_clock, unsigned int flags)
334:                 {
335:                     unsigned int pb_clk;
336:                     unsigned int int_status;
337:                 #ifdef _PCACHE
338:                     unsigned int cache_status;
339:                 #endif
340:                 
341:                     int_status=INTDisableInterrupts();
9D004828  0F40182E   JAL INTDisableInterrupts
9D00482C  00000000   NOP
9D004830  AFC20018   SW V0, 24(S8)
342:                 
343:                     mBMXDisableDRMWaitState();
9D004834  3C02BF88   LUI V0, -16504
9D004838  24030040   ADDIU V1, ZERO, 64
9D00483C  AC432004   SW V1, 8196(V0)
344:                 
345:                     if(flags & SYS_CFG_WAIT_STATES)
9D004840  8FC20014   LW V0, 20(S8)
9D004844  30420001   ANDI V0, V0, 1
9D004848  304200FF   ANDI V0, V0, 255
9D00484C  1040001D   BEQ V0, ZERO, 0x9D0048C4
9D004850  00000000   NOP
9D004854  8FC20010   LW V0, 16(S8)
9D004858  AFC2001C   SW V0, 28(S8)
346:                     {
347:                         SYSTEMConfigWaitStates(sys_clock);
348:                     }
349:                 
350:                     if(flags & SYS_CFG_PB_BUS)
9D0048C4  8FC20014   LW V0, 20(S8)
9D0048C8  30420002   ANDI V0, V0, 2
9D0048CC  10400065   BEQ V0, ZERO, 0x9D004A64
9D0048D0  00000000   NOP
9D0048D4  8FC20010   LW V0, 16(S8)
9D0048D8  AFC20028   SW V0, 40(S8)
351:                     {
352:                         SYSTEMConfigPB(sys_clock);
353:                     }
354:                 
355:                 
356:                 #ifdef _PCACHE
357:                     if(flags & SYS_CFG_PCACHE)
9D004A64  8FC20014   LW V0, 20(S8)
9D004A68  30420004   ANDI V0, V0, 4
9D004A6C  1040000C   BEQ V0, ZERO, 0x9D004AA0
9D004A70  00000000   NOP
358:                     {
359:                         cache_status = mCheGetCon();
9D004A74  3C02BF88   LUI V0, -16504
9D004A78  8C424000   LW V0, 16384(V0)
9D004A7C  AFC2004C   SW V0, 76(S8)
360:                         cache_status |= CHE_CONF_PF_ALL;
9D004A80  8FC2004C   LW V0, 76(S8)
9D004A84  34420030   ORI V0, V0, 48
9D004A88  AFC2004C   SW V0, 76(S8)
361:                         mCheConfigure(cache_status);
9D004A8C  3C02BF88   LUI V0, -16504
9D004A90  8FC3004C   LW V1, 76(S8)
9D004A94  AC434000   SW V1, 16384(V0)
362:                         CheKseg0CacheOn();
9D004A98  0F401811   JAL CheKseg0CacheOn
9D004A9C  00000000   NOP
363:                     }
364:                 #endif
365:                 
366:                     pb_clk = sys_clock;
9D004AA0  8FC20010   LW V0, 16(S8)
9D004AA4  AFC20050   SW V0, 80(S8)
367:                     pb_clk >>= OSCCONbits.PBDIV;
9D004AA8  3C02BF81   LUI V0, -16511
9D004AAC  8C42F000   LW V0, -4096(V0)
9D004AB0  7C420CC0   EXT V0, V0, 19, 2
9D004AB4  304200FF   ANDI V0, V0, 255
9D004AB8  8FC30050   LW V1, 80(S8)
9D004ABC  00431006   SRLV V0, V1, V0
9D004AC0  AFC20050   SW V0, 80(S8)
368:                 
369:                     INTRestoreInterrupts(int_status);
9D004AC4  8FC40018   LW A0, 24(S8)
9D004AC8  0F401804   JAL INTRestoreInterrupts
9D004ACC  00000000   NOP
370:                 
371:                     return pb_clk;
9D004AD0  AFC00054   SW ZERO, 84(S8)
372:                 
373:                 }
374:                 #ifdef __cplusplus
375:                   }
376:                 #endif
377:                 #endif
378:                 
---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/osc.h  ----------------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  OSC API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        OSC.h
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the Company) for its PIC Microcontroller is intended
19:                   * and supplied to you, the Companys customer, for use solely and
20:                   * exclusively on Microchip PIC Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   * $Id: OSC.h,v 1.6 2006/10/13 21:24:31 C12532 Exp $
37:                   * $Name:  $
38:                   ********************************************************************/
39:                  
40:                  #ifndef OSC_H_
41:                  #define OSC_H_
42:                  
43:                  #include <xc.h>
44:                  #include <peripheral/lock.h>
45:                  
46:                  #define _OSC_
47:                  
48:                  /*********************************************************************
49:                   * Function:        OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div)
50:                   *
51:                   * Description:	    Sets Osc options and clock source
52:                   *
53:                   * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
54:                   *
55:                   * Inputs:	    	Clock source, PLL multiplier, PLL postscaler, FRC divisor - see below
56:                   *
57:                   * Output:          None
58:                   *
59:                   * Example:	    	OSCConfig( OSC_POSC, OSC_PLL_MULT_24, OSC_PLL_POST_256, OSC_FRC_POST_64 )
60:                   *
61:                   * Note:	    	Forces cpu clock source to FRC(no divisor, no PLL), configures new clock
62:                   * 		     		source and then switches to the new clock source
63:                   *
64:                   *		    		Unused parameters are set to zero/default values.
65:                   ********************************************************************/
66:                  void OSCConfig(unsigned long int source, unsigned long int mult, unsigned long int post, unsigned long int div);
67:                  
68:                  	/******************************************************************************
69:                  	 * Available options for source parameter
70:                  	 *****************************************************************************/
71:                  		// CPU Oscillator modes - values are mutually exclusive
72:                  		#define OSC_FRC_DIV 	(7 << _OSCCON_NOSC_POSITION)
73:                  		#define OSC_FRC_DIV16 	(6 << _OSCCON_NOSC_POSITION)
74:                  		#define OSC_LPRC        (5 << _OSCCON_NOSC_POSITION)
75:                  		#define OSC_SOSC        (4 << _OSCCON_NOSC_POSITION)
76:                  		#define OSC_POSC_PLL 	(3 << _OSCCON_NOSC_POSITION)
77:                  		#define OSC_POSC        (2 << _OSCCON_NOSC_POSITION)
78:                  		#define OSC_FRC_PLL 	(1 << _OSCCON_NOSC_POSITION)
79:                  		#define OSC_FRC         (0 << _OSCCON_NOSC_POSITION)
80:                  
81:                  	/******************************************************************************
82:                  	 * Available options for mult parameter
83:                  	 *****************************************************************************/
84:                  		// CPU PLL multiplier values - values are mutually exclusive
85:                  		#define OSC_PLL_MULT_24 (7 << _OSCCON_PLLMULT_POSITION)
86:                  		#define OSC_PLL_MULT_21 (6 << _OSCCON_PLLMULT_POSITION)
87:                  		#define OSC_PLL_MULT_20 (5 << _OSCCON_PLLMULT_POSITION)
88:                  		#define OSC_PLL_MULT_19 (4 << _OSCCON_PLLMULT_POSITION)
89:                  		#define OSC_PLL_MULT_18 (3 << _OSCCON_PLLMULT_POSITION)
90:                  		#define OSC_PLL_MULT_17 (2 << _OSCCON_PLLMULT_POSITION)
91:                  		#define OSC_PLL_MULT_16 (1 << _OSCCON_PLLMULT_POSITION)
92:                  		#define OSC_PLL_MULT_15 (0 << _OSCCON_PLLMULT_POSITION)
93:                  
94:                  	/******************************************************************************
95:                  	 * Available options for post parameter
96:                  	 *****************************************************************************/
97:                  		// CPU PLL output divisor values - values are mutuallye exclusive
98:                  		#define OSC_PLL_POST_256 (7 << _OSCCON_PLLODIV_POSITION)
99:                  		#define OSC_PLL_POST_64  (6 << _OSCCON_PLLODIV_POSITION)
100:                 		#define OSC_PLL_POST_32  (5 << _OSCCON_PLLODIV_POSITION)
101:                 		#define OSC_PLL_POST_16  (4 << _OSCCON_PLLODIV_POSITION)
102:                 		#define OSC_PLL_POST_8   (3 << _OSCCON_PLLODIV_POSITION)
103:                 		#define OSC_PLL_POST_4   (2 << _OSCCON_PLLODIV_POSITION)
104:                 		#define OSC_PLL_POST_2   (1 << _OSCCON_PLLODIV_POSITION)
105:                 		#define OSC_PLL_POST_1   (0 << _OSCCON_PLLODIV_POSITION)
106:                 
107:                 	/******************************************************************************
108:                 	 * Available options for div parameter
109:                 	 *****************************************************************************/
110:                 		// CPU FRC output divisor values - values are mutually exclusive
111:                 		#define OSC_FRC_POST_256 (7 << _OSCCON_FRCDIV_POSITION)
112:                 		#define OSC_FRC_POST_64  (6 << _OSCCON_FRCDIV_POSITION)
113:                 		#define OSC_FRC_POST_32  (5 << _OSCCON_FRCDIV_POSITION)
114:                 		#define OSC_FRC_POST_16  (4 << _OSCCON_FRCDIV_POSITION)
115:                 		#define OSC_FRC_POST_8   (3 << _OSCCON_FRCDIV_POSITION)
116:                 		#define OSC_FRC_POST_4   (2 << _OSCCON_FRCDIV_POSITION)
117:                 		#define OSC_FRC_POST_2   (1 << _OSCCON_FRCDIV_POSITION)
118:                 		#define OSC_FRC_POST_1   (0 << _OSCCON_FRCDIV_POSITION)
119:                 	/***********************************
120:                 	 * End parameter values
121:                 	 ************************************/
122:                 
123:                 #if (((__PIC32_FEATURE_SET__ >= 100) && (__PIC32_FEATURE_SET__ <= 299)) || \
124:                     (__PIC32_FEATURE_SET__ == 330) || (__PIC32_FEATURE_SET__ == 350) || (__PIC32_FEATURE_SET__ == 370) || (__PIC32_FEATURE_SET__ == 430) || (__PIC32_FEATURE_SET__ == 450) || (__PIC32_FEATURE_SET__ == 470))
125:                 	
126:                 		// Reference Oscillator Source Select bits - values are mutually exclusive
127:                 	#define OSC_REFOCON_REFCLKI	 	(7 << _REFOCON_ROSEL_POSITION )
128:                 	#define OSC_REFOCON_SYSPLL 		(7 << _REFOCON_ROSEL_POSITION )
129:                 	#define OSC_REFOCON_USBPLL 		(6 << _REFOCON_ROSEL_POSITION )
130:                 	#define OSC_REFOCON_SOSC        (5 << _REFOCON_ROSEL_POSITION )
131:                 	#define OSC_REFOCON_LPRC        (4 << _REFOCON_ROSEL_POSITION )
132:                 	#define OSC_REFOCON_FRC 		(3 << _REFOCON_ROSEL_POSITION )
133:                 	#define OSC_REFOCON_POSC        (2 << _REFOCON_ROSEL_POSITION )
134:                 	#define OSC_REFOCON_PBCLK 		(1 << _REFOCON_ROSEL_POSITION )
135:                 	#define OSC_REFOCON_SYSCLK      (0 << _REFOCON_ROSEL_POSITION )
136:                 		
137:                 	typedef enum
138:                 	{		
139:                 		OSC_REFOCON_RLSPEN		=(1 << _REFOCON_RSLP_POSITION )	,
140:                 		OSC_REFOCON_OE			=(1 << _REFOCON_OE_POSITION ),
141:                 		OSC_REFOCON_SIDLEN		=(1 << _REFOCON_SIDL_POSITION ),
142:                 		OSC_REFOCON_ON			=(1 << _REFOCON_ON_POSITION )
143:                 	} OSCREFConfigFlags;
144:                 	
145:                 	void OSCREFConfig(unsigned long int source, OSCREFConfigFlags config, unsigned long int div);
146:                 	 
147:                 
148:                 	#define mOSCREFOTRIMSet(trim) 		(REFOTRIM = (trim << _REFOTRIM_ROTRIM_POSITION))
149:                 
150:                 #endif
151:                 
152:                 	 
153:                 	 
154:                 	 
155:                 /*********************************************************************
156:                  * Function:    OSCSetPBDIV(unsigned int oscPbDiv)
157:                  *
158:                  * Description:	Configures peripheral bus divisor
159:                  *
160:                  * PreCondition: oscPbDiv one of the OSC_PB_DIV_X valid values
161:                  *
162:                  * Inputs:    oscPbDiv - desired PB divider
163:                  *
164:                  * Output:      None
165:                  *
166:                  * Example:   OSCSetPBDIV(  OSC_PB_DIV_8 )
167:                  *
168:                  ********************************************************************/
169:                 extern inline void __attribute__((always_inline)) OSCSetPBDIV(unsigned int oscPbDiv)
170:                 {
171:                 	unsigned int dma_status;
172:                 	unsigned int int_status;
173:                 	__OSCCONbits_t oscBits;
174:                 
175:                 	mSYSTEMUnlock(int_status, dma_status);
9D004924  0F40182E   JAL INTDisableInterrupts
9D004928  00000000   NOP
9D00492C  AFC20038   SW V0, 56(S8)
9D004974  AFC20040   SW V0, 64(S8)
9D004978  3C02BF81   LUI V0, -16511
9D00497C  AC40F230   SW ZERO, -3536(V0)
9D004980  3C02BF81   LUI V0, -16511
9D004984  3C03AA99   LUI V1, -21863
9D004988  34636655   ORI V1, V1, 26197
9D00498C  AC43F230   SW V1, -3536(V0)
9D004990  3C02BF81   LUI V0, -16511
9D004994  3C035566   LUI V1, 21862
9D004998  346399AA   ORI V1, V1, -26198
9D00499C  AC43F230   SW V1, -3536(V0)
9D004AD4  0F40182E   JAL INTDisableInterrupts
9D004AD8  00000000   NOP
9D004ADC  AFC20058   SW V0, 88(S8)
9D004B24  AFC20060   SW V0, 96(S8)
9D004B28  3C02BF81   LUI V0, -16511
9D004B2C  AC40F230   SW ZERO, -3536(V0)
9D004B30  3C02BF81   LUI V0, -16511
9D004B34  3C03AA99   LUI V1, -21863
9D004B38  34636655   ORI V1, V1, 26197
9D004B3C  AC43F230   SW V1, -3536(V0)
9D004B40  3C02BF81   LUI V0, -16511
9D004B44  3C035566   LUI V1, 21862
9D004B48  346399AA   ORI V1, V1, -26198
9D004B4C  AC43F230   SW V1, -3536(V0)
176:                 	
177:                 	oscBits.w=OSCCON;		// read to be in sync. flush any pending write
9D0049A0  3C02BF81   LUI V0, -16511
9D0049A4  8C42F000   LW V0, -4096(V0)
9D0049A8  AFC20070   SW V0, 112(S8)
9D004B50  3C02BF81   LUI V0, -16511
9D004B54  8C42F000   LW V0, -4096(V0)
9D004B58  AFC2006C   SW V0, 108(S8)
178:                 	oscBits.PBDIV=0;
9D0049AC  8FC20070   LW V0, 112(S8)
9D0049B0  7C02A4C4   INS V0, ZERO, 19, 2
9D0049B4  AFC20070   SW V0, 112(S8)
9D004B5C  8FC2006C   LW V0, 108(S8)
9D004B60  7C02A4C4   INS V0, ZERO, 19, 2
9D004B64  AFC2006C   SW V0, 108(S8)
179:                 	oscBits.w|=oscPbDiv;	
9D0049B8  8FC30070   LW V1, 112(S8)
9D0049BC  8FC20034   LW V0, 52(S8)
9D0049C0  00621025   OR V0, V1, V0
9D0049C4  AFC20070   SW V0, 112(S8)
9D004B68  8FC3006C   LW V1, 108(S8)
9D004B6C  8FC20054   LW V0, 84(S8)
9D004B70  00621025   OR V0, V1, V0
9D004B74  AFC2006C   SW V0, 108(S8)
180:                 	OSCCON=oscBits.w;		// write back
9D0049C8  8FC30070   LW V1, 112(S8)
9D0049CC  3C02BF81   LUI V0, -16511
9D0049D0  AC43F000   SW V1, -4096(V0)
9D004B78  8FC3006C   LW V1, 108(S8)
9D004B7C  3C02BF81   LUI V0, -16511
9D004B80  AC43F000   SW V1, -4096(V0)
181:                 	oscBits.w=OSCCON;		// make sure the write occurred before returning from this function
9D0049D4  3C02BF81   LUI V0, -16511
9D0049D8  8C42F000   LW V0, -4096(V0)
9D0049DC  AFC20070   SW V0, 112(S8)
9D004B84  3C02BF81   LUI V0, -16511
9D004B88  8C42F000   LW V0, -4096(V0)
9D004B8C  AFC2006C   SW V0, 108(S8)
182:                 	
183:                 	mSYSTEMLock(int_status, dma_status);
9D0049E0  3C02BF81   LUI V0, -16511
9D0049E4  3C033333   LUI V1, 13107
9D0049E8  34633333   ORI V1, V1, 13107
9D0049EC  AC43F230   SW V1, -3536(V0)
9D0049F0  8FC20040   LW V0, 64(S8)
9D0049F4  AFC20044   SW V0, 68(S8)
9D004A58  8FC40038   LW A0, 56(S8)
9D004A5C  0F401804   JAL INTRestoreInterrupts
9D004A60  00000000   NOP
9D004B90  3C02BF81   LUI V0, -16511
9D004B94  3C033333   LUI V1, 13107
9D004B98  34633333   ORI V1, V1, 13107
9D004B9C  AC43F230   SW V1, -3536(V0)
9D004BA0  8FC20060   LW V0, 96(S8)
9D004BA4  AFC20064   SW V0, 100(S8)
9D004C08  8FC40058   LW A0, 88(S8)
9D004C0C  0F401804   JAL INTRestoreInterrupts
9D004C10  00000000   NOP
184:                 }
185:                 
186:                 #define		mOSCSetPBDIV		OSCSetPBDIV		// backward compatibility
187:                 
188:                 
189:                 
190:                 	/******************************************************************************
191:                 	 * Available options for config parameter
192:                 	 *****************************************************************************/
193:                 		// CPU Peripheral Bus divisor values - values are mutually exclusive
194:                 		#define OSC_PB_DIV_8    (3 << _OSCCON_PBDIV_POSITION)
195:                 		#define OSC_PB_DIV_4    (2 << _OSCCON_PBDIV_POSITION)
196:                 		#define OSC_PB_DIV_2    (1 << _OSCCON_PBDIV_POSITION)
197:                 		#define OSC_PB_DIV_1    (0 << _OSCCON_PBDIV_POSITION)
198:                 	/***********************************
199:                 	 * End config parameter values
200:                 	 ************************************/
201:                 
202:                 
203:                 /*********************************************************************
204:                  * Function:    mOSCGetPBDIV()
205:                  *
206:                  * Description:	Reads peripheral bus divisor
207:                  *
208:                  * PreCondition:None
209:                  *
210:                  * Inputs:	  	None
211:                  *
212:                  * Output:      None
213:                  *
214:                  * Example:	  	mOSCGetPBDIV()
215:                  *
216:                  ********************************************************************/
217:                 #define mOSCGetPBDIV() (OSCCONbits.PBDIV)
218:                 
219:                 
220:                 /*********************************************************************
221:                  * Function:    mOSCClockFailStatus()
222:                  *
223:                  * Description:	Returns Clock Fail status. 1 = clock fail, 0 = no clock fail
224:                  *
225:                  * PreCondition: None
226:                  *
227:                  * Inputs:	  	None
228:                  *
229:                  * Output:      None
230:                  *
231:                  * Example:	  	mOSCClockFailStatus()
232:                  *
233:                  ********************************************************************/
234:                 #define mOSCClockFailStatus (OSCCONbits.CF)
235:                 
236:                 
237:                 /*********************************************************************
238:                  * Function:      	mOSCEnableSOSC()
239:                  *
240:                  * Description:	  	Enables the LPRC
241:                  *
242:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
243:                  *
244:                  * Inputs:	  		None
245:                  *
246:                  * Output:        	None
247:                  *
248:                  * Example:	  		mOSCEnableSOSC()
249:                  *
250:                  ********************************************************************/
251:                 #define mOSCEnableSOSC() mSysUnlockOpLock(OSCCONSET = _OSCCON_SOSCEN_MASK)
252:                 
253:                 
254:                 /*********************************************************************
255:                  * Function:      	mOSCDisableSOSC(config)
256:                  *
257:                  * Description:	  	Disables SOSC
258:                  *
259:                  * PreCondition:    Interrupts must be disabled and DMA suspended or disabled
260:                  *
261:                  * Inputs:	  		None
262:                  *
263:                  * Output:        	None
264:                  *
265:                  * Example:	  		mOSCDisableSOSC()
266:                  *
267:                  ********************************************************************/
268:                 #define mOSCDisableSOSC() mSysUnlockOpLock(OSCCONCLR = _OSCCON_SOSCEN_MASK)
269:                 
270:                 
271:                 
272:                 #endif
---  /opt/microchip/xc32/v1.21/pic32mx/include/peripheral/dma_5xx_6xx_7xx.h  ----------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  DMA API definitions
4:                    *
5:                    *********************************************************************
6:                    * FileName:        Dma.h
7:                    * Dependencies:	xc.h
8:                    * 					int.h
9:                    *
10:                   * Processor:       PIC32
11:                   *
12:                   * Complier:        MPLAB C32
13:                   *                  MPLAB IDE
14:                   * Company:         Microchip Technology Inc.
15:                   *
16:                   * Software License Agreement
17:                   *
18:                   * The software supplied herewith by Microchip Technology Incorporated
19:                   * (the Company) for its PIC32/PIC24F Microcontroller is intended
20:                   * and supplied to you, the Companys customer, for use solely and
21:                   * exclusively on Microchip PIC32/PIC24F Microcontroller products.
22:                   * The software is owned by the Company and/or its supplier, and is
23:                   * protected under applicable copyright laws. All rights are reserved.
24:                   * Any use in violation of the foregoing restrictions may subject the
25:                   * user to criminal sanctions under applicable laws, as well as to
26:                   * civil liability for the breach of the terms and conditions of this
27:                   * license.
28:                   *
29:                   * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
30:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
31:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
32:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
33:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
34:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
35:                   *
36:                   *
37:                   * $Id: Dma.h,v 1.9 2007/01/17 21:35:46 C12878 Exp $
38:                   * $Name:  $
39:                   *
40:                   ********************************************************************/
41:                  
42:                  #ifndef _DMA_H_
43:                  #define _DMA_H_
44:                  
45:                  #include <xc.h>
46:                  
47:                  
48:                  // DMA definitions
49:                  
50:                  #ifdef _DMAC0
51:                  	#define _DMA_CHANNELS		// DMA channels exist
52:                  
53:                  
54:                  // existent DMA channels
55:                  	typedef enum
56:                  	{
57:                  		DMA_CHANNEL0,
58:                  	#ifdef _DMAC1
59:                  		DMA_CHANNEL1,
60:                  	#ifdef _DMAC2
61:                  		DMA_CHANNEL2,
62:                  	#ifdef _DMAC3
63:                  		DMA_CHANNEL3,
64:                  	#ifdef _DMAC4
65:                  		DMA_CHANNEL4,
66:                  	#ifdef _DMAC5
67:                  		DMA_CHANNEL5,
68:                  	#ifdef _DMAC6
69:                  		DMA_CHANNEL6,
70:                  	#ifdef _DMAC7
71:                  		DMA_CHANNEL7,
72:                  	#endif	// _DMAC7
73:                  	#endif	// _DMAC6
74:                  	#endif	// _DMAC5
75:                  	#endif	// _DMAC4
76:                  	#endif	// _DMAC3
77:                  	#endif	// _DMAC2
78:                  	#endif	// _DMAC1
79:                  		//	add/remove DMA channel as needed here
80:                  
81:                  		DMA_CHANNELS	// number of current available channels
82:                  	}DmaChannel;
83:                  
84:                  
85:                  	// Relative Dma channels priority, between each other
86:                  	typedef enum
87:                  	{
88:                  		DMA_CHN_PRI0,
89:                  		DMA_CHN_PRI1,
90:                  		DMA_CHN_PRI2,
91:                  		DMA_CHN_PRI3
92:                  	}DmaChannelPri;
93:                  
94:                  
95:                  
96:                  	// high level definitions for the API functions
97:                  
98:                  	typedef enum
99:                  	{
100:                 		DMA_OPEN_DEFAULT = 0,							        // DMA default operation
101:                 		DMA_OPEN_AUTO	= _DCH0CON_CHAEN_MASK,					// DMA channel is auto enabled
102:                 		DMA_OPEN_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
103:                 		DMA_OPEN_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),				// DMA channel is chained to higher channel
104:                 		DMA_OPEN_DET_EN = _DCH0CON_CHAED_MASK,					// events detection enabled while channel off
105:                 		DMA_OPEN_ENABLE = _DCH0CON_CHEN_MASK,					// DMA channel is enabled after open
106:                 		DMA_OPEN_MATCH	= 0x80000000,						    // DMA channel stops on match
107:                 	}DmaOpenFlags;	// flags for the channel open
108:                 
109:                 
110:                 	typedef enum
111:                 	{
112:                 		DMA_EV_ERR =			0x1,		// address error event
113:                 		DMA_EV_ABORT = 			0x2,		// transfer abort event
114:                 		DMA_EV_CELL_DONE =		0x4,		// cell transfer complete event
115:                 		DMA_EV_BLOCK_DONE =		0x8,		// block transfer complete event
116:                 		DMA_EV_DST_HALF =		0x10,		// destination half event
117:                 		DMA_EV_DST_FULL =		0x20,		// destination full event
118:                 		DMA_EV_SRC_HALF =		0x40,		// source half event
119:                 		DMA_EV_SRC_FULL =		0x80,		// source full event
120:                 
121:                 		DMA_EV_ALL_EVNTS=		(DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_CELL_DONE|DMA_EV_BLOCK_DONE|DMA_EV_DST_HALF|
122:                 									DMA_EV_DST_FULL|DMA_EV_SRC_HALF|DMA_EV_SRC_FULL)				// all available events
123:                 	}DmaEvFlags;	// flags for controlling the DMA channel events; Bit fields from the processor header file.
124:                 
125:                 
126:                 	typedef enum
127:                 	{
128:                 		DMA_TXFER_OK,			// the transfer was performed successfully
129:                 		DMA_TXFER_ADD_ERR,		// address error while performing the transfer
130:                 		DMA_TXFER_ABORT,		// the DMA transfer was aborted
131:                 		DMA_TXFER_BC_ERR,		// block complete not set after the DMA transfer performed
132:                 		DMA_TXFER_CC_ERR,		// cell complete not set after the DMA transfer performed
133:                 		DMA_TXFER_TMO			// DMA transfer timeout
134:                 	}DmaTxferRes;		// DMA transfer result
135:                 
136:                 	typedef enum
137:                 	{
138:                 		DMA_WAIT_NOT,		// don't wait for the transfer to complete, return immediately
139:                 		DMA_WAIT_CELL,		// wait for the cell transfer to complete, than return
140:                 		DMA_WAIT_BLOCK		// wait for the block transfer to complete, than return
141:                 	}DmaWaitMode;		// DMA transfer wait mode
142:                 
143:                 	typedef enum
144:                 	{
145:                 		DMA_CHKSUM_CRC,		// LFSR CRC
146:                 		DMA_CHKSUM_IP,		// IP Checksum
147:                 	}DmaChksumType;		// DMA SFM supported checksum types
148:                 
149:                 	typedef enum
150:                 	{
151:                 		DMA_BITO_MSb,		// MSb first (not reflected)
152:                 		DMA_BITO_LSb,		// LSb first (reflected)
153:                 	}DmaBitOrder;		// DMA SFM supported bit ordering
154:                 
155:                 	typedef enum
156:                 	{
157:                 		DMA_REORDER_NOT,	// no reordering, destination matches the source
158:                 		DMA_REORDER_ENDIAN,	// change endianess on word (32 bit) boundaries: LE<->BE
159:                 		DMA_REORDER_SWAP_HALF,	// swap half words (16 bit) within word (32 bit)		
160:                 		DMA_REORDER_SWAP_BYTE,	// swap bytes within half word (16 bit)				
161:                 	}DmaReorderMode;	// DMA SFM supported re-ordering modes
162:                 
163:                 
164:                 	/*********************************************************************
165:                 	 * Function:        void DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags)
166:                 	 *
167:                 	 * PreCondition:    chPri  - valid channel priority, 0-3
168:                 	 *
169:                 	 * Input:           chn    - channel to be configured in the DMA controller
170:                 	 *                  chPri  - the priority given to the channel, 0-3
171:                 	 *                  oFlags - orred flags specifying the open mode:
172:                 	 *                           DMA_OPEN_DEFAULT: DMA default operation mode
173:                 	 *                           DMA_OPEN_AUTO:	DMA channel is auto enabled
174:                 	 *                           DMA_OPEN_CHAIN_LOW: DMA channel is chained to lower channel
175:                 	 *                           DMA_OPEN_CHAIN_HI: DMA channel is chained to higher channel
176:                 	 *                           DMA_OPEN_DET_EN: events detection enabled while channel off
177:                 	 *                           DMA_OPEN_ENABLE: DMA channel is enabled when opened
178:                 	 *                           DMA_OPEN_MATCH:	DMA channel stops on match
179:                 	 *
180:                 	 *
181:                 	 *
182:                 	 * Output:          None
183:                 	 *
184:                 	 * Side Effects:    None
185:                 	 *
186:                 	 * Overview:        The function opens and configures the selected DMA channel using the supplied user flags and priority.
187:                 	 *
188:                 	 * Note:            - This is a high level access function that doesn't give access to all the settings possible for a DMA channel.
189:                 	 *                  Use the low level functions to address special settings.
190:                 	 *                  - The channel is turned off, the pending interrupts are cleared, interrupts are disabled.
191:                 	 *                  After that the channel is configured.
192:                 	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
193:                 	 *                  if DMA_OPEN_ENABLE flag was not specified.
194:                 	 *                  - If the CRC is attached to the submitted channel, the CRC append mode will be turned off.
195:                 	 *                  This way, the transfer will occur correctly together with CRC calculation.
196:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
197:                 	 *                  User has to call event channel functions to enable the event flags if needed.
198:                 	 *
199:                 	 * Example:         DmaChnOpen(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_OPEN_AUTO|DMA_OPEN_MATCH|DMA_OPEN_ENABLE);
200:                 	 ********************************************************************/
201:                 	 void			DmaChnOpen(DmaChannel chn, DmaChannelPri chPri, DmaOpenFlags oFlags);
202:                 
203:                 	/*********************************************************************
204:                 	 * Function:        void DmaChnEnable(DmaChannel chn)
205:                 	 *
206:                 	 * PreCondition:    None
207:                 	 *
208:                 	 * Input:			chn		- channel to be enabled
209:                 	 *
210:                 	 * Output:          None
211:                 	 *
212:                 	 * Side Effects:    None
213:                 	 *
214:                 	 * Overview:		The function enables a previously configured DMA channel.
215:                 	 *
216:                 	 * Note:            DmaChnOpen()/DmaChnConfigure() should have been called before.
217:                 	 *
218:                 	 * Example:			DmaChnEnable(DMA_CHANNEL3);
219:                 	 ********************************************************************/
220:                 	 void			DmaChnEnable(DmaChannel chn);
221:                 
222:                 	/*********************************************************************
223:                 	 * Function:        void DmaChnDisable(DmaChannel chn)
224:                 	 *
225:                 	 * PreCondition:    None
226:                 	 *
227:                 	 * Input:			chn		- selected channel in the DMA controller
228:                 	 *
229:                 	 * Output:          None
230:                 	 *
231:                 	 * Side Effects:    None
232:                 	 *
233:                 	 * Overview:		The function disables a DMA channel. The channel operation stops.
234:                 	 *
235:                 	 * Note:            None.
236:                 	 *
237:                 	 * Example:			DmaChnDisable(DMA_CHANNEL3);
238:                 	 ********************************************************************/
239:                 	 void			DmaChnDisable(DmaChannel chn);
240:                 
241:                 	/*********************************************************************
242:                 	 * Function:        void DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize)
243:                 	 *
244:                 	 * PreCondition:    chn		- valid DMA channel
245:                 	 * 				- vSrcAdd, vDstAdd	- valid pointers
246:                 	 *                              - 0 < srcSize <= DmaGetMaxTxferSize()
247:                 	 *                              - 0 < dstSize <= DmaGetMaxTxferSize()
248:                 	 *                              - 0 < cellSize <= DmaGetMaxTxferSize()
249:                 	 *
250:                 	 * Input:			chn			- DMA channel number
251:                 	 * 								- vSrcAdd: source of the DMA transfer
252:                 	 * 								- vDstAdd: destination of the DMA transfer
253:                 	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
254:                 	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
255:                 	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
256:                 	 *
257:                 	 * Output:          None
258:                 	 *
259:                 	 * Side Effects:    None
260:                 	 *
261:                 	 * Overview:		The function sets the transfer characteristics for a DMA channel transfer:
262:                 	 * 					the source and the destination addresses.
263:                 	 * 					the source and destination lengths
264:                 	 * 					and the number of bytes	transferred per event.
265:                 	 *
266:                 	 * Note:            The function clears the existing DMA channel event flags.
267:                 	 *                  The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
268:                 	 *
269:                 	 * Example:			DmaChnSetTxfer(DMA_CHANNEL3, &U2RXREG, dstBuff, 1, 200, 1);
270:                 	 ********************************************************************/
271:                 	 void			DmaChnSetTxfer(DmaChannel chn, const void* vSrcAdd, void* vDstAdd, int srcSize, int dstSize, int cellSize);
272:                 
273:                 
274:                 	/*********************************************************************
275:                 	 * Function:        void DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd)
276:                 	 *
277:                 	 * PreCondition:    chn		- valid DMA channel
278:                 	 *
279:                 	 * Input:           chn		- DMA channel number
280:                 	 * 				- vSrcAdd: source (virtual) of the DMA transfer
281:                 	 * Output:          None
282:                 	 *
283:                 	 * Side Effects:    None
284:                 	 *
285:                 	 * Overview:        The function is a helper to set directly the transfer source address.
286:                 	 *
287:                 	 * Note:            None.
288:                 	 *
289:                 	 * Example:         DmaChnSetSrcAdd(DMA_CHANNEL2, srcBuff+sizeof(srcBuff));
290:                 	 ********************************************************************/
291:                 	 void			DmaChnSetSrcAdd(DmaChannel chn, const void* vSrcAdd);
292:                 
293:                 	/*********************************************************************
294:                 	 * Function:        void DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd)
295:                 	 *
296:                 	 * PreCondition:    chn		- valid DMA channel
297:                 	 *
298:                 	 * Input:			chn			- DMA channel number
299:                 	 * 								- vDstAdd: destination (virtual) of the DMA transfer
300:                 	 * Output:          None
301:                 	 *
302:                 	 * Side Effects:    None
303:                 	 *
304:                 	 * Overview:		The function is a helper to set directly the transfer destination address.
305:                 	 *
306:                 	 * Note:            None
307:                 	 *
308:                 	 * Example:         DmaChnSetDstAdd(DMA_CHANNEL2, dstBuff+sizeof(dstBuff));
309:                 	 ********************************************************************/
310:                 	 void			DmaChnSetDstAdd(DmaChannel chn, void* vDstAdd);
311:                 
312:                 	/*********************************************************************
313:                 	 * Function:        void DmaChnSetMatchPattern(DmaChannel chn, int pattern)
314:                 	 *
315:                 	 * PreCondition:    chn	- valid DMA channel
316:                 	 *
317:                 	 * Input:			chn		- DMA channel number
318:                 	 * 					pattern	-  the match pattern
319:                 	 *
320:                 	 * Output:          None
321:                 	 *
322:                 	 * Side Effects:    None
323:                 	 *
324:                 	 * Overview:		The function sets the curent match pattern for the selected DMA channel.
325:                 	 *
326:                 	 * Note:            None.
327:                 	 *
328:                 	 * Example:			DmaChnSetMatchPattern(DMA_CHANNEL3, '\r');
329:                 	 ********************************************************************/
330:                 	 void			DmaChnSetMatchPattern(DmaChannel chn, int pattern);
331:                 
332:                 	/*********************************************************************
333:                 	 * Function:        int DmaChnGetMatchPattern(DmaChannel chn)
334:                 	 *
335:                 	 * PreCondition:    chn	- valid DMA channel
336:                 	 *
337:                 	 * Input:			chn		- DMA channel number
338:                 	 *
339:                 	 * Output:          The channel match pattern.
340:                 	 *
341:                 	 * Side Effects:    None
342:                 	 *
343:                 	 * Overview:		The function retrieves the curent match pattern for the selected DMA channel.
344:                 	 *
345:                 	 * Note:            None.
346:                 	 *
347:                 	 * Example:			int pattern=DmaChnGetMatchPattern(DMA_CHANNEL3);
348:                 	 ********************************************************************/
349:                 	 int			DmaChnGetMatchPattern(DmaChannel chn);
350:                 
351:                 	/*********************************************************************
352:                 	 * Function:        DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries)
353:                 	 *
354:                 	 * PreCondition:    chn	- valid DMA channel
355:                 	 *
356:                 	 * Input:			chn		- DMA channel number
357:                 	 * 					wMode	- if DMA_WAIT_NOT, return immediately
358:                 	 * 							- if DMA_WAIT_CELL, return after the cell transfer complete
359:                 	 * 							- if DMA_WAIT_BLOCK, return after the whole transfer is done
360:                 	 * 					retries	- retry counter: if transfer not complete after so many retries, return with tmo.
361:                 	 * 								If 0, wait forever.
362:                 	 *
363:                 	 * Output:          DMA_TXFER_OK if not waiting for the transfer completion or if the transfer ended normally,
364:                 	 * 					an DmaTxferRes error code  otherwise
365:                 	 *
366:                 	 * Side Effects:    None
367:                 	 *
368:                 	 * Overview:		The function initiates (forces) a DMA transfer for the selected DMA channel.
369:                 	 * 					The DMA channel is enabled.
370:                 	 * 					If waiting for the transfer completion needed (user doesn't use an ISR to catch
371:                 	 * 					this event) the function will periodically query the DMA controller for the
372:                 	 * 					transfer completion status.
373:                      * 					If DMA_WAIT_BLOCK is specified and multiple cell transfers are needed to complete
374:                      * 					the block transfer than the function will re-force the transfer for each cell.
375:                 	 *
376:                 	 * Note:            This function can not ne used when the DMA channel is triggerred
377:                      *                  by hardware interrupt requests.
378:                      *                  This is because the transfers are software forced, theere is no
379:                      *                  wait for the occurrence of the hardware trigger. 
380:                 	 *
381:                 	 * Example:         DmaChnStartTxfer(DMA_CHANNEL2, DMA_WAIT_BLOCK, 0);
382:                 	 ********************************************************************/
383:                 	 DmaTxferRes DmaChnStartTxfer(DmaChannel chn, DmaWaitMode wMode, unsigned long retries);
384:                 
385:                 	/*********************************************************************
386:                 	 * Function:        void DmaChnForceTxfer(DmaChannel chn)
387:                 	 *
388:                 	 * PreCondition:    chn	- valid DMA channel
389:                 	 *
390:                 	 * Input:			chn		- DMA channel number
391:                 	 *
392:                 	 * Output:          None
393:                 	 *
394:                 	 * Side Effects:    None
395:                 	 *
396:                 	 * Overview:		The function forces a DMA transfer to occur for the selected DMA channel.
397:                 	 *
398:                 	 * Note:            None.
399:                 	 *
400:                 	 * Example:			DmaChnForceTxfer(DMA_CHANNEL3);
401:                 	 ********************************************************************/
402:                 	 void			DmaChnForceTxfer(DmaChannel chn);
403:                 
404:                 	/*********************************************************************
405:                 	 * Function:        void DmaChnAbortTxfer(DmaChannel chn)
406:                 	 *
407:                 	 * PreCondition:    chn	- valid DMA channel
408:                 	 *
409:                 	 * Input:			chn		- DMA channel number
410:                 	 *
411:                 	 * Output:          None
412:                 	 *
413:                 	 * Side Effects:    None
414:                 	 *
415:                 	 * Overview:		The function aborts a current undergoing DMA transfer for the selected DMA channel.
416:                 	 *
417:                 	 * Note:            None.
418:                 	 *
419:                 	 * Example:			DmaChnAbortTxfer(DMA_CHANNEL3);
420:                 	 ********************************************************************/
421:                 	 void			DmaChnAbortTxfer(DmaChannel chn);
422:                 
423:                 	// High level channel event and interrupt control functions
424:                 
425:                 	/*********************************************************************
426:                 	 * Function:        void DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
427:                 	 *
428:                 	 * PreCondition:    chn	- valid DMA channel
429:                 	 *
430:                 	 * Input:			chn		- DMA channel number
431:                 	 * 					eFlags	- event flags with the following significance:
432:                 	 * 								- DMA_EV_ERR: address error event
433:                 	 * 								- DMA_EV_ABORT: transfer abort event
434:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
435:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
436:                 	 * 								- DMA_EV_DST_HALF: destination half event
437:                 	 * 								- DMA_EV_DST_FULL: destination full event
438:                 	 * 								- DMA_EV_SRC_HALF: source half event
439:                 	 * 								- DMA_EV_SRC_FULL: source full event
440:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
441:                 	 *
442:                 	 * Output:          None
443:                 	 *
444:                 	 * Side Effects:    None
445:                 	 *
446:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
447:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
448:                 	 * 					enabled for the selected channel, the other channel event flags won't be touched.
449:                 	 *
450:                 	 * Note:            None.
451:                 	 *
452:                 	 * Example:			DmaChnSetEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
453:                 	 ********************************************************************/
454:                 	 void			DmaChnSetEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
455:                 
456:                 	/*********************************************************************
457:                 	 * Function:        void DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
458:                 	 *
459:                 	 * PreCondition:    chn	- valid DMA channel
460:                 	 *
461:                 	 * Input:			chn		- DMA channel number
462:                 	 * 					eFlags	- event flags with the following significance:
463:                 	 * 								- DMA_EV_ERR: address error event
464:                 	 * 								- DMA_EV_ABORT: transfer abort event
465:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
466:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
467:                 	 * 								- DMA_EV_DST_HALF: destination half event
468:                 	 * 								- DMA_EV_DST_FULL: destination full event
469:                 	 * 								- DMA_EV_SRC_HALF: source half event
470:                 	 * 								- DMA_EV_SRC_FULL: source full event
471:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
472:                 	 *
473:                 	 * Output:          None
474:                 	 *
475:                 	 * Side Effects:    None
476:                 	 *
477:                 	 * Overview:		The function clears the event enable flags for the selected DMA channel.
478:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
479:                 	 * 					disabled for the selected channel, the other channel event flags won't be touched.
480:                 	 *
481:                 	 * Note:            None.
482:                 	 *
483:                 	 * Example:			DmaChnClrEvEnableFlags(DMA_CHANNEL3, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
484:                 	 ********************************************************************/
485:                 	 void			DmaChnClrEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
486:                 
487:                 	/*********************************************************************
488:                 	 * Function:        void DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags)
489:                 	 *
490:                 	 * PreCondition:    chn	- valid DMA channel
491:                 	 *
492:                 	 * Input:			chn		- DMA channel number
493:                 	 * 					eFlags	- event flags with the following significance:
494:                 	 * 								- DMA_EV_ERR: address error event
495:                 	 * 								- DMA_EV_ABORT: transfer abort event
496:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
497:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
498:                 	 * 								- DMA_EV_DST_HALF: destination half event
499:                 	 * 								- DMA_EV_DST_FULL: destination full event
500:                 	 * 								- DMA_EV_SRC_HALF: source half event
501:                 	 * 								- DMA_EV_SRC_FULL: source full event
502:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
503:                 	 *
504:                 	 * Output:          None
505:                 	 *
506:                 	 * Side Effects:    None
507:                 	 *
508:                 	 * Overview:		The function sets the event enable flags for the selected DMA channel.
509:                 	 * 					The channel event flags are forced to the eFlags value.
510:                 	 *
511:                 	 * Note:            None.
512:                 	 *
513:                 	 * Example:			DmaChnWriteEvEnableFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
514:                 	 ********************************************************************/
515:                 	 void			DmaChnWriteEvEnableFlags(DmaChannel chn, DmaEvFlags eFlags);
516:                 
517:                 	/*********************************************************************
518:                 	 * Function:        DmaEvFlags DmaChnGetEvEnableFlags(DmaChannel chn)
519:                 	 *
520:                 	 * PreCondition:    chn	- valid DMA channel
521:                 	 *
522:                 	 * Input:			chn		- DMA channel number
523:                 	 *
524:                 	 * Output:          - event flags with the following significance:
525:                 	 * 						- DMA_EV_ERR: address error event
526:                 	 * 						- DMA_EV_ABORT: transfer abort event
527:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
528:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
529:                 	 * 						- DMA_EV_DST_HALF: destination half event
530:                 	 * 						- DMA_EV_DST_FULL: destination full event
531:                 	 * 						- DMA_EV_SRC_HALF: source half event
532:                 	 * 						- DMA_EV_SRC_FULL: source full event
533:                 	 *						- DMA_EV_ALL_EVNTS: all of the above flags
534:                 	 *
535:                 	 * Side Effects:    None
536:                 	 *
537:                 	 * Overview:		The function returns the event enabled flags for the selected DMA channel.
538:                 	 *
539:                 	 * Note:            None.
540:                 	 *
541:                 	 * Example:			DmaEvFlags enabledFlags=DmaChnGetEvEnableFlags(DMA_CHANNEL3);
542:                 	 ********************************************************************/
543:                 	 DmaEvFlags	DmaChnGetEvEnableFlags(DmaChannel chn);
544:                 
545:                 	/*********************************************************************
546:                 	 * Function:        void DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags)
547:                 	 *
548:                 	 * PreCondition:    chn	- valid DMA channel
549:                 	 *
550:                 	 * Input:			chn		- DMA channel number
551:                 	 * 					eFlags	- event flags with the following significance:
552:                 	 * 								- DMA_EV_ERR: address error event
553:                 	 * 								- DMA_EV_ABORT: transfer abort event
554:                 	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
555:                 	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
556:                 	 * 								- DMA_EV_DST_HALF: destination half event
557:                 	 * 								- DMA_EV_DST_FULL: destination full event
558:                 	 * 								- DMA_EV_SRC_HALF: source half event
559:                 	 * 								- DMA_EV_SRC_FULL: source full event
560:                 	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
561:                 	 *
562:                 	 * Output:          None
563:                 	 *
564:                 	 * Side Effects:    None
565:                 	 *
566:                 	 * Overview:		The function clears the event flags for the selected DMA channel.
567:                 	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
568:                 	 * 					cleared for the selected channel, the other channel event flags won't be touched.
569:                 	 *
570:                 	 * Note:            None.
571:                 	 *
572:                 	 * Example:			DmaChnClrEvFlags(DMA_CHANNEL3, DMA_EV_ALL_EVNTS);
573:                 	 ********************************************************************/
574:                 	 void			DmaChnClrEvFlags(DmaChannel chn, DmaEvFlags eFlags);
575:                 
576:                 	/*********************************************************************
577:                 	 * Function:        DmaEvFlags DmaChnGetEvFlags(DmaChannel chn)
578:                 	 *
579:                 	 * PreCondition:    chn	- valid DMA channel
580:                 	 *
581:                 	 * Input:			chn		- DMA channel number
582:                 	 *
583:                 	 * Output:          event flags with the following significance:
584:                 	 * 						- DMA_EV_ERR: address error event
585:                 	 * 						- DMA_EV_ABORT: transfer abort event
586:                 	 * 						- DMA_EV_CELL_DONE: cell transfer complete event
587:                 	 * 						- DMA_EV_BLOCK_DONE: block transfer complete event
588:                 	 * 						- DMA_EV_DST_HALF: destination half event
589:                 	 * 						- DMA_EV_DST_FULL: destination full event
590:                 	 * 						- DMA_EV_SRC_HALF: source half event
591:                 	 * 						- DMA_EV_SRC_FULL: source full event
592:                 	 * 						- DMA_EV_ALL_EVNTS: all of the above flags
593:                 	 *
594:                 	 * Side Effects:    None
595:                 	 *
596:                 	 * Overview:		The function returns the event flags for the selected DMA channel.
597:                 	 *
598:                 	 * Note:            None.
599:                 	 *
600:                 	 * Example:			DmaEvFlags intSetFlags=DmaChnGetEvFlags(DMA_CHANNEL3);
601:                 	 ********************************************************************/
602:                 	 DmaEvFlags	DmaChnGetEvFlags(DmaChannel chn);
603:                 
604:                 
605:                 	// high level helpers for fast strcpy/memcpy transfers
606:                 
607:                 	/*********************************************************************
608:                 	 * Function:        DmaTxferRes DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri)
609:                 	 *
610:                 	 * PreCondition:    chn		- a valid DMA channel
611:                 	 * 					s1, s2	- valid memory pointers
612:                 	 * 					n>0, n<=DmaGetMaxTxferSize()
613:                 	 *
614:                 	 * Input:			s1		- destination pointer
615:                 	 * 					s2		- source pointer
616:                 	 * 					n		- number of bytes to transfer
617:                 	 * 					chn		- the DMA channel to perform the transfer
618:                 	 * 					chPri	- the desired channel priority
619:                 	 *
620:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
621:                 	 * 					an DmaTxferRes error code  otherwise
622:                 	 *
623:                 	 * Side Effects:    None
624:                 	 *
625:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
626:                 	 * 			Then it copies one block of memory from source to destination.
627:                 	 *
628:                 	 *
629:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
630:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
631:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
632:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
633:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
634:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
635:                 	 *
636:                  	 * Example:		res=DmaChnMemcpy(pDst, pSrc, buffSz, DMA_CHANNEL0, DMA_CHN_PRI3);
637:                  	 ********************************************************************/
638:                 	 DmaTxferRes	DmaChnMemcpy(void* s1, const void* s2, int n, DmaChannel chn, DmaChannelPri chPri);
639:                 
640:                 	/*********************************************************************
641:                 	 * Function:        DmaTxferRes DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri)
642:                 	 *
643:                 	 * PreCondition:    chn		- a valid DMA channel
644:                 	 * 					s1, s2	- valid memory pointers
645:                 	 *
646:                 	 * Input:			s1		- destination pointer
647:                 	 * 					s2		- source pointer
648:                 	 * 					chn		- the DMA channel to perform the transfer
649:                 	 * 					chPri	- the desired channel priority
650:                 	 *
651:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
652:                 	 * 					an DmaTxferRes error code  otherwise
653:                 	 *
654:                 	 * Side Effects:    None
655:                 	 *
656:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
657:                 	 * 			Then it copies one zero terminated string from source to destination.
658:                 	 *
659:                 	 *
660:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
661:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
662:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
663:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
664:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
665:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
666:                 	 *
667:                 	 *
668:                  	 * Example:		res=DmaChnStrcpy(str1, str2, DMA_CHANNEL1, DMA_CHN_PRI3);
669:                 	 *********************************************************************/
670:                 	 DmaTxferRes	DmaChnStrcpy(char* s1, const char* s2, DmaChannel chn, DmaChannelPri chPri);
671:                 
672:                 	/*********************************************************************
673:                 	 * Function:        DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri)
674:                 	 *
675:                 	 * PreCondition:    chn		- a valid DMA channel
676:                 	 * 				- s1, s2	- valid memory pointers
677:                 	 *                              - 0 < n <= DmaGetMaxTxferSize()
678:                 	 *
679:                 	 * Input:			s1		- destination pointer
680:                 	 * 					s2		- source pointer
681:                 	 * 					n	- max number of bytes to transfer
682:                 	 * 					chn		- the DMA channel to perform the transfer
683:                 	 * 					chPri	- the desired channel priority
684:                 	 *
685:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
686:                 	 * 					an DmaTxferRes error code  otherwise
687:                 	 *
688:                 	 * Side Effects:    None
689:                 	 *
690:                 	 * Overview:		The function configures a DMA channel for a fast memory transfer.
691:                 	 * 			Then it copies one zero terminated string from source to destination.
692:                 	 * 			It copies no more than n characters from s2.
693:                 	 *
694:                 	 *
695:                 	 * Note:            - If the SFM is attached to the submitted channel, the SFM append mode will be turned off.
696:                 	 *                    This way, the transfer will occur correctly together with checksum calculation.
697:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
698:                 	 *                  - Multiple channels could be opened to perform fast memory transfers, if necessary.
699:                 	 *                  - The function clears the suspend state and resumes the operation of the DMA controller.
700:                 	 *                  - The source to destination byte re-ordering is affected by DmaSfmConfigure(), DmaSfmTxferReorder().
701:                 	 *
702:                 	 *
703:                  	 * Example:		res=DmaChnStrncpy(str1, str2, MAX_STR_LEN, DMA_CHANNEL1, DMA_CHN_PRI3);
704:                 	 ********************************************************************/
705:                 	 DmaTxferRes DmaChnStrncpy(char* s1, const char* s2, int n, DmaChannel chn, DmaChannelPri chPri);
706:                 
707:                 	/*********************************************************************
708:                 	 * Function:        DmaTxferRes DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
709:                 	 *
710:                 	 * PreCondition:    chn    - a valid DMA channel
711:                 	 *                  d, s   - valid memory pointer
712:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
713:                 	 *
714:                 	 * Input:           d     - address where to deposit the result
715:                 	 *                  s     - source buffer pointer
716:                 	 *                  n     - number of bytes in the pointer
717:                 	 *                  chn   - the DMA channel to use
718:                 	 *                  chPri - the desired channel priority
719:                 	 * 
720:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
721:                 	 *                  an DmaTxferRes error code  otherwise
722:                 	 *
723:                 	 * Side Effects:    None
724:                 	 *
725:                 	 * Overview:        The function is a helper that calculates the CRC of a memory block.
726:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the CRC.
727:                 	 *
728:                 	 *
729:                 	 * Note:            - The CRC generator must have been previously configured using DmaSfmCrcConfigure()
730:                 	 *                  - No transfer is done, just the CRC is calculated.
731:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
732:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
733:                 	 *                  - The checksum type is switched to CRC.
734:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
735:                 	 *                  
736:                 	 * Example:          int myCrc; DmaChnMemCrc(&myCrc, srcBuff, sizeof(srcBuff), DMA_CHANNEL2, DMA_CHN_PRI3);
737:                 	 ********************************************************************/
738:                 	 DmaTxferRes	DmaChnMemCrc(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
739:                 
740:                 	/*********************************************************************
741:                 	 * Function:        DmaTxferRes DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri)
742:                 	 *
743:                 	 * PreCondition:    chn    - a valid DMA channel
744:                 	 *                  d, s   - valid memory pointer
745:                 	 *                  n>0, n<=DmaGetMaxTxferSize()
746:                 	 *
747:                 	 * Input:           d     - address where to deposit the result
748:                 	 *                  s     - source buffer pointer
749:                 	 *                  n     - number of bytes in the pointer
750:                 	 *                  chn   - the DMA channel to use
751:                 	 *                  chPri - the desired channel priority
752:                 	 * 
753:                 	 * Output:          DMA_TXFER_OK if the transfer ended normally,
754:                 	 *                  an DmaTxferRes error code  otherwise
755:                 	 *
756:                 	 * Side Effects:    None
757:                 	 *
758:                 	 * Overview:        The function is a helper that calculates the IP checksum of a memory block.
759:                 	 *                  The function configures the DMA channel for a fast memory transfer and calculates the IP checksum.
760:                 	 *
761:                 	 *
762:                 	 * Note:            - The checksum generator must have been previously seeded using DmaSfmSetSeed()
763:                 	 *                  - No transfer is done, just the checksum is calculated.
764:                 	 *                  - The start and abort Irqs will be disabled and the channel event enable flags are disabled.
765:                 	 *                  - Append mode is enabled and the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
766:                 	 *                  - The checksum type is switched to IP checksum.
767:                 	 *                  - The way the data is fed into the checksum calculation block is affected by DmaSfmConfigure().
768:                 	 *                  
769:                 	 * Example:          int myChecksum; DmaChnMemChecksum(&myChecksum, srcBuff, sizeof(srcBuff), DMA_CHANNEL1, DMA_CHN_PRI3);
770:                 	 ********************************************************************/
771:                 	 DmaTxferRes	DmaChnMemChecksum(void* d, const void* s, int n, DmaChannel chn, DmaChannelPri chPri);
772:                 
773:                 	// High level Special Function Module (SFM) functions
774:                 
775:                 	/*********************************************************************
776:                 	 * Function:        void DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
777:                 	 *
778:                 	 * PreCondition:    cType, bitO, rMode - valid values
779:                 	 *
780:                 	 * Input:           cType - checksum type to be calculated: CRC or IP Checksum
781:                 	 *                  bitO  - the bit order to be used MSb or LSb first
782:                 	 *                  rMode - the reordering mode of the bytes when calculating the checksum 
783:                 	 *
784:                 	 * Output:          None
785:                 	 *
786:                 	 * Side Effects:    Whenever the Transfer re-ordering is enabled the rMode setting will influence the destination data layout
787:                 	 *
788:                 	 * Overview:        The function configures the SFM module by setting the parameters that define the behavior:
789:                 	 *                      - the type of the checksum to be calculated (either CRC or IP checksum are supported)
790:                 	 *                      - the bit ordering (how a specific byte is used in the checksum calculation: MSb or LSb first) 
791:                 	 *                      - the data re-ordering (how bytes are re-ordered before calculating the checksum).
792:                 	 *                      All these values affect the way the checksum is calculated.
793:                 	 *
794:                 	 * Note:            None
795:                 	 *
796:                 	 * Example:         DmaSfmConfigure(DMA_CHKSUM_CRC, DMA_BITO_LSb, DMA_REORDER_ENDIAN);
797:                 	 ********************************************************************/
798:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmConfigure(DmaChksumType cType, DmaBitOrder bitO, DmaReorderMode rMode)
799:                 	{
800:                 		DCRCCONCLR=_DCRCCON_CRCTYP_MASK|_DCRCCON_BITO_MASK|_DCRCCON_BYTO_MASK;
801:                 		DCRCCONSET=(cType<<_DCRCCON_CRCTYP_POSITION)|(bitO<<_DCRCCON_BITO_POSITION)|(rMode<<_DCRCCON_BYTO_POSITION);
802:                 	}
803:                 
804:                 	/*********************************************************************
805:                 	 * Function:        void DmaSfmTxferReorder(int enable)
806:                 	 *
807:                 	 * PreCondition:    None
808:                 	 *
809:                 	 * Input:           enable - boolean to enable/disable the re-ordering of the data transfer
810:                 	 *
811:                 	 * Output:          None
812:                 	 *
813:                 	 * Side Effects:    None
814:                 	 *
815:                 	 * Overview:        The function configures the data transfer re-ordering of the SFM module.
816:                 	 *                  If the re-ordering is enabled, the data is read from the source, re-ordered accordingly and then written to the destination.
817:                 	 *                  Otherwise the data is written to the destination un-modified.
818:                 	 *                  The re-ordering is the one specified by the DmaReorderMode parameter in the DmaSfmConfigure() call.
819:                 	 *                  
820:                 	 *
821:                 	 * Note:            - The data transfer re-ordering should be used only for normal (background mode) data transfers.
822:                 	 *                  - In append mode the data transfer re-ordering should not be enabled (undefined behavior)!
823:                 	 *                  - Whenever the data re-ordering is enabled, the transfer should be aligned at both ends (source and destination).
824:                 	 *                    Un-aligned transfers are not supported (undefined behavior)!
825:                 	 *
826:                 	 * Example:         DmaSfmTxferReorder();
827:                 	 ********************************************************************/
828:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmTxferReorder(int enable)
829:                 	{
830:                 		DCRCCONCLR=_DCRCCON_WBO_MASK;
831:                 		DCRCCONSET=(enable<<_DCRCCON_WBO_POSITION);
832:                 	}
833:                 
834:                 
835:                 	 /*********************************************************************
836:                 	 * Function:        void DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
837:                 	 *
838:                 	 * PreCondition:    pLen   - valid polynomial length within 1-32
839:                 	 *
840:                 	 * Input:           polynomial	- the layout of the CRC generator
841:                 	 *                  pLen        - the length of the CRC generator polynomial
842:                 	 *                  seed        - the initial seed of the CRC generator
843:                 	 *
844:                 	 * Output:          None
845:                 	 *
846:                 	 * Side Effects:    None
847:                 	 *
848:                 	 * Overview:        The function configures the SFM CRC module by setting the parameters that define the generator polynomial:
849:                 	 *                  - the length of the CRC generator polynomial, pLen;
850:                 	 *                  - the function sets the layout of the shift stages that take place in the CRC generation.
851:                 	 *                    Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
852:                 	 *                    If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
853:                 	 *                    Note that in a proper CRC polynomial, both the most significant bit (MSb) and least significant bit(LSb)
854:                 	 *                    are always a '1'. Considering the generator polynomial: X^16+X^15+X^2+1, the value to be written as
855:                 	 *                    feedback should be 0x8005, or 0x8004, but not 0x018005;
856:                 	 *                  - the function sets the seed of the CRC generator. This is the initial data present in the
857:                 	 *                   CRC shift register before the CRC calculation begins. A good initial value is usually 0xffffffff.
858:                 	 *
859:                 	 * Note:            - Bit 0 of the generator polynomial is always XOR'ed.
860:                 	 *                  - When the append mode is set, the attached DMA channel has to have destination size <=4.
861:                 	 *                    Upon the transfer completion the calculated CRC is stored at the destination address.
862:                 	 *                  - When append mode is cleared, the DMA transfer occurs normally, and the CRC value is available using
863:                 	 *                    the CrcResult() function.
864:                 	 *                  - The CRC module should be configured before enabled.
865:                 	 *                  - These settings are relevant only when the SFM is configured for the CRC type of checksum.
866:                 	 *                  - The checksum register is the same for CRC or IP checksum mode. Therefore, this function changes also the seed for the IP checksum.
867:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
868:                 	 *
869:                 	 * Example:         DmaSfmCrcConfigure(0x04c11db7, 32, 0xffffffff);
870:                 	 ********************************************************************/
871:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmCrcConfigure(unsigned int polynomial, int pLen, unsigned int seed)
872:                 	{
873:                 		DCRCCONCLR=_DCRCCON_PLEN_MASK;
874:                 		DCRCCONSET=(pLen-1)<<_DCRCCON_PLEN_POSITION;
875:                 		DCRCDATA=seed;
876:                 		DCRCXOR=polynomial;
877:                 	}
878:                 	
879:                 	#define DmaCrcConfigure	DmaSfmCrcConfigure	// PIC32_3xx backward compatibility name
880:                 
881:                 
882:                 	/*********************************************************************
883:                 	 * Function:        void DmaSfmAttachChannel(DmaChannel chn, int appendMode)
884:                 	 *
885:                 	 * PreCondition:    chn	   - valid DMA channel
886:                 	 *
887:                 	 * Input:           chn         - the DMA channel to be attached to the checksum module.
888:                 	 *                  appendMode	- if TRUE the data passed to the checksum generator is not transferred to destination
889:                 	 *                                but it's written to the destination address when the block transfer is complete.
890:                 	 *                              - if FALSE the data is transferred normally while the checksum is calculated.
891:                 	 *                                The checksum will be available using the DmaSfmChecksum function.
892:                 	 *
893:                 	 * Output:          None
894:                 	 *
895:                 	 * Side Effects:    None
896:                 	 *
897:                 	 * Overview:        The function attaches the SFM checksum module to a DMA channel and enables the checksum generator.
898:                 	 *                  From now on, all the DMA traffic is directed to the SFM checksum generator. Once the DMA block transfer
899:                 	 *                  is complete, the checksum result is available in the checksum data register.
900:                 	 *                  If append mode is enabled, no data transfer takes place but the checksum result will be deposited at the DMA destination address.
901:                 
902:                 	 *
903:                 	 * Note:            If append mode is enabled the data transfer re-ordering is disabled (illegal combination, see DmaSfmTxferReorder()).
904:                 	 * 
905:                 	 * Example:         DmaSfmAttachChannel(DMA_CHANNEL0, TRUE);
906:                 	 ********************************************************************/
907:                 	void			DmaSfmAttachChannel(DmaChannel chn, int appendMode);
908:                 	#define			CrcAttachChannel	DmaSfmAttachChannel		// PIC32_3xx backward compatibility name	
909:                 
910:                 	/*********************************************************************
911:                 	 * Function:        unsigned int DmaSfmChecksum(void)
912:                 	 *
913:                 	 * PreCondition:    None
914:                 	 *
915:                 	 * Input:			None
916:                 	 *
917:                 	 * Output:          the current value of the checksum generator.
918:                 	 *
919:                 	 * Side Effects:    None
920:                 	 *
921:                 	 * Overview:		The function returns the calculated checksum value.
922:                 	 *
923:                 	 * Note:            - The function returns the valid checksum result. The masking out the unused MSbits in the checksum register is done by the hardware.
924:                 	 *                  - The way the data is fed into the checksum calculation block and the type of the checksum performed is affected by DmaSfmConfigure().
925:                 	 *
926:                 	 * Example:         unsigned int myChk=DmaSfmChecksum();
927:                 	 ********************************************************************/
928:                 	extern __inline__ int __attribute__((always_inline)) DmaSfmChecksum(void)
929:                 	{
930:                 		return DCRCDATA;
931:                 	}
932:                 	#define		CrcResult	DmaSfmChecksum		// PIC32_3xx backward compatibility name
933:                 	#define		DmaCrcGetValue	DmaSfmChecksum		// PIC32_3xx backward compatibility name 
934:                 
935:                 
936:                 	/*********************************************************************
937:                 	 * Function:        void DmaSfmSetSeed(unsigned int seed)
938:                 	 *
939:                 	 * PreCondition:    None
940:                 	 *
941:                 	 * Input:           seed	- the initial seed of the checksum generator
942:                 	 *
943:                 	 * Output:          None
944:                 	 *
945:                 	 * Side Effects:    None
946:                 	 *
947:                 	 * Overview:        The function sets the seed of the checksum generator. This is the initial data present in the
948:                 	 *                  CRC shift register or the IP checksum calculator before the actual transfer/calculation begins.
949:                 	 *
950:                 	 * Note:            When the SFM is configured for IP checksum mode, only the least significant 16 bits are relevant.
951:                 	 *
952:                 	 * Example:         DmaSfmSetSeed(0xffffffff);
953:                 	 ********************************************************************/
954:                 	extern __inline__ void __attribute__((always_inline)) DmaSfmSetSeed(unsigned int seed)
955:                 	{
956:                 		DCRCDATA=seed;
957:                 	}
958:                 	#define		DmaCrcSetSeed	DmaSfmSetSeed		// PIC32_3xx backward compatibility name
959:                 
960:                 	 
961:                 /*********************  end of high level functions ****************************************/
962:                 
963:                 	// low level definitions for the API functions
964:                 
965:                 
966:                 	typedef struct
967:                 	{
968:                 		union
969:                 		{
970:                 			struct
971:                 			{
972:                 				unsigned int chn:	3;		// last active DMA channel
973:                 				unsigned int rdOp:	1;		// last DMA operation, read if 1, write if 0
974:                 			};
975:                 			unsigned int	w;						// word access
976:                 		}lastAccess;
977:                 		void*	lastAddress;		// most recent DMA address
978:                 	}DmaStatus;			// DMA controller status
979:                 
980:                 	typedef enum
981:                 	{
982:                 		DMA_GFLG_SUSPEND =	_DMACON_SUSPEND_MASK,	// suspend DMA controller operation
983:                 		DMA_GFLG_ON =		_DMACON_ON_MASK,		// DMA module enabled/desabled
984:                 		//
985:                 		DMA_GFLG_ALL_FLAGS=	DMA_GFLG_SUSPEND|DMA_GFLG_ON		// all flags
986:                 	}DmaGlblFlags;	// flags for controlling global DMA controller behavior. From processor header file.
987:                 
988:                 
989:                 
990:                 
991:                 	typedef enum
992:                 	{
993:                 		DMA_EV_ABORT_IRQ_EN =		_DCH0ECON_AIRQEN_MASK,
994:                 		DMA_EV_START_IRQ_EN =		_DCH0ECON_SIRQEN_MASK,
995:                         // use DMA_EV_START_IRQ() and DMA_EV_ABORT_IRQ() below for selecting
996:                         // the start and abort IRQ signals
997:                 		DMA_EV_MATCH_EN =			_DCH0ECON_PATEN_MASK,
998:                 
999:                 
1000:                        // compiler use only field
1001:                        _DMA_EV_MAX_MASK =     _DCH0ECON_CHAIRQ_MASK,
1002:                	}DmaEvCtrlFlags;	/*DMA channel event control fields accessible as flags also
1003:                	                	  part of DmaEvCtrlFlags:
1004:                	                	*/
1005:                	#define	DMA_EV_START_IRQ(irq)	(DMA_EV_START_IRQ_EN | ((irq)<<_DCH0ECON_CHSIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1006:                	#define	DMA_EV_ABORT_IRQ(irq)	(DMA_EV_ABORT_IRQ_EN | ((irq)<<_DCH0ECON_CHAIRQ_POSITION))	// NOTE: irq has to be a symbol from the processor header file
1007:                
1008:                	// DMA channel event control as a structure:
1009:                	#define	DmaEvCtrl	__DCH0ECONbits_t
1010:                
1011:                
1012:                
1013:                
1014:                	typedef enum
1015:                	{
1016:                		DMA_CTL_AUTO_EN =		_DCH0CON_CHAEN_MASK,
1017:                		DMA_CTL_CHAIN_EN =		_DCH0CON_CHCHN_MASK,
1018:                		DMA_CTL_DET_EN =		_DCH0CON_CHAED_MASK,
1019:                		DMA_CTL_CHN_EN =		_DCH0CON_CHEN_MASK,
1020:                		DMA_CTL_CHAIN_DIR =		_DCH0CON_CHCHNS_MASK,
1021:                        // use the DMA_CTL_PRI() below for selecting the DMA
1022:                        // channel priority
1023:                	}DmaChnCtrlFlags;	// controlling the DMA channel with flags
1024:                	// also part of DmaChnCtrlFlags:
1025:                	#define	DMA_CTL_PRI(pri)	((pri)&_DCH0CON_CHPRI_MASK) // DMA Control channel priority
1026:                
1027:                	// DMA channel control as a structure:
1028:                	#define	DmaChnCtrl  	__DCH0CONbits_t
1029:                
1030:                	typedef struct
1031:                	{
1032:                		void*	vSrcAdd;		// source of the DMA transfer, virtual
1033:                		void*	vDstAdd;		// destination of the DMA transfer, virtual
1034:                		int	srcSize;		// source buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1035:                		int	dstSize;		// destination buffer size, 1 to DmaGetMaxTxferSize() bytes. Wrapped around.
1036:                		int	cellSize;		// no of bytes txferred per event, 1 to DmaGetMaxTxferSize().
1037:                	}DmaTxferCtrl;		// transfer setting: the transfer source, destination addresses and size, cell size
1038:                
1039:                
1040:                	/********************** low level DMA channel functions *******************************/
1041:                
1042:                
1043:                
1044:                	// Global DMA controller functions
1045:                
1046:                	/*********************************************************************
1047:                	 * Function:        void DmaEnable(int enable)
1048:                	 *
1049:                	 * PreCondition:    None
1050:                	 *
1051:                	 * Input:           enable - boolean to enable/disable the DMA controller
1052:                	 *
1053:                	 * Output:          None
1054:                	 *
1055:                	 * Side Effects:    None
1056:                	 *
1057:                	 * Overview:       The function enables/disables the DMA controller.
1058:                	 *
1059:                	 * Note:           None.
1060:                	 *
1061:                	 * Example:        DmaEnable(1);
1062:                	 ********************************************************************/
1063:                	extern __inline__ void __attribute__((always_inline)) DmaEnable(int enable)
1064:                	{
1065:                		if(enable)
1066:                		{
1067:                			DMACONSET=_DMACON_ON_MASK;
1068:                		}
1069:                		else
1070:                		{
1071:                			DMACONCLR=_DMACON_ON_MASK;
1072:                			while(DMACONbits.ON);		// wait to take effect
1073:                		}
1074:                	}
1075:                
1076:                	/*********************************************************************
1077:                	 * Function:        void DmaReset(void)
1078:                	 *
1079:                	 * PreCondition:    None
1080:                	 *
1081:                	 * Input:		None
1082:                	 *
1083:                	 * Output:          None
1084:                	 *
1085:                	 * Side Effects:    None
1086:                	 *
1087:                	 * Overview:        The function resets the DMA controller.
1088:                	 *
1089:                	 * Note:            None.
1090:                	 *
1091:                	 * Example:        DmaReset();
1092:                	 ********************************************************************/
1093:                	#define            DmaReset()	DmaEnable(0)
1094:                
1095:                
1096:                	/*********************************************************************
1097:                	 * Function:        int DmaSuspend(void)
1098:                	 *
1099:                	 * PreCondition:    None
1100:                	 *
1101:                	 * Input:		None
1102:                	 *
1103:                	 * Output:          true if the DMA was previously suspended, false otherwise
1104:                	 *
1105:                	 *
1106:                	 * Side Effects:    None
1107:                	 *
1108:                	 * Overview:        The function suspends the DMA controller.
1109:                	 *
1110:                	 * Note:            After the execution of this function the DMA operation is supposed to be suspended.
1111:                	 *                  I.e. the function has to wait for the suspension to take place!
1112:                	 *
1113:                	 * Example:         int susp=DmaSuspend();
1114:                	 ********************************************************************/
1115:                        extern __inline__ int __attribute__((always_inline)) DmaSuspend(void)
1116:                	{
1117:                		int suspSt;
1118:                		if(!(suspSt=DMACONbits.SUSPEND))
9D004930  3C02BF88   LUI V0, -16504
9D004934  8C423000   LW V0, 12288(V0)
9D004938  7C420300   EXT V0, V0, 12, 1
9D00493C  304200FF   ANDI V0, V0, 255
9D004940  AFC2003C   SW V0, 60(S8)
9D004944  8FC2003C   LW V0, 60(S8)
9D004948  14400009   BNE V0, ZERO, 0x9D004970
9D00494C  00000000   NOP
9D004A04  3C02BF88   LUI V0, -16504
9D004A08  8C423000   LW V0, 12288(V0)
9D004A0C  7C420300   EXT V0, V0, 12, 1
9D004A10  304200FF   ANDI V0, V0, 255
9D004A14  AFC20048   SW V0, 72(S8)
9D004A18  8FC20048   LW V0, 72(S8)
9D004A1C  1440000E   BNE V0, ZERO, 0x9D004A58
9D004A20  00000000   NOP
9D004AE0  3C02BF88   LUI V0, -16504
9D004AE4  8C423000   LW V0, 12288(V0)
9D004AE8  7C420300   EXT V0, V0, 12, 1
9D004AEC  304200FF   ANDI V0, V0, 255
9D004AF0  AFC2005C   SW V0, 92(S8)
9D004AF4  8FC2005C   LW V0, 92(S8)
9D004AF8  14400009   BNE V0, ZERO, 0x9D004B20
9D004AFC  00000000   NOP
9D004BB4  3C02BF88   LUI V0, -16504
9D004BB8  8C423000   LW V0, 12288(V0)
9D004BBC  7C420300   EXT V0, V0, 12, 1
9D004BC0  304200FF   ANDI V0, V0, 255
9D004BC4  AFC20068   SW V0, 104(S8)
9D004BC8  8FC20068   LW V0, 104(S8)
9D004BCC  1440000E   BNE V0, ZERO, 0x9D004C08
9D004BD0  00000000   NOP
1119:                		{
1120:                			DMACONSET=_DMACON_SUSPEND_MASK;		// suspend
9D004950  3C02BF88   LUI V0, -16504
9D004954  24031000   ADDIU V1, ZERO, 4096
9D004958  AC433008   SW V1, 12296(V0)
9D004A24  3C02BF88   LUI V0, -16504
9D004A28  24031000   ADDIU V1, ZERO, 4096
9D004A2C  AC433008   SW V1, 12296(V0)
9D004B00  3C02BF88   LUI V0, -16504
9D004B04  24031000   ADDIU V1, ZERO, 4096
9D004B08  AC433008   SW V1, 12296(V0)
9D004BD4  3C02BF88   LUI V0, -16504
9D004BD8  24031000   ADDIU V1, ZERO, 4096
9D004BDC  AC433008   SW V1, 12296(V0)
1121:                			while((DMACONbits.DMABUSY));	// wait to be actually suspended
9D00495C  3C02BF88   LUI V0, -16504
9D004960  8C423000   LW V0, 12288(V0)
9D004964  30420800   ANDI V0, V0, 2048
9D004968  1440FFFC   BNE V0, ZERO, 0x9D00495C
9D00496C  00000000   NOP
9D004A30  3C02BF88   LUI V0, -16504
9D004A34  8C423000   LW V0, 12288(V0)
9D004A38  30420800   ANDI V0, V0, 2048
9D004A3C  1440FFFC   BNE V0, ZERO, 0x9D004A30
9D004A40  00000000   NOP
9D004A44  0B401296   J 0x9D004A58
9D004A48  00000000   NOP
9D004B0C  3C02BF88   LUI V0, -16504
9D004B10  8C423000   LW V0, 12288(V0)
9D004B14  30420800   ANDI V0, V0, 2048
9D004B18  1440FFFC   BNE V0, ZERO, 0x9D004B0C
9D004B1C  00000000   NOP
9D004BE0  3C02BF88   LUI V0, -16504
9D004BE4  8C423000   LW V0, 12288(V0)
9D004BE8  30420800   ANDI V0, V0, 2048
9D004BEC  1440FFFC   BNE V0, ZERO, 0x9D004BE0
9D004BF0  00000000   NOP
9D004BF4  0B401302   J 0x9D004C08
9D004BF8  00000000   NOP
1122:                		}
1123:                		return suspSt;
9D004970  8FC2003C   LW V0, 60(S8)
9D004B20  8FC2005C   LW V0, 92(S8)
1124:                	}
1125:                
1126:                
1127:                
1128:                	/*********************************************************************
1129:                	 * Function:        void DmaResume(int susp)
1130:                	 *
1131:                	 * PreCondition:    None
1132:                	 *
1133:                	 * Input:		the desired DMA suspended state.
1134:                	 *
1135:                	 * Output:          None
1136:                	 *
1137:                	 * Side Effects:    None
1138:                	 *
1139:                	 * Overview:		The function restores the DMA controller activity to the old suspended mode.
1140:                	 *
1141:                	 * Note:            None.
1142:                	 *
1143:                	 * Example:			int isSusp=DmaSuspend(); {....}; DmaResume(isSusp);
1144:                	 ********************************************************************/
1145:                        extern __inline__ void __attribute__((always_inline)) DmaResume(int susp)
1146:                	{
1147:                		if(susp)
9D0049F8  8FC20044   LW V0, 68(S8)
9D0049FC  10400013   BEQ V0, ZERO, 0x9D004A4C
9D004A00  00000000   NOP
9D004BA8  8FC20064   LW V0, 100(S8)
9D004BAC  10400013   BEQ V0, ZERO, 0x9D004BFC
9D004BB0  00000000   NOP
1148:                		{
1149:                			DmaSuspend();
1150:                		}
1151:                		else
1152:                		{
1153:                			DMACONCLR=_DMACON_SUSPEND_MASK;		// resume DMA activity
9D004A4C  3C02BF88   LUI V0, -16504
9D004A50  24031000   ADDIU V1, ZERO, 4096
9D004A54  AC433004   SW V1, 12292(V0)
9D004BFC  3C02BF88   LUI V0, -16504
9D004C00  24031000   ADDIU V1, ZERO, 4096
9D004C04  AC433004   SW V1, 12292(V0)
1154:                		}
1155:                	}
1156:                
1157:                	/*********************************************************************
1158:                	 * Function:        void DmaGetStatus(DmaStatus* pStat)
1159:                	 *
1160:                	 * PreCondition:    pStat	- valid pointer
1161:                	 *
1162:                	 * Input:			pStat	- pointer to a DmaStatus structure to store the current DMA controller
1163:                	 * 							status, carrying the following info:
1164:                	 * 								- chn:	the last active DMA channel
1165:                	 * 								- rdOp: the last DMA operation, read/write
1166:                	 * 								- lastAddress: the most recent DMA address
1167:                	 *
1168:                	 * Output:          None
1169:                	 *
1170:                	 * Side Effects:    None
1171:                	 *
1172:                	 * Overview:		The function updates the info for the current DMA controller status.
1173:                	 * 					It updates the last DMA: operation, channel used and address.
1174:                	 *
1175:                	 * Note:            None.
1176:                	 *
1177:                	 * Example:			DmaStatus stat; DmaGetStatus(&stat);
1178:                	 ********************************************************************/
1179:                	 void			DmaGetStatus(DmaStatus* pStat);
1180:                
1181:                	/*********************************************************************
1182:                	 * Function:        void DmaSetGlobalFlags(DmaGlblFlags gFlags)
1183:                	 *
1184:                	 * PreCondition:    None
1185:                	 *
1186:                	 * Input:           gFlags - flags to be set, having the following fields:
1187:                	 * 			- DMA_GFLG_SUSPEND: DMA controller operation suspend
1188:                	 * 			- DMA_GFLG_ON: DMA controller enabled/desabled
1189:                	 * 			- DMA_GFLG_ALL_FLAGS: all flags
1190:                	 *
1191:                	 * Output:          None
1192:                	 *
1193:                	 * Side Effects:    None
1194:                	 *
1195:                	 * Overview:        The function affects the global behavior of the DMA controller.
1196:                	 *                  It sets the specified flags. Any flag that is set in the gFlags will be
1197:                	 *                  enabled, the other flags won't be touched.
1198:                	 *
1199:                	 * Note:            None.
1200:                	 *
1201:                	 * Example:         DmaSetGlobalFlags(DMA_GFLG_ON);
1202:                	 ********************************************************************/
1203:                        extern __inline__ void __attribute__((always_inline)) DmaSetGlobalFlags(DmaGlblFlags gFlags)
1204:                	{
1205:                		DMACONSET=gFlags;
1206:                	}
1207:                
1208:                	/*********************************************************************
1209:                	 * Function:        void DmaClrGlobalFlags(DmaGlblFlags gFlags)
1210:                	 *
1211:                	 * PreCondition:    None
1212:                	 *
1213:                	 * Input:           gFlags - flags to be cleared, having the following fields:
1214:                	 *                               - DMA_GFLG_SUSPEND: DMA controller operation suspend
1215:                	 *                               - DMA_GFLG_ON: DMA controller enabled/desabled
1216:                	 *                               - DMA_GFLG_ALL_FLAGS: all flags
1217:                	 *
1218:                	 * Output:          None
1219:                	 *
1220:                	 * Side Effects:    None
1221:                	 *
1222:                	 * Overview:        The function affects the global behavior of the DMA controller.
1223:                	 *                  It clears the specified flags. Any flag that is set in the gFlags will be
1224:                	 *                  cleared, the other flags won't be touched.
1225:                	 *
1226:                	 * Note:            None.
1227:                	 *
1228:                	 * Example:         DmaClrGlobalFlags(DMA_GFLG_SUSPEND);
1229:                	 ********************************************************************/
1230:                        extern __inline__ void __attribute__((always_inline)) DmaClrGlobalFlags(DmaGlblFlags gFlags)
1231:                	{
1232:                		DMACONCLR=gFlags;
1233:                	}
1234:                
1235:                
1236:                	/*********************************************************************
1237:                	 * Function:        void DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1238:                	 *
1239:                	 * PreCondition:    None
1240:                	 *
1241:                	 * Input:           gFlags - flags to be set, having the following fields:
1242:                	 *                                 - DMA_GFLG_SUSPEND: DMA controller operation suspend
1243:                	 *                                 - DMA_GFLG_ON: DMA controller enabled/desabled
1244:                	 *                                 - DMA_GFLG_ALL_FLAGS: all flags
1245:                	 *
1246:                	 * Output:          None
1247:                	 *
1248:                	 * Side Effects:    None
1249:                	 *
1250:                	 * Overview:        The function affects the global behavior of the DMA controller.
1251:                	 *                  It forces the flags to have the specified gFlags value.
1252:                	 *
1253:                	 * Note:            None.
1254:                	 *
1255:                	 * Example:         DmaWriteGlobalFlags(DMA_GFLG_ALL_FLAGS);
1256:                	 ********************************************************************/
1257:                        extern __inline__ void __attribute__((always_inline)) DmaWriteGlobalFlags(DmaGlblFlags gFlags)
1258:                	{
1259:                		DMACON=gFlags;
1260:                	}
1261:                
1262:                	/*********************************************************************
1263:                	 * Function:        DmaGlblFlags DmaGetGlobalFlags(void)
1264:                	 *
1265:                	 * PreCondition:    None
1266:                	 *
1267:                	 * Input:           None
1268:                	 *
1269:                	 * Output:          The current DMA controller flags settings.
1270:                	 *                              - DMA_GFLG_SUSPEND: DMA controller operation suspend
1271:                	 *                              - DMA_GFLG_ON: DMA controller enabled/desabled
1272:                	 *
1273:                	 * Side Effects:    None
1274:                	 *
1275:                	 * Overview:        The function returns the global flags of the DMA controller.
1276:                	 *
1277:                	 * Note:            None.
1278:                	 *
1279:                	 * Example:         DmaGlblFlags dmaFlags=DmaGetGlobalFlags();
1280:                	 ********************************************************************/
1281:                        extern __inline__ DmaGlblFlags __attribute__((always_inline)) DmaGetGlobalFlags(void)
1282:                	{
1283:                		return (DmaGlblFlags)DMACON;
1284:                	}
1285:                
1286:                
1287:                	/*********************************************************************
1288:                	 * Function:        int DmaGetMaxTxferSize(void)
1289:                	 *
1290:                	 * PreCondition:    None
1291:                	 *
1292:                	 * Input:           None
1293:                	 *
1294:                	 * Output:          The maximum transfer capacity for a DMA channel, in bytes.
1295:                	 *
1296:                	 * Side Effects:    None
1297:                	 *
1298:                	 * Overview:        The function returns the maximum number of bytes that can be transferred by a DMA channel.
1299:                	 *
1300:                	 * Note:            Revision dependant.
1301:                	 *
1302:                	 * Example:         int dmaMaxSz=DmaGetMaxTxferSize();
1303:                	 ********************************************************************/
1304:                	extern __inline__ int __attribute__((always_inline)) DmaGetMaxTxferSize(void)
1305:                	{
1306:                		return 65536;
1307:                	}
1308:                
1309:                	// Direct Channel control functions
1310:                
1311:                	typedef enum
1312:                	{
1313:                		DMA_CONFIG_DEFAULT = 0,                             // DMA default operation
1314:                		DMA_CONFIG_AUTO	= _DCH0CON_CHAEN_MASK,              // DMA channel is auto enabled
1315:                		DMA_CONFIG_CHAIN_LOW  = (_DCH0CON_CHCHN_MASK|_DCH0CON_CHCHNS_MASK),	// DMA channel is chained to lower channel
1316:                		DMA_CONFIG_CHAIN_HI  = (_DCH0CON_CHCHN_MASK),		// DMA channel is chained to higher channel
1317:                		DMA_CONFIG_DET_EN = _DCH0CON_CHAED_MASK,			// events detection enabled while channel off
1318:                		DMA_CONFIG_ENABLE = _DCH0CON_CHEN_MASK,	            // DMA channel is enabled after open
1319:                		DMA_CONFIG_MATCH	= 0x80000000,                   // DMA channel stops on match
1320:                	}DmaConfigFlags;	// flags for the channel configuration
1321:                
1322:                
1323:                
1324:                	/*********************************************************************
1325:                	 * Function:        void DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags)
1326:                	 *
1327:                	 * PreCondition:    chPri  - valid channel priority, 0-3
1328:                	 *
1329:                	 * Input:           chn    - channel to be configured in the DMA controller
1330:                	 *                  chPri  - the priority given to the channel, 0-3
1331:                	 *                  cFlags - orred flags specifying the configuration:
1332:                	 *                           DMA_CONFIG_DEFAULT: DMA default operation mode
1333:                	 *                           DMA_CONFIG_AUTO:	DMA channel is auto enabled
1334:                	 *                           DMA_CONFIG_CHAIN_LOW: DMA channel is chained to lower channel
1335:                	 *                           DMA_CONFIG_CHAIN_HI: DMA channel is chained to higher channel
1336:                	 *                           DMA_CONFIG_DET_EN: events detection enabled while channel off
1337:                	 *                           DMA_CONFIG_ENABLE: DMA channel is enabled when opened
1338:                	 *                           DMA_CONFIG_MATCH:	DMA channel stops on match
1339:                	 *
1340:                	 *
1341:                	 *
1342:                	 * Output:          None
1343:                	 *
1344:                	 * Side Effects:    None
1345:                	 *
1346:                	 * Overview:        The function configures the selected DMA channel using the supplied user flags and priority.
1347:                	 *
1348:                	 * Note:            - The channel is NOT turned off. It should be turned off before calling this function.
1349:                	 *                  The channel is just configured.
1350:                	 *                  - After calling this function, the channel should be enabled using DmaChnEnable(chn) call
1351:                	 *                  if DMA_CONFIG_ENABLE flag was not specified.
1352:                	 *                  - The function does not touch the interrupt flags, interrupt enables, etc.
1353:                	 *                  The interrupt flags should have been previously cleared and interrupts disabled before calling this function.
1354:                	 *                  - The start and abort Irqs, the channel event enable flags are not touched/cleared by this function.
1355:                	 *                  User has to call event channel functions to clear/enable the event flags if needed.
1356:                	 *
1357:                	 * Example:         DmaChnDisable(DMA_CHANNEL2); DmaChnConfigure(DMA_CHANNEL2, DMA_CHN_PRI2, DMA_CONFIG_AUTO|DMA_CONFIG_MATCH|DMA_CONFIG_ENABLE);
1358:                	 ********************************************************************/
1359:                	void			DmaChnConfigure(DmaChannel chn, DmaChannelPri chPri, DmaConfigFlags cFlags);
1360:                
1361:                
1362:                	/*********************************************************************
1363:                	 * Function:        int DmaChnGetSrcPnt(DmaChannel chn)
1364:                	 *
1365:                	 * PreCondition:    chn	- valid DMA channel
1366:                	 *
1367:                	 * Input:			chn		- DMA channel number
1368:                	 *
1369:                	 * Output:          Current channel source pointer.
1370:                	 *
1371:                	 * Side Effects:    None
1372:                	 *
1373:                	 * Overview:		The function retrieves the current source pointer for the selected DMA channel.
1374:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the source transfer buffer.
1375:                	 *
1376:                	 * Note:            None
1377:                	 *
1378:                	 * Example:         int srcPnt=DmaChnGetSrcPnt(DMA_CHANNEL3);
1379:                	 ********************************************************************/
1380:                	 int			DmaChnGetSrcPnt(DmaChannel chn);
1381:                
1382:                	/*********************************************************************
1383:                	 * Function:        int DmaChnGetDstPnt(DmaChannel chn)
1384:                	 *
1385:                	 * PreCondition:    chn	- valid DMA channel
1386:                	 *
1387:                	 * Input:			chn		- DMA channel number
1388:                	 *
1389:                	 * Output:          Current channel destination pointer.
1390:                	 *
1391:                	 * Side Effects:    None
1392:                	 *
1393:                	 * Overview:		The function retrieves the current destination pointer for the selected DMA channel.
1394:                	 * 					It is the current offset, 0 to DmaGetMaxTxferSize()-1, in the destination transfer buffer.
1395:                	 *
1396:                	 * Note:            None
1397:                	 *
1398:                	 * Example:			int dstPnt=DmaChnGetDstPnt(DMA_CHANNEL3);
1399:                	 ********************************************************************/
1400:                	 int			DmaChnGetDstPnt(DmaChannel chn);
1401:                
1402:                	/*********************************************************************
1403:                	 * Function:        int DmaChnGetCellPnt(DmaChannel chn)
1404:                	 *
1405:                	 * PreCondition:    chn	- valid DMA channel
1406:                	 *
1407:                	 * Input:			chn		- DMA channel number
1408:                	 *
1409:                	 * Output:          Current channel transfer pointer.
1410:                	 *
1411:                	 * Side Effects:    None
1412:                	 *
1413:                	 * Overview:		The function retrieves the current transfer progress pointer for the selected DMA channel.
1414:                	 * 					It ranges 0 to DmaGetMaxTxferSize()-1.
1415:                	 *
1416:                	 * Note:            None
1417:                	 *
1418:                	 * Example:			int cellPnt=DmaChnGetCellPnt(DMA_CHANNEL3);
1419:                	 ********************************************************************/
1420:                	 int			DmaChnGetCellPnt(DmaChannel chn);
1421:                
1422:                
1423:                
1424:                	/*********************************************************************
1425:                	 * Function:        void DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1426:                	 *
1427:                	 * PreCondition:    chn	- valid DMA channel
1428:                	 *
1429:                	 * Input:			chn			- DMA channel number
1430:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1431:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1432:                	 * 										- SIRQEN: enable/disable the start IRQ action
1433:                	 * 										- PATEN: enable/disable the pattern match and abort
1434:                	 * 									or any of the DmaEvCtrlFlags:
1435:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1436:                	 *
1437:                	 *
1438:                	 * Output:          None
1439:                	 *
1440:                	 * Side Effects:    None
1441:                	 *
1442:                	 * Overview:		The function sets the events that start and abort the transfer
1443:                	 * 					for the selected DMA channel.
1444:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1445:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1446:                	 *
1447:                	 * Note:            None.
1448:                	 *
1449:                	 * Example:			either:
1450:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN;
1451:                	 * 					or:
1452:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.SIRQEN=1;
1453:                	 * 						DmaChnSetEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1454:                	 *
1455:                	 ********************************************************************/
1456:                	 void			DmaChnSetEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1457:                
1458:                
1459:                	/*********************************************************************
1460:                	 * Function:        void DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1461:                	 *
1462:                	 * PreCondition:    chn	- valid DMA channel
1463:                	 *
1464:                	 * Input:			chn			- DMA channel number
1465:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1466:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1467:                	 * 										- SIRQEN: enable/disable the start IRQ action
1468:                	 * 										- PATEN: enable/disable the pattern match and abort
1469:                	 * 									or any of the DmaEvCtrlFlags:
1470:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN
1471:                	 *
1472:                	 *
1473:                	 * Output:          None
1474:                	 *
1475:                	 * Side Effects:    None
1476:                	 *
1477:                	 * Overview:		The function clears the events that start and abort the transfer
1478:                	 * 					for the selected DMA channel.
1479:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1480:                	 * 					disabled for the selected channel, the other channel event flags won't be touched.
1481:                	 *
1482:                	 * Note:            None.
1483:                	 *
1484:                	 * Example:			either:
1485:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ_EN);
1486:                	 * 					or:
1487:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.PATEN=1; evCtrl.AIRQEN=1;
1488:                	 * 						DmaChnClrEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1489:                	 *
1490:                	 ********************************************************************/
1491:                	 void			DmaChnClrEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1492:                
1493:                
1494:                
1495:                	/*********************************************************************
1496:                	 * Function:        void DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1497:                	 *
1498:                	 * PreCondition:    chn	- valid DMA channel
1499:                	 *
1500:                	 * Input:			chn			- DMA channel number
1501:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1502:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1503:                	 * 										- SIRQEN: enable/disable the start IRQ action
1504:                	 * 										- PATEN: enable/disable the pattern match and abort
1505:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1506:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1507:                	 * 									or any of the DmaEvCtrlFlags:
1508:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1509:                	 *
1510:                	 *
1511:                	 * Output:          None
1512:                	 *
1513:                	 * Side Effects:    None
1514:                	 *
1515:                	 * Overview:		The function writes the events that start and abort the transfer
1516:                	 * 					for the selected DMA channel.
1517:                	 *
1518:                	 * Note:            None.
1519:                	 *
1520:                	 * Example:			either:
1521:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1522:                	 * 					or:
1523:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1524:                	 * 						DmaChnWriteEventControlFlags(DMA_CHANNEL3, evCtrl.w);
1525:                	 *
1526:                	 ********************************************************************/
1527:                	 void			DmaChnWriteEventControlFlags(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl);
1528:                
1529:                
1530:                
1531:                	/*********************************************************************
1532:                	 * Function:        void DmaChnSetEventControl(DmaChannel chn, DmaEvCtrlFlags dmaEvCtrl)
1533:                	 *
1534:                	 * PreCondition:    chn	- valid DMA channel
1535:                	 *
1536:                	 * Input:			chn			- DMA channel number
1537:                	 * 					dmaEvCtrl	- 	either a DmaEvCtrl structure field, carrying the following info:
1538:                	 * 										- AIRQEN: enable/disable the abort IRQ action
1539:                	 * 										- SIRQEN: enable/disable the start IRQ action
1540:                	 * 										- PATEN: enable/disable the pattern match and abort
1541:                	 * 										- CHSIRQ: IRQ number to start the DMA channel transfer
1542:                	 * 										- CHAIRQ: IRQ number to abort the DMA channel transfer
1543:                	 * 									or any of the DmaEvCtrlFlags:
1544:                	 * 										DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1545:                	 *
1546:                	 *
1547:                	 * Output:          None
1548:                	 *
1549:                	 * Side Effects:    None
1550:                	 *
1551:                	 * Overview:		The function sets the events that start and abort the transfer
1552:                	 * 					for the selected DMA channel.
1553:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
1554:                	 * 					enabled for the selected channel, the other channel event flags won't be touched.
1555:                	 *
1556:                	 * Note:           A shorter name for DmaChnWriteEventControlFlags();
1557:                	 *
1558:                	 * Example:			either:
1559:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, DMA_EV_MATCH_EN|DMA_EV_START_IRQ(_UART2_RX_IRQ));
1560:                	 * 					or:
1561:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=0; evCtrl.AIRQEN=1; evCtrl.PATEN=1; evCtrl.CHSIRQ=_UART2_RX_IRQ;
1562:                	 * 						DmaChnSetEventControl(DMA_CHANNEL3, evCtrl.w);
1563:                	 *
1564:                	 ********************************************************************/
1565:                	#define			DmaChnSetEventControl(chn, dmaEvCtrl)	DmaChnWriteEventControlFlags(chn, dmaEvCtrl)
1566:                
1567:                
1568:                	/*********************************************************************
1569:                	 * Function:        DmaEvCtrlFlags DmaChnGetEventControl(DmaChannel chn)
1570:                	 *
1571:                	 * PreCondition:    chn	- valid DMA channel
1572:                	 *
1573:                	 * Input:			chn		- DMA channel number
1574:                	 *
1575:                	 * Output:          - 	either a DmaEvCtrl structure field, carrying the following info:
1576:                	 * 							- AIRQEN: enable/disable the abort IRQ action
1577:                	 * 							- SIRQEN: enable/disable the start IRQ action
1578:                	 * 							- PATEN: enable/disable the pattern match and abort
1579:                	 * 							- CHSIRQ: IRQ number to start the DMA channel transfer
1580:                	 * 							- CHAIRQ: IRQ number to abort the DMA channel transfer
1581:                	 * 						or any of the DmaEvCtrlFlags:
1582:                	 * 							DMA_EV_ABORT_IRQ_EN|DMA_EV_START_IRQ_EN|DMA_EV_MATCH_EN|DMA_EV_START_IRQ(irq)|DMA_EV_ABORT_IRQ(irq)
1583:                	 *
1584:                	 *
1585:                	 * Side Effects:    None
1586:                	 *
1587:                	 * Overview:		The function retrieves the events that start and abort the transfer
1588:                	 * 					for the selected DMA channel.
1589:                	 *
1590:                	 * Note:            None.
1591:                	 *
1592:                	 * Example:			either:
1593:                	 * 						DmaEvCtrlFlags evCtrlW=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrlW&DMA_EV_MATCH_EN) {...}
1594:                	 * 					or:
1595:                	 * 						DmaEvCtrl evCtrl; evCtrl.w=DmaChnGetEventControl(DMA_CHANNEL3); if(evCtrl.PATEN){...}
1596:                	 *
1597:                	 ********************************************************************/
1598:                	 DmaEvCtrlFlags	DmaChnGetEventControl(DmaChannel chn);
1599:                
1600:                
1601:                	/*********************************************************************
1602:                	 * Function:        void DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1603:                	 *
1604:                	 * PreCondition:    chn	- valid DMA channel
1605:                	 *
1606:                	 * Input:			chn			- DMA channel number
1607:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1608:                	 * 										- autoEn: enable/disable the automatic mode
1609:                	 * 										- chainEn: enable/disable channel chaining
1610:                	 * 										- detectEn: enable/disable events detection when channel disabled
1611:                	 * 										- chEn: enable/disable channel functionality
1612:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1613:                	 * 									or any of the DmaChnCtrlFlags flags:
1614:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1615:                	 *
1616:                	 * Output:          None
1617:                	 *
1618:                	 * Side Effects:    None
1619:                	 *
1620:                	 * Overview:		The function sets the selected DMA channel control flags:
1621:                	 * 					the chaining or auto mode, and events detection.
1622:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1623:                	 * 					set for the selected channel, the other channel control flags won't be touched.
1624:                	 *
1625:                	 * Note:            None.
1626:                	 *
1627:                	 * Example:			either:
1628:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1629:                	 * 					or:
1630:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1631:                	 * 						DmaChnSetControlFlags(DMA_CHANNEL3, chCtrl.w);
1632:                	 *
1633:                	 ********************************************************************/
1634:                	 void			DmaChnSetControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1635:                
1636:                	/*********************************************************************
1637:                	 * Function:        void DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1638:                	 *
1639:                	 * PreCondition:    chn	- valid DMA channel
1640:                	 *
1641:                	 * Input:			chn			- DMA channel number
1642:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1643:                	 * 										- autoEn: enable/disable the automatic mode
1644:                	 * 										- chainEn: enable/disable channel chaining
1645:                	 * 										- detectEn: enable/disable events detection when channel disabled
1646:                	 * 										- chEn: enable/disable channel functionality
1647:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1648:                	 * 									or any of the DmaChnCtrlFlags flags:
1649:                	 * 										DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1650:                	 *
1651:                	 * Output:          None
1652:                	 *
1653:                	 * Side Effects:    None
1654:                	 *
1655:                	 * Overview:		The function clears the selected DMA channel control flags:
1656:                	 * 					the chaining or auto mode and events detection.
1657:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the dmaChnCtrl will be
1658:                	 * 					cleared for the selected channel, the other channel control flags won't be touched.
1659:                	 *
1660:                	 * Note:            None.
1661:                	 *
1662:                	 * Example:			either:
1663:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1664:                	 * 					or:
1665:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.autoEn=1; chCtrl.chainEn=1;
1666:                	 * 						DmaChnClrControlFlags(DMA_CHANNEL3, chCtrl.w);
1667:                	 *
1668:                	 ********************************************************************/
1669:                	 void			DmaChnClrControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1670:                
1671:                	/*********************************************************************
1672:                	 * Function:        void DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1673:                	 *
1674:                	 * PreCondition:    chn	- valid DMA channel
1675:                	 *
1676:                	 * Input:			chn			- DMA channel number
1677:                	 * 					dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1678:                	 * 										- chPri: channel priority 0-3
1679:                	 * 										- autoEn: enable/disable the automatic mode
1680:                	 * 										- chainEn: enable/disable channel chaining
1681:                	 * 										- detectEn: enable/disable events detection when channel disabled
1682:                	 * 										- chEn: enable/disable channel functionality
1683:                	 * 										- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1684:                	 * 									or any of the DmaChnCtrlFlags flags:
1685:                	 * 										DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1686:                	 *
1687:                	 * Output:          None
1688:                	 *
1689:                	 * Side Effects:    None
1690:                	 *
1691:                	 * Overview:		The function enables/disables the selected DMA channel and also sets
1692:                	 * 					the channel priority, chaining mode or auto and events detection.
1693:                	 *
1694:                	 * Note:            None.
1695:                	 *
1696:                	 * Example:			either:
1697:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1698:                	 * 					or:
1699:                	 * 						DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1700:                	 * 						DmaChnWriteControlFlags(DMA_CHANNEL3, chCtrl.w);
1701:                	 *
1702:                	 ********************************************************************/
1703:                	 void			DmaChnWriteControlFlags(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl);
1704:                
1705:                	/*********************************************************************
1706:                	 * Function:        void DmaChnSetControl(DmaChannel chn, DmaChnCtrlFlags dmaChnCtrl)
1707:                	 *
1708:                	 * PreCondition:    chn	- valid DMA channel
1709:                	 *
1710:                	 * Input:	    chn		- DMA channel number
1711:                	 *                  dmaChnCtrl	- 	either a DmaChnCtrl structure field, carrying the following info:
1712:                	 * 						- chPri: channel priority 0-3
1713:                	 * 						- autoEn: enable/disable the automatic mode
1714:                	 * 						- chainEn: enable/disable channel chaining
1715:                	 * 						- detectEn: enable/disable events detection when channel disabled
1716:                	 * 						- chEn: enable/disable channel functionality
1717:                	 * 						- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1718:                	 * 					or any of the DmaChnCtrlFlags flags:
1719:                	 * 						DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1720:                	 *
1721:                	 * Output:          None
1722:                	 *
1723:                	 * Side Effects:    None
1724:                	 *
1725:                	 * Overview:        The function enables/disables the selected DMA channel and also sets
1726:                	 * 					the channel priority, chaining mode or auto and events detection.
1727:                	 *
1728:                	 * Note:            Another name ( backward compatible) for DmaChnWriteControlFlags().
1729:                	 *
1730:                	 * Example:         either:
1731:                	 *                      DmaChnSetControl(DMA_CHANNEL3, DMA_CTL_PRI(DMA_CHN_PRI2)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN);
1732:                	 *                  or:
1733:                	 *                     	DmaChnCtrl chCtrl; chCtrl.w=0; chCtrl.chPri=DMA_CHN_PRI2; chCtrl.autoEn=1; chCtrl.chainEn=1;
1734:                	 * 			DmaChnSetControl(DMA_CHANNEL3, chCtrl.w);
1735:                	 *
1736:                	 ********************************************************************/
1737:                	#define		DmaChnSetControl(chn, dmaChnCtrl)	DmaChnWriteControlFlags(chn, dmaChnCtrl)
1738:                
1739:                	/*********************************************************************
1740:                	 * Function:        DmaChnCtrlFlags DmaChnGetControlFlags(DmaChannel chn)
1741:                	 *
1742:                	 * PreCondition:    chn	- valid DMA channel
1743:                	 *
1744:                	 * Input:			chn			- DMA channel number
1745:                	 *
1746:                	 * Output:          - either a DmaChnCtrl structure field, carrying the following info:
1747:                	 * 							- chPri: channel priority 0-3
1748:                	 * 							- autoEn: enable/disable the automatic mode
1749:                	 * 							- chainEn: enable/disable channel chaining
1750:                	 * 							- detectEn: enable/disable events detection when channel disabled
1751:                	 * 							- chEn: enable/disable channel functionality
1752:                	 * 							- chainDir:	chain direction: chain to lower(1)/higher(0),pri channel
1753:                	 *						or any of the DmaChnCtrlFlags flags:
1754:                	 *							DMA_CTL_PRI(pri)|DMA_CTL_AUTO_EN|DMA_CTL_CHAIN_EN|DMA_CTL_DET_EN|DMA_CTL_CHN_EN|DMA_CTL_CHAIN_DIR
1755:                	 *
1756:                	 * Side Effects:    None
1757:                	 *
1758:                	 * Overview:		The function retrieves the current control settings for the selected DMA channel,
1759:                	 * 					including the channel enable/disable status, the channel priority,
1760:                	 * 					chaining mode, auto mode and events detection.
1761:                	 *
1762:                	 * Note:            None.
1763:                	 *
1764:                	 * Example:			either:
1765:                	 * 						DmaChnCtrlFlags ctrl=DmaChnGetControlFlags(DMA_CHANNEL3); if(ctrl&DMA_CTL_AUTO_EN) {...}
1766:                	 * 					or:
1767:                	 * 						DmaChnCtrl chnCtrl; chnCtrl.w=DmaChnGetControlFlags(DMA_CHANNEL3); if(chnCtrl.autoEn) {...}
1768:                	 *
1769:                	 ********************************************************************/
1770:                	 DmaChnCtrlFlags	DmaChnGetControlFlags(DmaChannel chn);
1771:                
1772:                
1773:                	/*********************************************************************
1774:                	 * Function:        int DmaChnGetEvDetect(DmaChannel chn)
1775:                	 *
1776:                	 * PreCondition:    chn	- valid DMA channel
1777:                	 *
1778:                	 * Input:			chn		- DMA channel number
1779:                	 *
1780:                	 * Output:          TRUE if an DMA event was detected, FALSE otherwise.
1781:                	 *
1782:                	 * Side Effects:    None
1783:                	 *
1784:                	 * Overview:		The function returns the current event detection for the selected DMA channel.
1785:                	 *
1786:                	 * Note:            None.
1787:                	 *
1788:                	 * Example:			int evDetect=DmaChnGetEvDetect(DMA_CHANNEL3);
1789:                	 *
1790:                	 ********************************************************************/
1791:                	 int			DmaChnGetEvDetect(DmaChannel chn);
1792:                
1793:                	/*********************************************************************
1794:                	 * Function:        void DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0)
1795:                	 *
1796:                	 * PreCondition:    chn		- valid DMA channel
1797:                	 * 					pTxCtrl	- valid pointer
1798:                	 *
1799:                	 * Input:			chn			- DMA channel number
1800:                	 * 					pTxCtrl		- pointer to a DmaTxferCtrl that will carry the following info:
1801:                	 * 								- vSrcAdd: source of the DMA transfer
1802:                	 * 								- vDstAdd: destination of the DMA transfer
1803:                	 * 								- srcSize: source buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped arround
1804:                	 * 								- dstSize: destination buffer size, 1 to DmaGetMaxTxferSize() bytes, wrapped around
1805:                	 * 								- cellSize: cell transfer size, 1 to DmaGetMaxTxferSize() bytes.
1806:                	 *					mapToK0		- if TRUE, a Kernel address is mapped to KSeg0, else KSeg1.
1807:                	 *
1808:                	 * Output:          None
1809:                	 *
1810:                	 * Side Effects:    None
1811:                	 *
1812:                	 * Overview:		The function retrieves the transfer characteristics for a DMA channel transfer:
1813:                	 * 					the source and the destination addresses.
1814:                	 * 					It also retrieves the source and destination lengths
1815:                	 * 					and the number of bytes	transferred per event.
1816:                	 *
1817:                	 * Note:            None
1818:                	 *
1819:                	 * Example:			DmaTxferCtrl txCtl; DmaChnGetTxfer(DMA_CHANNEL3, &txCtl, FALSE);
1820:                	 ********************************************************************/
1821:                	 void			DmaChnGetTxfer(DmaChannel chn, DmaTxferCtrl* pTxCtrl, int mapToK0);
1822:                
1823:                	// Low level checksum functions
1824:                
1825:                	/*********************************************************************
1826:                	 * Function:        void DmaSfmEnable(int enable)
1827:                	 *
1828:                	 * PreCondition:    None
1829:                	 *
1830:                	 * Input:           enable _ boolean to enable/disable the SFM functionality
1831:                	 *
1832:                	 * Output:          None
1833:                	 *
1834:                	 * Side Effects:    None
1835:                	 *
1836:                	 * Overview:        The function enables/diables the checksum module functionality.
1837:                	 *                  When enabled the attached DMA channel transfers are routed to the SFM module.
1838:                	 *
1839:                	 * Note:            The SFM module should be properly configured before enabled.
1840:                	 *
1841:                	 * Example:         DmaSfmEnable(1);
1842:                	 ********************************************************************/
1843:                	extern __inline__ void __attribute__((always_inline)) DmaSfmEnable(int enable)
1844:                	{
1845:                		if(enable)
1846:                		{
1847:                			DCRCCONSET=_DCRCCON_CRCEN_MASK;
1848:                		}
1849:                		else
1850:                		{
1851:                			DCRCCONCLR=_DCRCCON_CRCEN_MASK;
1852:                		}
1853:                	}
1854:                	#define DmaCrcEnable	DmaSfmEnable		// PIC32_3xx backward compatibility
1855:                
1856:                
1857:                	/*********************************************************************
1858:                	 * Function:        int DmaSfmGetEnable(void)
1859:                	 *
1860:                	 * PreCondition:    None
1861:                	 *
1862:                	 * Input:			None
1863:                	 *
1864:                	 * Output:          TRUE, if the SFM module is enabled
1865:                	 * 		    FALSE otherwise
1866:                	 *
1867:                	 * Side Effects:    None
1868:                	 *
1869:                	 * Overview:		The function returns the SFM module enabling status.
1870:                	 *
1871:                	 * Note:            None
1872:                	 *
1873:                	 * Example:	    int isSfmEnabled=DmaSfmGetEnable();
1874:                	 ********************************************************************/
1875:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetEnable(void)
1876:                	{
1877:                		return DCRCCONbits.CRCEN!=0;
1878:                	}
1879:                	#define		DmaCrcGetEnable 	DmaSfmGetEnable		// PIC32_3xx backward compatibility
1880:                
1881:                
1882:                	/*********************************************************************
1883:                	 * Function:        void DmaSfmAppendEnable(int enable)
1884:                	 *
1885:                	 * PreCondition:    None
1886:                	 *
1887:                	 * Input:           enable _ boolean to enable/disable the SFM append mode
1888:                	 *
1889:                	 * Output:          None
1890:                	 *
1891:                	 * Side Effects:    None
1892:                	 *
1893:                	 * Overview:        The function enables the SFM append mode. In this mode, the attached DMA channel reads
1894:                	 *                  the source data but does not write it to the destination address. The data it's just passed
1895:                	 *                  to the checksum generator for CRC/IP checksum calculation.
1896:                	 *                  When the block transfer is completed, the checksum result is written to the
1897:                	 *                  DMA channel destination address.
1898:                	 *
1899:                	 * Note:            The SFM module should be properly configured before enabled.
1900:                	 *
1901:                	 * Example:         DmaSfmAppendModeEnable(TRUE);
1902:                	 ********************************************************************/
1903:                	extern __inline__ void __attribute__((always_inline)) DmaSfmAppendEnable(int enable)
1904:                	{
1905:                		if(enable)
1906:                		{
1907:                			DCRCCONSET=_DCRCCON_CRCAPP_MASK;
1908:                		}
1909:                		else
1910:                		{
1911:                			DCRCCONCLR=_DCRCCON_CRCAPP_MASK;
1912:                		}
1913:                	}
1914:                	#define		DmaCrcAppendModeEnable	DmaSfmAppendEnable	// PIC32_3xx backward compatibility
1915:                
1916:                
1917:                	/*********************************************************************
1918:                	 * Function:        int DmaSfmGetAppendMode(void)
1919:                	 *
1920:                	 * PreCondition:    None
1921:                	 *
1922:                	 * Input:           None
1923:                	 *
1924:                	 * Output:          TRUE, if the SFM append mode is enabled
1925:                	 *                  FALSE otherwise
1926:                	 *
1927:                	 * Side Effects:    None
1928:                	 *
1929:                	 * Overview:        The function returns the SFM module enabling status.
1930:                	 *
1931:                	 * Note:            None
1932:                	 *
1933:                	 * Example:         int isAppendEnabled=DmaSfmGetAppendMode();
1934:                	 ********************************************************************/
1935:                	extern __inline__ int __attribute__((always_inline)) DmaSfmGetAppendMode(void)
1936:                	{
1937:                		return DCRCCONbits.CRCAPP!=0;
1938:                	}
1939:                	#define	DmaCrcGetAppendMode	DmaSfmGetAppendMode		// PIC32_3xx backward compatibility
1940:                
1941:                
1942:                	/*********************************************************************
1943:                	 * Function:        void DmaSfmSetAttach(DmaChannel chn)
1944:                	 *
1945:                	 * PreCondition:    chn		- valid DMA channel
1946:                	 *
1947:                	 * Input:           chn	- the DMA channel to be attached to the SFM module (the DMA channel transfers will be routed to the SFM module)
1948:                	 *
1949:                	 * Output:          None
1950:                	 *
1951:                	 * Side Effects:    None
1952:                	 *
1953:                	 * Overview:        The function directly attaches a DMA channel to the SFM module.
1954:                	 *
1955:                	 * Note:            None
1956:                	 *
1957:                	 * Example:         DmaSfmSetAttach(DMA_CHANNEL3);
1958:                	 ********************************************************************/
1959:                	extern __inline__ void __attribute__((always_inline)) DmaSfmSetAttach(DmaChannel chn)
1960:                	{
1961:                		DCRCCONCLR=_DCRCCON_CRCCH_MASK;
1962:                		DCRCCONSET=chn;
1963:                	}
1964:                	#define		DmaCrcSetAttach		DmaSfmSetAttach		// PIC32_3xx backward compatibility
1965:                
1966:                
1967:                	/*********************************************************************
1968:                	 * Function:        DmaChannel DmaSfmGetAttach(void)
1969:                	 *
1970:                	 * PreCondition:    None
1971:                	 *
1972:                	 * Input:           None
1973:                	 *
1974:                	 * Output:          the DMA channel that is currently attached to the CRC module
1975:                	 *
1976:                	 * Side Effects:    None
1977:                	 *
1978:                	 * Overview:        The function returns the DMA channel number that is currently attached to the SFM module.
1979:                	 *
1980:                	 * Note:            None
1981:                	 *
1982:                	 * Example:         DmaChannel chn=DmaSfmGetAttach();
1983:                	 ********************************************************************/
1984:                	extern __inline__ DmaChannel __attribute__((always_inline)) DmaSfmGetAttach(void)
1985:                	{
1986:                		return (DmaChannel)DCRCCONbits.CRCCH;
1987:                	}
1988:                	#define		DmaCrcGetAttach		DmaSfmGetAttach		// PIC32_3xx backward compatibility
1989:                
1990:                	/*********************************************************************
1991:                	 * Function:        void DmaCrcSetPLen(int pLen)
1992:                	 *
1993:                	 * PreCondition:    pLen - valid polynomial length within 1-32
1994:                	 *
1995:                	 * Input:           pLen	- the length of the CRC generator polynomial
1996:                	 *
1997:                	 * Output:          None
1998:                	 *
1999:                	 * Side Effects:    None
2000:                	 *
2001:                	 * Overview:        The length of the CRC generator polynomial is set as being pLen;
2002:                	 *
2003:                	 * Note:            None
2004:                	 *
2005:                	 * Example:         DmaCrcSetPLen(32);
2006:                	 ********************************************************************/
2007:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetPLen(int pLen)
2008:                	{
2009:                		DCRCCONCLR=_DCRCCON_PLEN_MASK;
2010:                		DCRCCONSET=(pLen)-1;
2011:                	}
2012:                
2013:                	/*********************************************************************
2014:                	 * Function:        int DmaCrcGetPLen(void)
2015:                	 *
2016:                	 * PreCondition:    None
2017:                	 *
2018:                	 * Input:           None
2019:                	 *
2020:                	 * Output:          the length of the CRC generator polynomial
2021:                	 *
2022:                	 * Side Effects:    None
2023:                	 *
2024:                	 * Overview:        The function returns the current length of the CRC generator polynomial.
2025:                	 *                  It's always a number between 1 and 32.
2026:                	 *
2027:                	 * Note:            None
2028:                	 *
2029:                	 * Example:         int polyLen=DmaCrcGetPLen();
2030:                	 ********************************************************************/
2031:                	extern __inline__ int __attribute__((always_inline)) DmaCrcGetPLen(void)
2032:                	{
2033:                		return	DCRCCONbits.PLEN+1; 
2034:                	}
2035:                
2036:                	/*********************************************************************
2037:                	 * Function:        void DmaCrcSetShiftFeedback(unsigned int feedback)
2038:                	 *
2039:                	 * PreCondition:    None
2040:                	 *
2041:                	 * Input:           feedback - the layout of the CRC generator
2042:                	 *
2043:                	 * Output:          None
2044:                	 *
2045:                	 * Side Effects:    None
2046:                	 *
2047:                	 * Overview:        The function sets the layout of the shift stages that take place in the CRC generation.
2048:                	 *                  Setting a bit to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2049:                	 *                  If bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2050:                	 *
2051:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2052:                	 *
2053:                	 * Example:         DmaCrcSetShiftFeedback(0x04c11db7);
2054:                	 ********************************************************************/
2055:                	extern __inline__ void __attribute__((always_inline)) DmaCrcSetShiftFeedback(unsigned int feedback)
2056:                	{
2057:                		DCRCXOR=feedback;
2058:                	}
2059:                
2060:                
2061:                	/*********************************************************************
2062:                	 * Function:        unsigned int DmaCrcGetShiftFeedback(void)
2063:                	 *
2064:                	 * PreCondition:    None
2065:                	 *
2066:                	 * Input:           None
2067:                	 *
2068:                	 * Output:          the current layout of the CRC generator
2069:                	 *
2070:                	 * Side Effects:    None
2071:                	 *
2072:                	 * Overview:        The function returns the layout of the shift stages that take place in the CRC generation.
2073:                	 *                  A bit set to 1 enables the XOR input from the MSb (pLen bit) to the selected stage in the shift register.
2074:                	 *                  If a bit is cleared, the selected shift stage gets data directly from the previous stage in the shift register.
2075:                	 *
2076:                	 * Note:            Bit 0 of the generator polynomial is always XOR'ed.
2077:                	 *
2078:                	 * Example:         int feedback=DmaCrcGetShiftFeedback();
2079:                	 ********************************************************************/
2080:                	extern __inline__ unsigned int __attribute__((always_inline)) DmaCrcGetShiftFeedback(void)
2081:                	{
2082:                		return DCRCXOR;
2083:                	}
2084:                
2085:                
2086:                
2087:                	// Channel test/debug and special functions
2088:                
2089:                	/*********************************************************************
2090:                	 * Function:        void DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2091:                	 *
2092:                	 * PreCondition:    chn	- valid DMA channel
2093:                	 *
2094:                	 * Input:			chn		- DMA channel number
2095:                	 * 					eFlags	- event flags with the following significance:
2096:                	 * 								- DMA_EV_ERR: address error event
2097:                	 * 								- DMA_EV_ABORT: transfer abort event
2098:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2099:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2100:                	 * 								- DMA_EV_DST_HALF: destination half event
2101:                	 * 								- DMA_EV_DST_FULL: destination full event
2102:                	 * 								- DMA_EV_SRC_HALF: source half event
2103:                	 * 								- DMA_EV_SRC_FULL: source full event
2104:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2105:                	 *
2106:                	 * Output:          None
2107:                	 *
2108:                	 * Side Effects:    None
2109:                	 *
2110:                	 * Overview:		The function sets the event flags for the selected DMA channel.
2111:                	 * 					Multiple flags can be orr-ed together. Any flag that is set in the eFlags will be
2112:                	 * 					set for the selected channel, the other channel event flags won't be touched.
2113:                	 *
2114:                	 * Note:            This is intended as a channel test function.
2115:                	 *
2116:                	 * Example:			DmaChnSetEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2117:                	 ********************************************************************/
2118:                	 void			DmaChnSetEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2119:                
2120:                	/*********************************************************************
2121:                	 * Function:        void DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags)
2122:                	 *
2123:                	 * PreCondition:    chn	- valid DMA channel
2124:                	 *
2125:                	 * Input:			chn		- DMA channel number
2126:                	 * 					eFlags	- event flags with the following significance:
2127:                	 * 								- DMA_EV_ERR: address error event
2128:                	 * 								- DMA_EV_ABORT: transfer abort event
2129:                	 * 								- DMA_EV_CELL_DONE: cell transfer complete event
2130:                	 * 								- DMA_EV_BLOCK_DONE: block transfer complete event
2131:                	 * 								- DMA_EV_DST_HALF: destination half event
2132:                	 * 								- DMA_EV_DST_FULL: destination full event
2133:                	 * 								- DMA_EV_SRC_HALF: source half event
2134:                	 * 								- DMA_EV_SRC_FULL: source full event
2135:                	 * 								- DMA_EV_ALL_EVNTS: all of the above flags
2136:                	 *
2137:                	 * Output:          None
2138:                	 *
2139:                	 * Side Effects:    None
2140:                	 *
2141:                	 * Overview:		The function writes the event flags for the selected DMA channel.
2142:                	 * 					The channel event flags are forced to the eFlags value.
2143:                	 *
2144:                	 * Note:            This is intended as a channel test function.
2145:                	 *
2146:                	 * Example:			DmaChnWriteEvFlags(DMA_CHANNEL0, DMA_EV_ERR|DMA_EV_ABORT|DMA_EV_BLOCK_DONE|DMA_EV_SRC_FULL);
2147:                	 ********************************************************************/
2148:                	 void			DmaChnWriteEvFlags(DmaChannel chn, DmaEvFlags eFlags);
2149:                
2150:                
2151:                	/********************************************************************
2152:                	 * Include legacy DMA functions
2153:                	 * New projects should not use them!
2154:                	 * Note that interrupt functions are no longer provided.
2155:                	 * The functions in the int.h should be used instead.
2156:                	 ********************************************************************/
2157:                	#ifndef _PLIB_DISABLE_LEGACY
2158:                		#include <peripheral/legacy/dma_legacy.h>
2159:                	#endif
2160:                
2161:                
2162:                #else
2163:                	#undef _DMA_CHANNELS		// no DMA channels
2164:                #endif	// _DMAC0
2165:                
2166:                #endif /*_DMA_H_*/
2167:                
2168:                
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/tick.c  ---------------------------------------
1:                   /******************************************************************************/
2:                   /*                                                                            */
3:                   /* File:   tick.c                                                             */
4:                   /* Author: Matt Bennett                                                       */
5:                   /*                                                                            */
6:                   /* Created on June 13, 2012                                                   */
7:                   /*                                                                            */
8:                   /******************************************************************************/
9:                   
10:                  
11:                  #include <common.h>
12:                  #include <peripheral/timer.h>
13:                  #include <tick.h>
14:                  
15:                  /******************************************************************************/
16:                  /* there are 31536000 seconds in a year. With a 64 bit ms counter, it will    */
17:                  /* take 584 million years for the counter to roll over.                       */
18:                  /******************************************************************************/
19:                  
20:                  TICK_TYPE tick;
21:                  
22:                  /******************************************************************************/
23:                  /* timer interrupt, provides an independent clock for real-time timing        */
24:                  /* purposes                                                                   */
25:                  /******************************************************************************/
26:                  
27:                  void __ISR(_TIMER_4_VECTOR,TICK_INT_PRIORITY_ISR) T4_Interrupt_Handler(void)
28:                  {
9D00521C  415DE800   RDPGPR SP, SP
9D005220  401A7000   MFC0 K0, EPC
9D005224  401B6000   MFC0 K1, Status
9D005228  27BDFF88   ADDIU SP, SP, -120
9D00522C  AFBA0074   SW K0, 116(SP)
9D005230  401A6002   MFC0 K0, SRSCtl
9D005234  AFBB0070   SW K1, 112(SP)
9D005238  AFBA006C   SW K0, 108(SP)
9D00523C  7C1B7844   INS K1, ZERO, 1, 15
9D005240  377B1800   ORI K1, K1, 6144
9D005244  409B6000   MTC0 K1, Status
9D005248  AFBF005C   SW RA, 92(SP)
9D00524C  AFBE0058   SW S8, 88(SP)
9D005250  AFB90054   SW T9, 84(SP)
9D005254  AFB80050   SW T8, 80(SP)
9D005258  AFAF004C   SW T7, 76(SP)
9D00525C  AFAE0048   SW T6, 72(SP)
9D005260  AFAD0044   SW T5, 68(SP)
9D005264  AFAC0040   SW T4, 64(SP)
9D005268  AFAB003C   SW T3, 60(SP)
9D00526C  AFAA0038   SW T2, 56(SP)
9D005270  AFA90034   SW T1, 52(SP)
9D005274  AFA80030   SW T0, 48(SP)
9D005278  AFA7002C   SW A3, 44(SP)
9D00527C  AFA60028   SW A2, 40(SP)
9D005280  AFA50024   SW A1, 36(SP)
9D005284  AFA40020   SW A0, 32(SP)
9D005288  AFA3001C   SW V1, 28(SP)
9D00528C  AFA20018   SW V0, 24(SP)
9D005290  AFA10014   SW AT, 20(SP)
9D005294  00001012   MFLO V0, 0
9D005298  AFA20064   SW V0, 100(SP)
9D00529C  00001810   MFHI V1, 0
9D0052A0  AFA30060   SW V1, 96(SP)
9D0052A4  03A0F021   ADDU S8, SP, ZERO
29:                      INTClearFlag(INT_SOURCE_TIMER(TICK_TIMER));
9D0052A8  2404000B   ADDIU A0, ZERO, 11
9D0052AC  0F4017B7   JAL INTClearFlag
9D0052B0  00000000   NOP
30:                      tick++;
9D0052B4  8F848038   LW A0, -32712(GP)
9D0052B8  8F85803C   LW A1, -32708(GP)
9D0052BC  24060001   ADDIU A2, ZERO, 1
9D0052C0  00003821   ADDU A3, ZERO, ZERO
9D0052C4  00861021   ADDU V0, A0, A2
9D0052C8  0044402B   SLTU T0, V0, A0
9D0052CC  00A71821   ADDU V1, A1, A3
9D0052D0  01032021   ADDU A0, T0, V1
9D0052D4  00801821   ADDU V1, A0, ZERO
9D0052D8  AF828038   SW V0, -32712(GP)
9D0052DC  AF83803C   SW V1, -32708(GP)
31:                  }
9D0052E0  03C0E821   ADDU SP, S8, ZERO
9D0052E4  8FA20064   LW V0, 100(SP)
9D0052E8  00400013   MTLO V0, 0
9D0052EC  8FA30060   LW V1, 96(SP)
9D0052F0  00600011   MTHI V1, 0
9D0052F4  8FBF005C   LW RA, 92(SP)
9D0052F8  8FBE0058   LW S8, 88(SP)
9D0052FC  8FB90054   LW T9, 84(SP)
9D005300  8FB80050   LW T8, 80(SP)
9D005304  8FAF004C   LW T7, 76(SP)
9D005308  8FAE0048   LW T6, 72(SP)
9D00530C  8FAD0044   LW T5, 68(SP)
9D005310  8FAC0040   LW T4, 64(SP)
9D005314  8FAB003C   LW T3, 60(SP)
9D005318  8FAA0038   LW T2, 56(SP)
9D00531C  8FA90034   LW T1, 52(SP)
9D005320  8FA80030   LW T0, 48(SP)
9D005324  8FA7002C   LW A3, 44(SP)
9D005328  8FA60028   LW A2, 40(SP)
9D00532C  8FA50024   LW A1, 36(SP)
9D005330  8FA40020   LW A0, 32(SP)
9D005334  8FA3001C   LW V1, 28(SP)
9D005338  8FA20018   LW V0, 24(SP)
9D00533C  8FA10014   LW AT, 20(SP)
9D005340  41606000   DI ZERO
9D005344  000000C0   EHB
9D005348  8FBA0074   LW K0, 116(SP)
9D00534C  8FBB0070   LW K1, 112(SP)
9D005350  409A7000   MTC0 K0, EPC
9D005354  8FBA006C   LW K0, 108(SP)
9D005358  27BD0078   ADDIU SP, SP, 120
9D00535C  409A6002   MTC0 K0, SRSCtl
9D005360  41DDE800   WRPGPR SP, SP
9D005364  409B6000   MTC0 K1, Status
9D005368  42000018   ERET
32:                  
33:                  /******************************************************************************/
34:                  /* UINT64 TickGet(void)                                                       */
35:                  /* interrupt safe accessor function for the tick variable                     */
36:                  /******************************************************************************/
37:                  
38:                  TICK_TYPE TickGet(void)
39:                  {
9D00536C  27BDFFE0   ADDIU SP, SP, -32
9D005370  AFBF001C   SW RA, 28(SP)
9D005374  AFBE0018   SW S8, 24(SP)
9D005378  03A0F021   ADDU S8, SP, ZERO
40:                      TICK_TYPE returnValue;
41:                      INTEnable(INT_SOURCE_TIMER(TICK_TIMER),INT_DISABLED);
9D00537C  2404000B   ADDIU A0, ZERO, 11
9D005380  00002821   ADDU A1, ZERO, ZERO
9D005384  0F4016DC   JAL INTEnable
9D005388  00000000   NOP
42:                      returnValue=tick;
9D00538C  8F828038   LW V0, -32712(GP)
9D005390  8F83803C   LW V1, -32708(GP)
9D005394  AFC20010   SW V0, 16(S8)
9D005398  AFC30014   SW V1, 20(S8)
43:                      INTEnable(INT_SOURCE_TIMER(TICK_TIMER),INT_ENABLED);
9D00539C  2404000B   ADDIU A0, ZERO, 11
9D0053A0  24050001   ADDIU A1, ZERO, 1
9D0053A4  0F4016DC   JAL INTEnable
9D0053A8  00000000   NOP
44:                      return returnValue;
9D0053AC  8FC20010   LW V0, 16(S8)
9D0053B0  8FC30014   LW V1, 20(S8)
45:                  }
9D0053B4  03C0E821   ADDU SP, S8, ZERO
9D0053B8  8FBF001C   LW RA, 28(SP)
9D0053BC  8FBE0018   LW S8, 24(SP)
9D0053C0  27BD0020   ADDIU SP, SP, 32
9D0053C4  03E00008   JR RA
9D0053C8  00000000   NOP
46:                  
47:                  /******************************************************************************/
48:                  /* void TickInitialize(void)                                                  */
49:                  /******************************************************************************/
50:                  
51:                  void TickInitialize(void)
52:                  {
9D0053CC  27BDFFE8   ADDIU SP, SP, -24
9D0053D0  AFBF0014   SW RA, 20(SP)
9D0053D4  AFBE0010   SW S8, 16(SP)
9D0053D8  03A0F021   ADDU S8, SP, ZERO
53:                      OpenTimer4(
9D0053DC  3C02BF80   LUI V0, -16512
9D0053E0  24030010   ADDIU V1, ZERO, 16
9D0053E4  AC430C00   SW V1, 3072(V0)
9D0053E8  3C02BF80   LUI V0, -16512
9D0053EC  AC400C10   SW ZERO, 3088(V0)
9D0053F0  3C02BF80   LUI V0, -16512
9D0053F4  24032710   ADDIU V1, ZERO, 10000
9D0053F8  AC430C20   SW V1, 3104(V0)
9D0053FC  3C02BF80   LUI V0, -16512
9D005400  34038000   ORI V1, ZERO, -32768
9D005404  AC430C08   SW V1, 3080(V0)
54:                          T4_ON|
55:                          T4_IDLE_CON|
56:                          T4_GATE_OFF|
57:                          TICK_PRESCALER|
58:                          T4_32BIT_MODE_OFF|
59:                          T4_SOURCE_INT,
60:                          TICK_UPDATE_INTERVAL);
61:                      TMR4=0;
9D005408  3C02BF80   LUI V0, -16512
9D00540C  AC400C10   SW ZERO, 3088(V0)
62:                      tick=0;
9D005410  00001021   ADDU V0, ZERO, ZERO
9D005414  00001821   ADDU V1, ZERO, ZERO
9D005418  AF828038   SW V0, -32712(GP)
9D00541C  AF83803C   SW V1, -32708(GP)
63:                      //mTickClearInterruptFlag();
64:                      INTClearFlag(INT_SOURCE_TIMER(TICK_TIMER));
9D005420  2404000B   ADDIU A0, ZERO, 11
9D005424  0F4017B7   JAL INTClearFlag
9D005428  00000000   NOP
65:                      INTSetVectorPriority(INT_VECTOR_TIMER(TICK_TIMER),TICK_INT_PRIORITY);
9D00542C  2404000B   ADDIU A0, ZERO, 11
9D005430  24050006   ADDIU A1, ZERO, 6
9D005434  0F401752   JAL INTSetVectorPriority
9D005438  00000000   NOP
66:                      INTSetVectorSubPriority(INT_VECTOR_I2C(TICK_TIMER),TICK_INT_SUB_PRIORITY);
9D00543C  24040024   ADDIU A0, ZERO, 36
9D005440  24050002   ADDIU A1, ZERO, 2
9D005444  0F401760   JAL INTSetVectorSubPriority
9D005448  00000000   NOP
67:                      INTEnable(INT_SOURCE_TIMER(TICK_TIMER),INT_ENABLED);
9D00544C  2404000B   ADDIU A0, ZERO, 11
9D005450  24050001   ADDIU A1, ZERO, 1
9D005454  0F4016DC   JAL INTEnable
9D005458  00000000   NOP
68:                      //ConfigIntTimer4(T4_INT_ON | TICK_INT_PRIORITY | T4_INT_SUB_PRIOR_1);
69:                  }
9D00545C  03C0E821   ADDU SP, S8, ZERO
9D005460  8FBF0014   LW RA, 20(SP)
9D005464  8FBE0010   LW S8, 16(SP)
9D005468  27BD0018   ADDIU SP, SP, 24
9D00546C  03E00008   JR RA
9D005470  00000000   NOP
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/mainv1p0.c  -----------------------------------
1:                   /******************************************************************************/
2:                   /* File:   mainv1p0.c                                                         */
3:                   /* Author: Matt Bennett                                                       */
4:                   /*                                                                            */
5:                   /* Created on December 16, 2012, 3:51 PM                                      */
6:                   /* Updated August 2013                                                        */
7:                   /******************************************************************************/
8:                   
9:                   #include <common.h>
10:                  #include <system.h>
11:                  #include <osc.h>
12:                  #include <tick.h>
13:                  #include <LED.h>
14:                  #include <PAC1710.h>
15:                  #include <MCP4461.h>
16:                  #include <I2C_Bus_Master.h>
17:                  #include <TRISThis.h>
18:                  #include <configuration.h>
19:                  #include <mainv1p0.h>
20:                  
21:                  /******************************************************************************/
22:                  extern UINT16_VAL currentHolding;
23:                  extern UINT16_VAL voltageHolding;
24:                  /* file scope for DMCI */
25:                  INT16 monitorCurrentReadings[CURRENT_HISTORY_SIZE];
26:                  UINT16 monitorVoltageReadings[VOLTAGE_HISTORY_SIZE];
27:                  
28:                  /******************************************************************************/
29:                  
30:                  int main(void)
31:                  {
9D0045D4  27BDFFC0   ADDIU SP, SP, -64
9D0045D8  AFBF003C   SW RA, 60(SP)
9D0045DC  AFBE0038   SW S8, 56(SP)
9D0045E0  03A0F021   ADDU S8, SP, ZERO
32:                      /* variables local to main()                                              */
33:                      UINT8 dataRead;
34:                      TICK_TYPE timeoutTime;
35:                      I2CBUS_COMMAND_TYPE command;
36:                      UINT16_VAL vSource;
37:                      //INT16 readingHoldingSigned;
38:                      //UINT16 readingHoldingUnsigned;
39:                      /* local to main() and initialized*/
40:                      //int currentIndex=0;
41:                      //int voltageIndex=0;
42:                      #ifdef USE_DIGIPOT
43:                          BOOL digipotGet=TRUE;
9D0045E4  24020001   ADDIU V0, ZERO, 1
9D0045E8  0F4011FB   JAL InitializeSystem
44:                      #endif
45:                      /**************************************************************************/
46:                      InitializeSystem();
9D0045EC  AFC20010   SW V0, 16(S8)
47:                      if(!MasterI2CStartup())
9D0045F0  0F400318   JAL MasterI2CStartup
9D0045F4  00000000   NOP
9D0045F8  1440001B   BNE V0, ZERO, 0x9D004668
9D0045FC  00000000   NOP
48:                      {
49:                          LED1_ON;
9D004600  3C02BF88   LUI V0, -16504
9D004604  24034000   ADDIU V1, ZERO, 16384
9D004608  AC4360E4   SW V1, 24804(V0)
50:                          LED2_OFF;
9D00460C  3C02BF88   LUI V0, -16504
9D004610  34038000   ORI V1, ZERO, -32768
9D004614  AC4360E8   SW V1, 24808(V0)
51:                          LED3_ON;
9D004618  3C02BF88   LUI V0, -16504
9D00461C  24030010   ADDIU V1, ZERO, 16
9D004620  AC436164   SW V1, 24932(V0)
52:                          LED4_OFF;
9D004624  3C02BF88   LUI V0, -16504
9D004628  24030020   ADDIU V1, ZERO, 32
9D00462C  AC436168   SW V1, 24936(V0)
53:                          LED5_ON;
9D004630  3C02BF88   LUI V0, -16504
9D004634  24030008   ADDIU V1, ZERO, 8
9D004638  AC436164   SW V1, 24932(V0)
54:                          LED6_OFF;
9D00463C  3C02BF88   LUI V0, -16504
9D004640  24030004   ADDIU V1, ZERO, 4
9D004644  AC436168   SW V1, 24936(V0)
55:                          LED7_ON;
9D004648  3C02BF88   LUI V0, -16504
9D00464C  24030100   ADDIU V1, ZERO, 256
9D004650  AC436164   SW V1, 24932(V0)
56:                          LED8_OFF;
9D004654  3C02BF88   LUI V0, -16504
9D004658  24032000   ADDIU V1, ZERO, 8192
9D00465C  AC4360E8   SW V1, 24808(V0)
57:                          while(TRUE);
9D004660  0B401198   J 0x9D004660
9D004664  00000000   NOP
58:                      }
59:                      if(!PAC1710SubsystemInitialize(PAC1710_ADDRESS))
9D004668  0F40051F   JAL PAC1710SubsystemInitialize
9D00466C  24040030   ADDIU A0, ZERO, 48
9D004670  1440001B   BNE V0, ZERO, 0x9D0046E0
9D004674  00000000   NOP
60:                      {
61:                          LED1_ON;
9D004678  3C02BF88   LUI V0, -16504
9D00467C  24034000   ADDIU V1, ZERO, 16384
9D004680  AC4360E4   SW V1, 24804(V0)
62:                          LED2_OFF;
9D004684  3C02BF88   LUI V0, -16504
9D004688  34038000   ORI V1, ZERO, -32768
9D00468C  AC4360E8   SW V1, 24808(V0)
63:                          LED3_ON;
9D004690  3C02BF88   LUI V0, -16504
9D004694  24030010   ADDIU V1, ZERO, 16
9D004698  AC436164   SW V1, 24932(V0)
64:                          LED4_OFF;
9D00469C  3C02BF88   LUI V0, -16504
9D0046A0  24030020   ADDIU V1, ZERO, 32
9D0046A4  AC436168   SW V1, 24936(V0)
65:                          LED5_ON;
9D0046A8  3C02BF88   LUI V0, -16504
9D0046AC  24030008   ADDIU V1, ZERO, 8
9D0046B0  AC436164   SW V1, 24932(V0)
66:                          LED6_OFF;
9D0046B4  3C02BF88   LUI V0, -16504
9D0046B8  24030004   ADDIU V1, ZERO, 4
9D0046BC  AC436168   SW V1, 24936(V0)
67:                          LED7_ON;
9D0046C0  3C02BF88   LUI V0, -16504
9D0046C4  24030100   ADDIU V1, ZERO, 256
9D0046C8  AC436164   SW V1, 24932(V0)
68:                          LED8_OFF;
9D0046CC  3C02BF88   LUI V0, -16504
9D0046D0  24032000   ADDIU V1, ZERO, 8192
9D0046D4  AC4360E8   SW V1, 24808(V0)
69:                          while(TRUE);
9D0046D8  0B4011B6   J 0x9D0046D8
9D0046DC  00000000   NOP
70:                      }
71:                      #ifdef USE_DIGIPOT
72:                      DigipotSubsystemInitialize();
9D0046E0  0F400DFB   JAL DigipotSubsystemInitialize
9D0046E4  00000000   NOP
73:                      #endif
74:                      if(!ConfigSPIComms())
9D0046E8  0F4008BA   JAL ConfigSPIComms
9D0046EC  00000000   NOP
9D0046F0  14400003   BNE V0, ZERO, 0x9D004700
9D0046F4  00000000   NOP
75:                      {
76:                          while(TRUE);
9D0046F8  0B4011BE   J 0x9D0046F8
9D0046FC  00000000   NOP
77:                      }
78:                      TRISThisConfigure();
9D004700  0F400B0B   JAL TRISThisConfigure
9D004704  00000000   NOP
79:                      
80:                      mEnableWatchdog();
9D004708  3C02BF80   LUI V0, -16512
9D00470C  34038000   ORI V1, ZERO, -32768
9D004710  0B4011CA   J 0x9D004728
9D004714  AC430008   SW V1, 8(V0)
81:                  
82:                      while(TRUE)
83:                      {
84:                          mClearWatchdog();
9D004728  3C02BF80   LUI V0, -16512
9D00472C  24030001   ADDIU V1, ZERO, 1
9D004730  0F400C54   JAL DoTRISThis
85:                          DoTRISThis();
9D004734  AC430008   SW V1, 8(V0)
86:                          DoPowerMonState();
9D004738  0F4006AA   JAL DoPowerMonState
9D00473C  00000000   NOP
87:                          DoLEDs();
9D004740  0F4013DD   JAL DoLEDs
9D004744  00000000   NOP
88:                          #ifdef USE_DIGIPOT
89:                          DoDigipot();
9D004748  0F400E26   JAL DoDigipot
9D00474C  00000000   NOP
90:                          //DigipotStartReadingAll();
91:                          if(digipotGet)
9D004750  8FC20010   LW V0, 16(S8)
9D004754  10400007   BEQ V0, ZERO, 0x9D004774
9D004758  00000000   NOP
92:                          {
93:                              if(DigipotStartGetStatus())
9D00475C  0F400D5B   JAL DigipotStartGetStatus
9D004760  00000000   NOP
9D004764  1040FFEC   BEQ V0, ZERO, 0x9D004718
9D004768  00000000   NOP
94:                              {
95:                                  digipotGet=FALSE;
9D00476C  0B4011CA   J 0x9D004728
96:                              }
97:                          }
98:                          else
99:                          {
100:                             if(DigipotReadingReady())
9D004774  0F400DA6   JAL DigipotReadingReady
9D004778  00000000   NOP
9D00477C  1040FFE9   BEQ V0, ZERO, 0x9D004724
9D004780  00000000   NOP
101:                             {
102:                                 UINT8 reading;
103:                                 reading=DigipotGetStatus();
9D004784  0F400D73   JAL DigipotGetStatus
9D004788  00000000   NOP
9D00478C  A3C20014   SB V0, 20(S8)
104:                                 Nop();
9D004790  00000040   SSNOP
105:                                 Nop();
9D004794  00000040   SSNOP
106:                                 Nop();
9D004798  00000040   SSNOP
107:                                 Nop();
9D00479C  00000040   SSNOP
108:                                 Nop();
9D0047A0  00000040   SSNOP
109:                                 //if(DigipotGetReading(0,&reading))
110:                                 //{
111:                                 //    Nop();
112:                                 //}
113:                                 //else
114:                                 //{
115:                                 //    Nop();
116:                                 //}
117:                             }
118:                         }
119:                         #endif /* USE_DIGIPOT */
120:                 //        if(PAC1710GetData(PAC1710_DATA_CURRENT,&monitorCurrentReadings[currentIndex]))
121:                 //        {
122:                 //            currentIndex++;
123:                 //            currentIndex%=CURRENT_HISTORY_SIZE;
124:                 //        }
125:                 //        if(PAC1710GetData(PAC1710_DATA_VOLTAGE,&monitorVoltageReadings[voltageIndex]))
126:                 //        {
127:                 //            voltageIndex++;
128:                 //            voltageIndex%=VOLTAGE_HISTORY_SIZE;
129:                 //        }
130:                 //        if(GetCurrentData(PAC1710_ADDRESS,&readingHoldingSigned))
131:                 //        {
132:                 //            monitorCurrentReadings[currentIndex++]=readingHoldingSigned>>4;
133:                 //            if(currentIndex>=100)
134:                 //            {
135:                 //                currentIndex=0;
136:                 //            }
137:                 //        }
138:                 //        if(GetVoltageData(PAC1710_ADDRESS,&readingHoldingUnsigned))
139:                 //        {
140:                 //            monitorVoltageReadings[voltageIndex++]=readingHoldingUnsigned>>5;
141:                 //            if(voltageIndex>=100)
142:                 //            {
143:                 //                voltageIndex=0;
144:                 //            }
145:                 //        }
146:                     }
9D004718  00000000   NOP
9D00471C  0B4011CA   J 0x9D004728
9D004720  00000000   NOP
9D004724  00000000   NOP
9D004770  AFC00010   SW ZERO, 16(S8)
9D0047A4  0B4011CA   J 0x9D004728
9D0047A8  00000000   NOP
147:                 }
148:                 
149:                 void __attribute__ ((interrupt(IPL0SOFT))) _DefaultInterrupt(void)
150:                 {
9D0047AC  415DE800   RDPGPR SP, SP
9D0047B0  401A7000   MFC0 K0, EPC
9D0047B4  401B6000   MFC0 K1, Status
9D0047B8  27BDFFE8   ADDIU SP, SP, -24
9D0047BC  AFBA0014   SW K0, 20(SP)
9D0047C0  401A6002   MFC0 K0, SRSCtl
9D0047C4  AFBB0010   SW K1, 16(SP)
9D0047C8  AFBA000C   SW K0, 12(SP)
9D0047CC  7C1B7844   INS K1, ZERO, 1, 15
9D0047D0  377B0000   ORI K1, K1, 0
9D0047D4  409B6000   MTC0 K1, Status
9D0047D8  AFBE0004   SW S8, 4(SP)
9D0047DC  AFA30000   SW V1, 0(SP)
9D0047E0  03A0F021   ADDU S8, SP, ZERO
151:                     while(TRUE);
9D0047E4  0B4011F9   J 0x9D0047E4
9D0047E8  00000000   NOP
152:                 }
153:                 
154:                 void InitializeSystem(void)
155:                 {
9D0047EC  27BDFF80   ADDIU SP, SP, -128
9D0047F0  AFBF007C   SW RA, 124(SP)
9D0047F4  AFBE0078   SW S8, 120(SP)
9D0047F8  03A0F021   ADDU S8, SP, ZERO
156:                     /**************************************************************************/
157:                     /* Configure, enable the cache for the best performance                   */
158:                     OSCConfig(OSC_POSC_PLL,PLL_OUTPUT_MULT,PLL_OUTPUT_DIVIDER,0);
9D0047FC  24040300   ADDIU A0, ZERO, 768
9D004800  3C050005   LUI A1, 5
9D004804  00003021   ADDU A2, ZERO, ZERO
9D004808  00003821   ADDU A3, ZERO, ZERO
9D00480C  0F40151D   JAL OSCConfig
9D004810  00000000   NOP
9D004814  3C0204C4   LUI V0, 1220
9D004818  3442B400   ORI V0, V0, -19456
9D00481C  AFC20010   SW V0, 16(S8)
9D004820  24020005   ADDIU V0, ZERO, 5
9D004824  AFC20014   SW V0, 20(S8)
159:                     SYSTEMConfig(GetSystemClock(), SYS_CFG_WAIT_STATES | SYS_CFG_PCACHE);
160:                     mOSCSetPBDIV(PBCLK_DIV);
161:                     /* Enable multiple interrupt vectors */
162:                     INTConfigureSystem(INT_SYSTEM_CONFIG_MULT_VECTOR);
9D004C14  00002021   ADDU A0, ZERO, ZERO
9D004C18  0F401789   JAL INTConfigureSystem
9D004C1C  00000000   NOP
163:                     AD1PCFG=0xFFFF;
9D004C20  3C02BF81   LUI V0, -16511
9D004C24  3403FFFF   ORI V1, ZERO, -1
9D004C28  AC439060   SW V1, -28576(V0)
164:                     P5V_POWER_GOOD_DIRECTION=TRIS_IN;
9D004C2C  3C03BF88   LUI V1, -16504
9D004C30  8C626100   LW V0, 24832(V1)
9D004C34  24040001   ADDIU A0, ZERO, 1
9D004C38  7C824A44   INS V0, A0, 9, 1
9D004C3C  AC626100   SW V0, 24832(V1)
165:                     LEDInitialize();
9D004C40  0F40131C   JAL LEDInitialize
9D004C44  00000000   NOP
166:                     TickInitialize();
9D004C48  0F4014F3   JAL TickInitialize
9D004C4C  00000000   NOP
167:                     INTEnableInterrupts();
9D004C50  0F40182C   JAL INTEnableInterrupts
9D004C54  00000000   NOP
168:                 }
9D004C58  03C0E821   ADDU SP, S8, ZERO
9D004C5C  8FBF007C   LW RA, 124(SP)
9D004C60  8FBE0078   LW S8, 120(SP)
9D004C64  27BD0080   ADDIU SP, SP, 128
9D004C68  03E00008   JR RA
9D004C6C  00000000   NOP
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/general_exception_handler.c  ------------------
1:                   #include <common.h>
2:                   
3:                   typedef enum
4:                   {                       /******************************************************/
5:                   	EXCEP_IRQ = 0,	/* 0 - interrupt                                      */
6:                   	EXCEP_AdEL = 4,	/* 4 - address error exception (load or ifetch)       */
7:                   	EXCEP_AdES,	/* 5 - address error exception (store)                */
8:                   	EXCEP_IBE,	/* 6 - bus error (ifetch)                             */
9:                   	EXCEP_DBE,	/* 7 - bus error (load/store)                         */
10:                  	EXCEP_Sys,	/* 8 - syscall                                        */
11:                  	EXCEP_Bp,	/* 9 - breakpoint                                     */
12:                  	EXCEP_RI,	/* 10 - reserved instruction                          */
13:                  	EXCEP_CpU,	/* 11 - coprocessor unusable                          */
14:                  	EXCEP_Overflow,	/* 12 - arithmetic overflow                           */
15:                  	EXCEP_Trap,	/* 13 - trap (possible divide by zero)                */
16:                  	EXCEP_IS1 = 16,	/* 16 - implementation specfic                        */
17:                  	EXCEP_CEU,	/* 17 - CorExtend Unuseable                           */
18:                  	EXCEP_C2E	/* 18 - coprocessor 2                                 */
19:                  } _excep_code;          /******************************************************/
20:                  
21:                  /******************************************************************************/
22:                  /* void _general_exception_handler(unsigned int Cause, unsigned int Status)   */
23:                  /*                                                                            */
24:                  /* PreCondition:    None                                                      */
25:                  /*                                                                            */
26:                  /* Input:           None                                                      */
27:                  /*                                                                            */
28:                  /* Output:          None                                                      */
29:                  /*                                                                            */
30:                  /* Side Effects:    None                                                      */
31:                  /*                                                                            */
32:                  /*  Overview:       Overrides (weak) general exception handler provided by    */
33:                  /*                  C32. Uses C32 macros to read epc and cause registers.     */
34:                  /*                  Application code can then do something useful with them.  */
35:                  /*                                                                            */
36:                  /******************************************************************************/
37:                  
38:                  void __attribute__((naked, nomips16)) _general_exception_handler(UINT32 cause, UINT32 status)
39:                  {
9D005C54  AFC40018   SW A0, 24(S8)
9D005C58  AFC5001C   SW A1, 28(S8)
40:                      UINT32 count=0;
9D005C5C  AFC00000   SW ZERO, 0(S8)
41:                      UINT32 _epc=0;
9D005C60  AFC00004   SW ZERO, 4(S8)
42:                      UINT32 _status = 0;
9D005C64  AFC00008   SW ZERO, 8(S8)
43:                      _excep_code _cause = 0;
9D005C68  AFC0000C   SW ZERO, 12(S8)
44:                  
45:                      _status = status;
9D005C6C  8FC2001C   LW V0, 28(S8)
9D005C70  AFC20008   SW V0, 8(S8)
46:                      _cause = ((cause & 0x0000007C) >> 2);
9D005C74  8FC20018   LW V0, 24(S8)
9D005C78  3042007C   ANDI V0, V0, 124
9D005C7C  00021082   SRL V0, V0, 2
9D005C80  AFC2000C   SW V0, 12(S8)
47:                      _epc = _CP0_GET_EPC();
9D005C84  40027000   MFC0 V0, EPC
9D005C88  AFC20004   SW V0, 4(S8)
48:                      while(TRUE)
49:                      {
50:                          Nop();
9D005C8C  00000040   SSNOP
51:                      }
9D005C90  0B401723   J 0x9D005C8C
9D005C94  00000000   NOP
52:                  } 
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/delay.c  --------------------------------------
1:                   /******************************************************************************/
2:                   /* File: delay.c                                                              */
3:                   /* Author: Matt Bennett                                                       */
4:                   /* Date: December 26, 2011                                                    */
5:                   /* Version: 0.9                                                               */
6:                   /*                                                                            */
7:                   /* Description: Functions to access a real time timer, derived from 'tick'    */
8:                   /*                                                                            */
9:                   /******************************************************************************/
10:                  
11:                  #include "common.h"
12:                  #include "tick.h"
13:                  #include "delay.h"
14:                  
15:                  /******************************************************************************/
16:                  /* DelayMs(int toWait)                                                        */
17:                  /*  wait between toWait and toWait+1 milliseconds. Added the +1 in there since*/
18:                  /*  we don't know where within the 'tick' this starts.                        */
19:                  /* NB: this is a blocking function!                                           */
20:                  /******************************************************************************/
21:                  #ifdef DELAY_USE_CORE_TIMER
22:                  
23:                  
24:                  void DelayUs(UINT32 delay_us)
25:                  {
9D00572C  27BDFFE0   ADDIU SP, SP, -32
9D005730  AFBF001C   SW RA, 28(SP)
9D005734  AFBE0018   SW S8, 24(SP)
9D005738  03A0F021   ADDU S8, SP, ZERO
9D00573C  AFC40020   SW A0, 32(S8)
26:                      UINT32   DelayStartTime;
27:                      DelayStartTime = ReadCoreTimer();
9D005740  0F40182A   JAL ReadCoreTimer
9D005744  00000000   NOP
9D005748  AFC20010   SW V0, 16(S8)
28:                      while((ReadCoreTimer() - DelayStartTime) < (delay_us * CORE_TIMER_MICROSECONDS));
9D00574C  00000000   NOP
9D005750  0F40182A   JAL ReadCoreTimer
9D005754  00000000   NOP
9D005758  00401821   ADDU V1, V0, ZERO
9D00575C  8FC20010   LW V0, 16(S8)
9D005760  00621023   SUBU V0, V1, V0
9D005764  8FC40020   LW A0, 32(S8)
9D005768  24030028   ADDIU V1, ZERO, 40
9D00576C  70831802   MUL V1, A0, V1
9D005770  0043102B   SLTU V0, V0, V1
9D005774  1440FFF6   BNE V0, ZERO, 0x9D005750
9D005778  00000000   NOP
29:                  }
9D00577C  03C0E821   ADDU SP, S8, ZERO
9D005780  8FBF001C   LW RA, 28(SP)
9D005784  8FBE0018   LW S8, 24(SP)
9D005788  27BD0020   ADDIU SP, SP, 32
9D00578C  03E00008   JR RA
9D005790  00000000   NOP
30:                  
31:                  void DelayMs(UINT32 delay_ms)
32:                  {
9D005794  27BDFFE0   ADDIU SP, SP, -32
9D005798  AFBF001C   SW RA, 28(SP)
9D00579C  AFBE0018   SW S8, 24(SP)
9D0057A0  03A0F021   ADDU S8, SP, ZERO
9D0057A4  AFC40020   SW A0, 32(S8)
33:                      UINT32   DelayStartTime;
34:                      DelayStartTime = ReadCoreTimer();
9D0057A8  0F40182A   JAL ReadCoreTimer
9D0057AC  00000000   NOP
9D0057B0  AFC20010   SW V0, 16(S8)
35:                      while((ReadCoreTimer() - DelayStartTime) < (delay_ms * CORE_TIMER_MILLISECONDS));
9D0057B4  00000000   NOP
9D0057B8  0F40182A   JAL ReadCoreTimer
9D0057BC  00000000   NOP
9D0057C0  00401821   ADDU V1, V0, ZERO
9D0057C4  8FC20010   LW V0, 16(S8)
9D0057C8  00621023   SUBU V0, V1, V0
9D0057CC  8FC40020   LW A0, 32(S8)
9D0057D0  34039C40   ORI V1, ZERO, -25536
9D0057D4  70831802   MUL V1, A0, V1
9D0057D8  0043102B   SLTU V0, V0, V1
9D0057DC  1440FFF6   BNE V0, ZERO, 0x9D0057B8
9D0057E0  00000000   NOP
36:                  }
9D0057E4  03C0E821   ADDU SP, S8, ZERO
9D0057E8  8FBF001C   LW RA, 28(SP)
9D0057EC  8FBE0018   LW S8, 24(SP)
9D0057F0  27BD0020   ADDIU SP, SP, 32
9D0057F4  03E00008   JR RA
9D0057F8  00000000   NOP
37:                  
38:                  #else
39:                  
40:                  void DelayMS(int ms)
41:                  {
42:                      UINT64 when;
43:                      when=TickGet()+ms+1;
44:                      while(TickGet()<when);
45:                  }
46:                  
47:                  #endif
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/commsToRPi.c  ---------------------------------
1:                   /******************************************************************************/
2:                   /*                                                                            */
3:                   /* File:   commsToRPi.c                                                       */
4:                   /* Author: Matt Bennett                                                       */
5:                   /*                                                                            */
6:                   /* Created on January 30, 2013                                                */
7:                   /*                                                                            */
8:                   /******************************************************************************/
9:                   
10:                  #include <common.h>
11:                  #include <TRISThis.h>
12:                  #include <commsToRPi.h>
13:                  #include <peripheral/spi.h>
14:                  #include <peripheral/int.h>
15:                  
16:                  SPI_TYPE SPI;
17:                  extern TRISTHIS_DATA_TYPE TRISThisData;
18:                  
19:                  /******************************************************************************/
20:                  
21:                  BOOL SPIByteGet(UINT8 address, UINT8 *data)
22:                  {
9D0021E4  27BDFFF8   ADDIU SP, SP, -8
9D0021E8  AFBE0004   SW S8, 4(SP)
9D0021EC  03A0F021   ADDU S8, SP, ZERO
9D0021F0  00801021   ADDU V0, A0, ZERO
9D0021F4  AFC5000C   SW A1, 12(S8)
9D0021F8  A3C20008   SB V0, 8(S8)
23:                      if(address>=sizeof(SPI.RXData))
9D0021FC  93C30008   LBU V1, 8(S8)
9D002200  240200FF   ADDIU V0, ZERO, 255
9D002204  14620004   BNE V1, V0, 0x9D002218
9D002208  00000000   NOP
24:                      {
25:                          return FALSE;
9D00220C  00001021   ADDU V0, ZERO, ZERO
9D002210  0B40088E   J 0x9D002238
9D002214  00000000   NOP
26:                      }
27:                      else
28:                      {
29:                          *data=SPI.RXData[address];
9D002218  93C30008   LBU V1, 8(S8)
9D00221C  3C02A000   LUI V0, -24576
9D002220  24420230   ADDIU V0, V0, 560
9D002224  00621021   ADDU V0, V1, V0
9D002228  9043000C   LBU V1, 12(V0)
9D00222C  8FC2000C   LW V0, 12(S8)
9D002230  A0430000   SB V1, 0(V0)
30:                          return TRUE;
9D002234  24020001   ADDIU V0, ZERO, 1
31:                      }
32:                  }
9D002238  03C0E821   ADDU SP, S8, ZERO
9D00223C  8FBE0004   LW S8, 4(SP)
9D002240  27BD0008   ADDIU SP, SP, 8
9D002244  03E00008   JR RA
9D002248  00000000   NOP
33:                  
34:                  BOOL SPIWordGet(UINT8 address, UINT32 *data)
35:                  {
9D00224C  27BDFFF8   ADDIU SP, SP, -8
9D002250  AFBE0004   SW S8, 4(SP)
9D002254  03A0F021   ADDU S8, SP, ZERO
9D002258  00801021   ADDU V0, A0, ZERO
9D00225C  AFC5000C   SW A1, 12(S8)
9D002260  A3C20008   SB V0, 8(S8)
36:                  
37:                  }
9D002264  03C0E821   ADDU SP, S8, ZERO
9D002268  8FBE0004   LW S8, 4(SP)
9D00226C  27BD0008   ADDIU SP, SP, 8
9D002270  03E00008   JR RA
9D002274  00000000   NOP
38:                  /******************************************************************************/
39:                  
40:                  BOOL SPIDataReady(void)
41:                  {
9D002278  27BDFFE0   ADDIU SP, SP, -32
9D00227C  AFBF001C   SW RA, 28(SP)
9D002280  AFBE0018   SW S8, 24(SP)
9D002284  03A0F021   ADDU S8, SP, ZERO
42:                      BOOL returnValue;
43:                      unsigned int statusTemp;
44:                      statusTemp = INTDisableInterrupts();
9D002288  0F40182E   JAL INTDisableInterrupts
9D00228C  00000000   NOP
9D002290  AFC20010   SW V0, 16(S8)
45:                      returnValue=SPI.status.RXDataReady;
9D002294  3C02A000   LUI V0, -24576
9D002298  24420230   ADDIU V0, V0, 560
9D00229C  8C420008   LW V0, 8(V0)
9D0022A0  7C420000   EXT V0, V0, 0, 1
9D0022A4  304200FF   ANDI V0, V0, 255
9D0022A8  AFC20014   SW V0, 20(S8)
46:                      SPI.status.RXDataReady=FALSE;
9D0022AC  3C02A000   LUI V0, -24576
9D0022B0  24430230   ADDIU V1, V0, 560
9D0022B4  8C620008   LW V0, 8(V1)
9D0022B8  7C020004   INS V0, ZERO, 0, 1
9D0022BC  AC620008   SW V0, 8(V1)
47:                      INTRestoreInterrupts(statusTemp);
9D0022C0  8FC40010   LW A0, 16(S8)
9D0022C4  0F401804   JAL INTRestoreInterrupts
9D0022C8  00000000   NOP
48:                      return returnValue;
9D0022CC  8FC20014   LW V0, 20(S8)
49:                  }
9D0022D0  03C0E821   ADDU SP, S8, ZERO
9D0022D4  8FBF001C   LW RA, 28(SP)
9D0022D8  8FBE0018   LW S8, 24(SP)
9D0022DC  27BD0020   ADDIU SP, SP, 32
9D0022E0  03E00008   JR RA
9D0022E4  00000000   NOP
50:                  
51:                  /******************************************************************************/
52:                  
53:                  BOOL ConfigSPIComms(void)
54:                  {
9D0022E8  27BDFFE8   ADDIU SP, SP, -24
9D0022EC  AFBF0014   SW RA, 20(SP)
9D0022F0  AFBE0010   SW S8, 16(SP)
9D0022F4  03A0F021   ADDU S8, SP, ZERO
55:                      SpiChnClose(RPI_SPI_CHANNEL);
9D0022F8  24040001   ADDIU A0, ZERO, 1
9D0022FC  0F401633   JAL SpiChnClose
9D002300  00000000   NOP
56:                      /* do I need to configure this? */
57:                      INTEnable(INT_SOURCE_SPI_RX(RPI_SPI_CHANNEL),INT_DISABLED);
9D002304  24040029   ADDIU A0, ZERO, 41
9D002308  00002821   ADDU A1, ZERO, ZERO
9D00230C  0F4016DC   JAL INTEnable
9D002310  00000000   NOP
58:                      INTEnable(INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL),INT_DISABLED);
9D002314  24040025   ADDIU A0, ZERO, 37
9D002318  00002821   ADDU A1, ZERO, ZERO
9D00231C  0F4016DC   JAL INTEnable
9D002320  00000000   NOP
59:                      INTEnable(INT_SOURCE_SPI_ERROR(RPI_SPI_CHANNEL),INT_DISABLED);
9D002324  24040021   ADDIU A0, ZERO, 33
9D002328  00002821   ADDU A1, ZERO, ZERO
9D00232C  0F4016DC   JAL INTEnable
9D002330  00000000   NOP
60:                      INTEnable(INT_SOURCE_SPI(RPI_SPI_CHANNEL),INT_DISABLED);
9D002334  2404001D   ADDIU A0, ZERO, 29
9D002338  00002821   ADDU A1, ZERO, ZERO
9D00233C  0F4016DC   JAL INTEnable
9D002340  00000000   NOP
61:                      RPI_SPI_BUF=0x00;
9D002344  3C02BF80   LUI V0, -16512
9D002348  AC405E20   SW ZERO, 24096(V0)
62:                      SPI_DATA_IN_DIRECTION = TRIS_IN;
9D00234C  3C03BF88   LUI V1, -16504
9D002350  8C626080   LW V0, 24704(V1)
9D002354  24040001   ADDIU A0, ZERO, 1
9D002358  7C822104   INS V0, A0, 4, 1
9D00235C  AC626080   SW V0, 24704(V1)
63:                      SPI_DATA_OUT_DIRECTION = TRIS_OUT;
9D002360  3C03BF88   LUI V1, -16504
9D002364  8C6260C0   LW V0, 24768(V1)
9D002368  7C020004   INS V0, ZERO, 0, 1
9D00236C  AC6260C0   SW V0, 24768(V1)
64:                      SPI_CLOCK_IN_DIRECTION = TRIS_IN;
9D002370  3C03BF88   LUI V1, -16504
9D002374  8C6260C0   LW V0, 24768(V1)
9D002378  24040001   ADDIU A0, ZERO, 1
9D00237C  7C825284   INS V0, A0, 10, 1
9D002380  AC6260C0   SW V0, 24768(V1)
65:                      SPI_SELECT_IN_DIRECTION = TRIS_IN;
9D002384  3C03BF88   LUI V1, -16504
9D002388  8C6260C0   LW V0, 24768(V1)
9D00238C  24040001   ADDIU A0, ZERO, 1
9D002390  7C824A44   INS V0, A0, 9, 1
9D002394  AC6260C0   SW V0, 24768(V1)
66:                  
67:                      SPI.RXCount=0;
9D002398  3C02A000   LUI V0, -24576
9D00239C  24420230   ADDIU V0, V0, 560
9D0023A0  A0400005   SB ZERO, 5(V0)
68:                      SPI.address.Val=0;
9D0023A4  3C02A000   LUI V0, -24576
9D0023A8  AC400230   SW ZERO, 560(V0)
69:                      SPI.command=0;
9D0023AC  3C02A000   LUI V0, -24576
9D0023B0  24420230   ADDIU V0, V0, 560
9D0023B4  A0400004   SB ZERO, 4(V0)
70:                      SpiChnOpen(RPI_SPI_CHANNEL,
9D0023B8  24040001   ADDIU A0, ZERO, 1
9D0023BC  24050180   ADDIU A1, ZERO, 384
9D0023C0  00003021   ADDU A2, ZERO, ZERO
9D0023C4  0F401577   JAL SpiChnOpen
9D0023C8  00000000   NOP
71:                              SPI_OPEN_SLVEN|SPI_OPEN_CKE_REV/*|SPI_OPEN_CKP_HIGH*/|SPI_OPEN_MODE8|SPI_OPEN_SSEN,
72:                              0);
73:                      //TODO: Not acting consistently? RPI needs to send -b 8 -H parameters to spidev
74:                      RPI_SPI_BUF=0xFF;
9D0023CC  3C02BF80   LUI V0, -16512
9D0023D0  240300FF   ADDIU V1, ZERO, 255
9D0023D4  AC435E20   SW V1, 24096(V0)
75:                      INTSetVectorPriority(INT_VECTOR_SPI(RPI_SPI_CHANNEL), INT_PRIORITY_LEVEL_3);
9D0023D8  24040017   ADDIU A0, ZERO, 23
9D0023DC  24050003   ADDIU A1, ZERO, 3
9D0023E0  0F401752   JAL INTSetVectorPriority
9D0023E4  00000000   NOP
76:                      INTSetVectorSubPriority(INT_VECTOR_SPI(RPI_SPI_CHANNEL),
9D0023E8  24040017   ADDIU A0, ZERO, 23
9D0023EC  24050001   ADDIU A1, ZERO, 1
9D0023F0  0F401760   JAL INTSetVectorSubPriority
9D0023F4  00000000   NOP
77:                              INT_SUB_PRIORITY_LEVEL_1);
78:                  
79:                      INTClearFlag(INT_SOURCE_SPI_RX(RPI_SPI_CHANNEL));
9D0023F8  24040029   ADDIU A0, ZERO, 41
9D0023FC  0F4017B7   JAL INTClearFlag
9D002400  00000000   NOP
80:                      INTEnable(INT_SOURCE_SPI_RX(RPI_SPI_CHANNEL),INT_ENABLED);
9D002404  24040029   ADDIU A0, ZERO, 41
9D002408  24050001   ADDIU A1, ZERO, 1
9D00240C  0F4016DC   JAL INTEnable
9D002410  00000000   NOP
81:                      
82:                      INTClearFlag(INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL));
9D002414  24040025   ADDIU A0, ZERO, 37
9D002418  0F4017B7   JAL INTClearFlag
9D00241C  00000000   NOP
83:                      INTEnable(INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL),INT_ENABLED);
9D002420  24040025   ADDIU A0, ZERO, 37
9D002424  24050001   ADDIU A1, ZERO, 1
9D002428  0F4016DC   JAL INTEnable
9D00242C  00000000   NOP
84:                  
85:                      INTClearFlag(INT_SOURCE_SPI_ERROR(RPI_SPI_CHANNEL));
9D002430  24040021   ADDIU A0, ZERO, 33
9D002434  0F4017B7   JAL INTClearFlag
9D002438  00000000   NOP
86:                      INTEnable(INT_SOURCE_SPI_ERROR(RPI_SPI_CHANNEL),INT_ENABLED);
9D00243C  24040021   ADDIU A0, ZERO, 33
9D002440  24050001   ADDIU A1, ZERO, 1
9D002444  0F4016DC   JAL INTEnable
9D002448  00000000   NOP
87:                  
88:                      INTClearFlag(INT_SOURCE_SPI(RPI_SPI_CHANNEL));
9D00244C  2404001D   ADDIU A0, ZERO, 29
9D002450  0F4017B7   JAL INTClearFlag
9D002454  00000000   NOP
89:                      INTEnable(INT_SOURCE_SPI(RPI_SPI_CHANNEL),INT_ENABLED);
9D002458  2404001D   ADDIU A0, ZERO, 29
9D00245C  24050001   ADDIU A1, ZERO, 1
9D002460  0F4016DC   JAL INTEnable
9D002464  00000000   NOP
90:                      /* configure change notice, as I can't figure out any other way to        */
91:                      /* trigger the beginning of the slave select with just the SPI peripheral */
92:                      /* buuut the change notice pins are not on the SS pins, so a white wire is*/
93:                      /* needed                                                                 */
94:                      /* tie chip enable CE0 to pin20/RE5 CE1 */
95:                      SPI_SELECT_CN_DIRECTION=TRIS_IN;
9D002468  3C03BF88   LUI V1, -16504
9D00246C  8C626040   LW V0, 24640(V1)
9D002470  24040001   ADDIU A0, ZERO, 1
9D002474  7C822944   INS V0, A0, 5, 1
9D002478  AC626040   SW V0, 24640(V1)
96:                      CNCONbits.w=0;
9D00247C  3C02BF88   LUI V0, -16504
9D002480  AC4061C0   SW ZERO, 25024(V0)
97:                      CNCONbits.ON=TRUE;
9D002484  3C03BF88   LUI V1, -16504
9D002488  8C6261C0   LW V0, 25024(V1)
9D00248C  24040001   ADDIU A0, ZERO, 1
9D002490  7C827BC4   INS V0, A0, 15, 1
9D002494  AC6261C0   SW V0, 25024(V1)
98:                      CNENbits.w=0;
9D002498  3C02BF88   LUI V0, -16504
9D00249C  AC4061D0   SW ZERO, 25040(V0)
99:                      CNENbits.CNEN7=TRUE;
9D0024A0  3C03BF88   LUI V1, -16504
9D0024A4  8C6261D0   LW V0, 25040(V1)
9D0024A8  24040001   ADDIU A0, ZERO, 1
9D0024AC  7C8239C4   INS V0, A0, 7, 1
9D0024B0  AC6261D0   SW V0, 25040(V1)
100:                     RPI_SPI_RX_OVERFLOW_CLEAR;
9D0024B4  3C03BF80   LUI V1, -16512
9D0024B8  8C625E10   LW V0, 24080(V1)
9D0024BC  7C023184   INS V0, ZERO, 6, 1
9D0024C0  AC625E10   SW V0, 24080(V1)
101:                     SPI1CONbits.STXISEL=0b01;
9D0024C4  3C03BF80   LUI V1, -16512
9D0024C8  8C625E00   LW V0, 24064(V1)
9D0024CC  24040001   ADDIU A0, ZERO, 1
9D0024D0  7C821884   INS V0, A0, 2, 2
9D0024D4  AC625E00   SW V0, 24064(V1)
102:                     SPI.status.w=0;
9D0024D8  3C02A000   LUI V0, -24576
9D0024DC  24420230   ADDIU V0, V0, 560
9D0024E0  AC400008   SW ZERO, 8(V0)
103:                     INTClearFlag(INT_CN);
9D0024E4  2404001C   ADDIU A0, ZERO, 28
9D0024E8  0F4017B7   JAL INTClearFlag
9D0024EC  00000000   NOP
104:                     INTSetVectorPriority(INT_CHANGE_NOTICE_VECTOR, INT_PRIORITY_LEVEL_2);
9D0024F0  24040026   ADDIU A0, ZERO, 38
9D0024F4  24050002   ADDIU A1, ZERO, 2
9D0024F8  0F401752   JAL INTSetVectorPriority
9D0024FC  00000000   NOP
105:                     INTSetVectorSubPriority(INT_CHANGE_NOTICE_VECTOR, INT_SUB_PRIORITY_LEVEL_1);
9D002500  24040026   ADDIU A0, ZERO, 38
9D002504  24050001   ADDIU A1, ZERO, 1
9D002508  0F401760   JAL INTSetVectorSubPriority
9D00250C  00000000   NOP
106:                     INTEnable(INT_CN,INT_ENABLED);
9D002510  2404001C   ADDIU A0, ZERO, 28
9D002514  24050001   ADDIU A1, ZERO, 1
9D002518  0F4016DC   JAL INTEnable
9D00251C  00000000   NOP
107:                     return TRUE;
9D002520  24020001   ADDIU V0, ZERO, 1
108:                 }
9D002524  03C0E821   ADDU SP, S8, ZERO
9D002528  8FBF0014   LW RA, 20(SP)
9D00252C  8FBE0010   LW S8, 16(SP)
9D002530  27BD0018   ADDIU SP, SP, 24
9D002534  03E00008   JR RA
9D002538  00000000   NOP
109:                 
110:                 /******************************************************************************/
111:                 
112:                 void __ISR(_CHANGE_NOTICE_VECTOR , RPI_COMMS_CE_PRIORITY) RPiSPICNInterrutpt(void)
113:                 {
9D00253C  415DE800   RDPGPR SP, SP
9D002540  401A7000   MFC0 K0, EPC
9D002544  401B6000   MFC0 K1, Status
9D002548  27BDFFE0   ADDIU SP, SP, -32
9D00254C  AFBA001C   SW K0, 28(SP)
9D002550  401A6002   MFC0 K0, SRSCtl
9D002554  AFBB0018   SW K1, 24(SP)
9D002558  AFBA0014   SW K0, 20(SP)
9D00255C  7C1B7844   INS K1, ZERO, 1, 15
9D002560  377B1000   ORI K1, K1, 4096
9D002564  409B6000   MTC0 K1, Status
9D002568  AFBE000C   SW S8, 12(SP)
9D00256C  AFA40008   SW A0, 8(SP)
9D002570  AFA30004   SW V1, 4(SP)
9D002574  AFA20000   SW V0, 0(SP)
9D002578  03A0F021   ADDU S8, SP, ZERO
114:                     IFS1CLR=_IFS1_CNIF_MASK;
9D00257C  3C02BF88   LUI V0, -16504
9D002580  24030001   ADDIU V1, ZERO, 1
9D002584  AC431044   SW V1, 4164(V0)
115:                     if((SPI.status.CEStatus==FALSE)&&(SPI_SELECT_CN_IN==FALSE))
9D002588  3C02A000   LUI V0, -24576
9D00258C  24420230   ADDIU V0, V0, 560
9D002590  8C420008   LW V0, 8(V0)
9D002594  30420002   ANDI V0, V0, 2
9D002598  14400025   BNE V0, ZERO, 0x9D002630
9D00259C  00000000   NOP
9D0025A0  3C02BF88   LUI V0, -16504
9D0025A4  8C426050   LW V0, 24656(V0)
9D0025A8  30420020   ANDI V0, V0, 32
9D0025AC  14400020   BNE V0, ZERO, 0x9D002630
9D0025B0  00000000   NOP
116:                     {
117:                         if(SPI.status.RXDataReady)
9D0025B4  3C02A000   LUI V0, -24576
9D0025B8  24420230   ADDIU V0, V0, 560
9D0025BC  8C420008   LW V0, 8(V0)
9D0025C0  30420001   ANDI V0, V0, 1
9D0025C4  1040000C   BEQ V0, ZERO, 0x9D0025F8
9D0025C8  00000000   NOP
118:                         {
119:                             /* we missed some data */
120:                             SPI.status.RXDataReady=FALSE;
9D0025CC  3C02A000   LUI V0, -24576
9D0025D0  24430230   ADDIU V1, V0, 560
9D0025D4  8C620008   LW V0, 8(V1)
9D0025D8  7C020004   INS V0, ZERO, 0, 1
9D0025DC  AC620008   SW V0, 8(V1)
121:                             SPI.status.RXOverrun=TRUE;
9D0025E0  3C02A000   LUI V0, -24576
9D0025E4  24430230   ADDIU V1, V0, 560
9D0025E8  8C620008   LW V0, 8(V1)
9D0025EC  24040001   ADDIU A0, ZERO, 1
9D0025F0  7C822944   INS V0, A0, 5, 1
9D0025F4  AC620008   SW V0, 8(V1)
122:                         }
123:                         SPI.RXState=STATE_SPI_RX_COMMAND;
9D0025F8  3C02A000   LUI V0, -24576
9D0025FC  24420230   ADDIU V0, V0, 560
9D002600  AC400110   SW ZERO, 272(V0)
124:                         SPI.status.CEStatus=TRUE;
9D002604  3C02A000   LUI V0, -24576
9D002608  24430230   ADDIU V1, V0, 560
9D00260C  8C620008   LW V0, 8(V1)
9D002610  24040001   ADDIU A0, ZERO, 1
9D002614  7C820844   INS V0, A0, 1, 1
9D002618  AC620008   SW V0, 8(V1)
125:                         SPI.RXCount=0;
9D00261C  3C02A000   LUI V0, -24576
9D002620  24420230   ADDIU V0, V0, 560
9D002624  A0400005   SB ZERO, 5(V0)
9D002628  0B4009A6   J 0x9D002698
9D00262C  00000000   NOP
126:                     }
127:                     else if((SPI.status.CEStatus==TRUE)&&(SPI_SELECT_CN_IN==TRUE))
9D002630  3C02A000   LUI V0, -24576
9D002634  24420230   ADDIU V0, V0, 560
9D002638  8C420008   LW V0, 8(V0)
9D00263C  30420002   ANDI V0, V0, 2
9D002640  10400015   BEQ V0, ZERO, 0x9D002698
9D002644  00000000   NOP
9D002648  3C02BF88   LUI V0, -16504
9D00264C  8C426050   LW V0, 24656(V0)
9D002650  30420020   ANDI V0, V0, 32
9D002654  10400010   BEQ V0, ZERO, 0x9D002698
9D002658  00000000   NOP
128:                     {
129:                         SPI.RXState=STATE_SPI_RX_COMPLETE;
9D00265C  3C02A000   LUI V0, -24576
9D002660  24420230   ADDIU V0, V0, 560
9D002664  24030007   ADDIU V1, ZERO, 7
9D002668  AC430110   SW V1, 272(V0)
130:                         SPI.status.RXDataReady=TRUE;
9D00266C  3C02A000   LUI V0, -24576
9D002670  24430230   ADDIU V1, V0, 560
9D002674  8C620008   LW V0, 8(V1)
9D002678  24040001   ADDIU A0, ZERO, 1
9D00267C  7C820004   INS V0, A0, 0, 1
9D002680  AC620008   SW V0, 8(V1)
131:                         SPI.status.CEStatus=FALSE;
9D002684  3C02A000   LUI V0, -24576
9D002688  24430230   ADDIU V1, V0, 560
9D00268C  8C620008   LW V0, 8(V1)
9D002690  7C020844   INS V0, ZERO, 1, 1
9D002694  AC620008   SW V0, 8(V1)
132:                     }
133:                 }
9D002698  03C0E821   ADDU SP, S8, ZERO
9D00269C  8FBE000C   LW S8, 12(SP)
9D0026A0  8FA40008   LW A0, 8(SP)
9D0026A4  8FA30004   LW V1, 4(SP)
9D0026A8  8FA20000   LW V0, 0(SP)
9D0026AC  41606000   DI ZERO
9D0026B0  000000C0   EHB
9D0026B4  8FBA001C   LW K0, 28(SP)
9D0026B8  8FBB0018   LW K1, 24(SP)
9D0026BC  409A7000   MTC0 K0, EPC
9D0026C0  8FBA0014   LW K0, 20(SP)
9D0026C4  27BD0020   ADDIU SP, SP, 32
9D0026C8  409A6002   MTC0 K0, SRSCtl
9D0026CC  41DDE800   WRPGPR SP, SP
9D0026D0  409B6000   MTC0 K1, Status
9D0026D4  42000018   ERET
134:                 
135:                 /******************************************************************************/
136:                 
137:                 inline BOOL RPiSelectStatus(void)
138:                 {
9D0026D8  27BDFFE0   ADDIU SP, SP, -32
9D0026DC  AFBF001C   SW RA, 28(SP)
9D0026E0  AFBE0018   SW S8, 24(SP)
9D0026E4  03A0F021   ADDU S8, SP, ZERO
139:                     BOOL returnValue;
140:                     unsigned int intEnabled;
141:                     intEnabled=INTGetEnable(INT_CN);
9D0026E8  2404001C   ADDIU A0, ZERO, 28
9D0026EC  0F4017D5   JAL INTGetEnable
9D0026F0  00000000   NOP
9D0026F4  AFC20010   SW V0, 16(S8)
142:                     INTEnable(INT_CN,INT_DISABLED);
9D0026F8  2404001C   ADDIU A0, ZERO, 28
9D0026FC  00002821   ADDU A1, ZERO, ZERO
9D002700  0F4016DC   JAL INTEnable
9D002704  00000000   NOP
143:                     returnValue=SPI.status.CEStatus;
9D002708  3C02A000   LUI V0, -24576
9D00270C  24420230   ADDIU V0, V0, 560
9D002710  8C420008   LW V0, 8(V0)
9D002714  7C420040   EXT V0, V0, 1, 1
9D002718  304200FF   ANDI V0, V0, 255
9D00271C  AFC20014   SW V0, 20(S8)
144:                     if(intEnabled)
9D002720  8FC20010   LW V0, 16(S8)
9D002724  10400005   BEQ V0, ZERO, 0x9D00273C
9D002728  00000000   NOP
145:                     {
146:                         INTEnable(INT_CN,INT_ENABLED);
9D00272C  2404001C   ADDIU A0, ZERO, 28
9D002730  24050001   ADDIU A1, ZERO, 1
9D002734  0F4016DC   JAL INTEnable
9D002738  00000000   NOP
147:                     }
148:                     return returnValue;
9D00273C  8FC20014   LW V0, 20(S8)
149:                 }
9D002740  03C0E821   ADDU SP, S8, ZERO
9D002744  8FBF001C   LW RA, 28(SP)
9D002748  8FBE0018   LW S8, 24(SP)
9D00274C  27BD0020   ADDIU SP, SP, 32
9D002750  03E00008   JR RA
9D002754  00000000   NOP
150:                 
151:                 /******************************************************************************/
152:                 
153:                 void __ISR(RPI_SPI_INTERRUPT , RPI_COMMS_INT_PRIORITY) RPiSPIInterrutpt(void)
154:                 {
9D002758  415DE800   RDPGPR SP, SP
9D00275C  401A7000   MFC0 K0, EPC
9D002760  401B6000   MFC0 K1, Status
9D002764  27BDFFD0   ADDIU SP, SP, -48
9D002768  AFBA002C   SW K0, 44(SP)
9D00276C  401A6002   MFC0 K0, SRSCtl
9D002770  AFBB0028   SW K1, 40(SP)
9D002774  AFBA0024   SW K0, 36(SP)
9D002778  7C1B7844   INS K1, ZERO, 1, 15
9D00277C  377B0C00   ORI K1, K1, 3072
9D002780  409B6000   MTC0 K1, Status
9D002784  AFBE0014   SW S8, 20(SP)
9D002788  AFA50010   SW A1, 16(SP)
9D00278C  AFA4000C   SW A0, 12(SP)
9D002790  AFA30008   SW V1, 8(SP)
9D002794  AFA20004   SW V0, 4(SP)
9D002798  00001012   MFLO V0, 0
9D00279C  AFA2001C   SW V0, 28(SP)
9D0027A0  00001810   MFHI V1, 0
9D0027A4  AFA30018   SW V1, 24(SP)
9D0027A8  03A0F021   ADDU S8, SP, ZERO
155:                     static UINT8 SPITemp;
156:                     if(SPI_RX_INTERRUPT_ENABLE&&SPI_RX_INTERRUPT_FLAG)
9D0027AC  3C02BF88   LUI V0, -16504
9D0027B0  8C431060   LW V1, 4192(V0)
9D0027B4  3C020100   LUI V0, 256
9D0027B8  00621024   AND V0, V1, V0
9D0027BC  104000BA   BEQ V0, ZERO, 0x9D002AA8
9D0027C0  00000000   NOP
9D0027C4  3C02BF88   LUI V0, -16504
9D0027C8  8C431030   LW V1, 4144(V0)
9D0027CC  3C020100   LUI V0, 256
9D0027D0  00621024   AND V0, V1, V0
9D0027D4  104000B4   BEQ V0, ZERO, 0x9D002AA8
9D0027D8  00000000   NOP
157:                     {
158:                         SPI_RX_INTERRUPT_FLAG_CLEAR;
9D0027DC  3C02BF88   LUI V0, -16504
9D0027E0  3C030100   LUI V1, 256
9D0027E4  AC431034   SW V1, 4148(V0)
159:                         if(RPI_SPI_RX_BUF_FULL)
9D0027E8  3C02BF80   LUI V0, -16512
9D0027EC  8C425E10   LW V0, 24080(V0)
9D0027F0  30420001   ANDI V0, V0, 1
9D0027F4  104000AC   BEQ V0, ZERO, 0x9D002AA8
9D0027F8  00000000   NOP
160:                         {
161:                             /* data in the buffer, read it */
162:                             SPITemp=RPI_SPI_BUF;
9D0027FC  3C02BF80   LUI V0, -16512
9D002800  8C425E20   LW V0, 24096(V0)
9D002804  304200FF   ANDI V0, V0, 255
9D002808  A3828028   SB V0, -32728(GP)
163:                             switch(SPI.RXState)
9D00280C  3C02A000   LUI V0, -24576
9D002810  24420230   ADDIU V0, V0, 560
9D002814  8C420110   LW V0, 272(V0)
9D002818  2C430009   SLTIU V1, V0, 9
9D00281C  10600096   BEQ V1, ZERO, 0x9D002A78
9D002820  00000000   NOP
9D002824  00021880   SLL V1, V0, 2
9D002828  3C029D00   LUI V0, -25344
9D00282C  24422840   ADDIU V0, V0, 10304
9D002830  00621021   ADDU V0, V1, V0
9D002834  8C420000   LW V0, 0(V0)
9D002838  00400008   JR V0
9D00283C  00000000   NOP
164:                             {
165:                                 case STATE_SPI_RX_COMMAND:
166:                                 {
167:                                     SPI.command=SPITemp;
9D002864  93838028   LBU V1, -32728(GP)
9D002868  3C02A000   LUI V0, -24576
9D00286C  24420230   ADDIU V0, V0, 560
9D002870  A0430004   SB V1, 4(V0)
168:                                     SPI.TXBuffer=NOT_YET_BYTE;
9D002874  3C02A000   LUI V0, -24576
9D002878  24420230   ADDIU V0, V0, 560
9D00287C  A040010C   SB ZERO, 268(V0)
169:                                     SPI.RXState=STATE_SPI_RX_ADDRESS_MSB;
9D002880  3C02A000   LUI V0, -24576
9D002884  24420230   ADDIU V0, V0, 560
9D002888  24030001   ADDIU V1, ZERO, 1
9D00288C  AC430110   SW V1, 272(V0)
170:                                     break;
9D002890  0B400AAA   J 0x9D002AA8
9D002894  00000000   NOP
171:                                 }
172:                                 case STATE_SPI_RX_ADDRESS_MSB:
173:                                 {
174:                                     SPI.address.Val=0;
9D002898  3C02A000   LUI V0, -24576
9D00289C  AC400230   SW ZERO, 560(V0)
175:                                     SPI.RXState=STATE_SPI_RX_ADDRESS_2SB;
9D0028A0  3C02A000   LUI V0, -24576
9D0028A4  24420230   ADDIU V0, V0, 560
9D0028A8  24030002   ADDIU V1, ZERO, 2
9D0028AC  AC430110   SW V1, 272(V0)
176:                                     SPI.address.byte.UB=SPITemp;
9D0028B0  93838028   LBU V1, -32728(GP)
9D0028B4  3C02A000   LUI V0, -24576
9D0028B8  24420230   ADDIU V0, V0, 560
9D0028BC  A0430002   SB V1, 2(V0)
177:                                     break;
9D0028C0  0B400AAA   J 0x9D002AA8
9D0028C4  00000000   NOP
178:                                 }
179:                                 case STATE_SPI_RX_ADDRESS_2SB:
180:                                 {
181:                                     SPI.RXState=STATE_SPI_RX_ADDRESS_LSB;
9D0028C8  3C02A000   LUI V0, -24576
9D0028CC  24420230   ADDIU V0, V0, 560
9D0028D0  24030003   ADDIU V1, ZERO, 3
9D0028D4  AC430110   SW V1, 272(V0)
182:                                     SPI.address.byte.HB=SPITemp;
9D0028D8  93838028   LBU V1, -32728(GP)
9D0028DC  3C02A000   LUI V0, -24576
9D0028E0  24420230   ADDIU V0, V0, 560
9D0028E4  A0430001   SB V1, 1(V0)
183:                                     break;
9D0028E8  0B400AAA   J 0x9D002AA8
9D0028EC  00000000   NOP
184:                                 }
185:                                 case STATE_SPI_RX_ADDRESS_LSB:
186:                                 {
187:                                     SPI.RXState=STATE_SPI_RX_DATA;
9D0028F0  3C02A000   LUI V0, -24576
9D0028F4  24420230   ADDIU V0, V0, 560
9D0028F8  24030004   ADDIU V1, ZERO, 4
9D0028FC  AC430110   SW V1, 272(V0)
188:                                     SPI.address.byte.LB=SPITemp;
9D002900  93838028   LBU V1, -32728(GP)
9D002904  3C02A000   LUI V0, -24576
9D002908  A0430230   SB V1, 560(V0)
189:                                     break;
9D00290C  0B400AAA   J 0x9D002AA8
9D002910  00000000   NOP
190:                                 }
191:                                 case STATE_SPI_RX_DATA:
192:                                 {
193:                                     if(!SPI.status.RXOverrunError)
9D002914  3C02A000   LUI V0, -24576
9D002918  24420230   ADDIU V0, V0, 560
9D00291C  8C420008   LW V0, 8(V0)
9D002920  30420008   ANDI V0, V0, 8
9D002924  1440005F   BNE V0, ZERO, 0x9D002AA4
9D002928  00000000   NOP
194:                                     {
195:                                         switch(SPI.command)
9D00292C  3C02A000   LUI V0, -24576
9D002930  24420230   ADDIU V0, V0, 560
9D002934  90420004   LBU V0, 4(V0)
9D002938  24030002   ADDIU V1, ZERO, 2
9D00293C  10430006   BEQ V0, V1, 0x9D002958
9D002940  00000000   NOP
9D002944  24030003   ADDIU V1, ZERO, 3
9D002948  10430023   BEQ V0, V1, 0x9D0029D8
9D00294C  00000000   NOP
9D002950  0B400A91   J 0x9D002A44
9D002954  00000000   NOP
196:                                         {
197:                                             case SPI_WRITE:
198:                                             {
199:                                                 SPI.RXData[SPI.RXCount++]=SPITemp;
9D002958  3C02A000   LUI V0, -24576
9D00295C  24420230   ADDIU V0, V0, 560
9D002960  90420005   LBU V0, 5(V0)
9D002964  00402821   ADDU A1, V0, ZERO
9D002968  93848028   LBU A0, -32728(GP)
9D00296C  3C03A000   LUI V1, -24576
9D002970  24630230   ADDIU V1, V1, 560
9D002974  00A31821   ADDU V1, A1, V1
9D002978  A064000C   SB A0, 12(V1)
9D00297C  24420001   ADDIU V0, V0, 1
9D002980  304300FF   ANDI V1, V0, 255
9D002984  3C02A000   LUI V0, -24576
9D002988  24420230   ADDIU V0, V0, 560
9D00298C  A0430005   SB V1, 5(V0)
200:                                                 if(SPI.RXCount==SPI_RX_BUFFER_SIZE)
9D002990  3C02A000   LUI V0, -24576
9D002994  24420230   ADDIU V0, V0, 560
9D002998  90430005   LBU V1, 5(V0)
9D00299C  240200FF   ADDIU V0, ZERO, 255
9D0029A0  1462000B   BNE V1, V0, 0x9D0029D0
9D0029A4  00000000   NOP
201:                                                 {
202:                                                     /* error-- went too long*/
203:                                                     SPI.status.RXOverrunError=TRUE;
9D0029A8  3C02A000   LUI V0, -24576
9D0029AC  24430230   ADDIU V1, V0, 560
9D0029B0  8C620008   LW V0, 8(V1)
9D0029B4  24040001   ADDIU A0, ZERO, 1
9D0029B8  7C8218C4   INS V0, A0, 3, 1
9D0029BC  AC620008   SW V0, 8(V1)
204:                                                     SPI.RXState=STATE_SPI_RX_SPI_WRITE_COMPLETE;
9D0029C0  3C02A000   LUI V0, -24576
9D0029C4  24420230   ADDIU V0, V0, 560
9D0029C8  24030008   ADDIU V1, ZERO, 8
9D0029CC  AC430110   SW V1, 272(V0)
205:                                                 }
206:                                                 break;
9D0029D0  0B400A9C   J 0x9D002A70
9D0029D4  00000000   NOP
207:                                             }
208:                                             case SPI_READ:
209:                                             {
210:                                                 SPI.TXIndex = SPI.address.byte.LB % sizeof (TRISThisData);
9D0029D8  3C02A000   LUI V0, -24576
9D0029DC  90430230   LBU V1, 560(V0)
9D0029E0  2402002C   ADDIU V0, ZERO, 44
9D0029E4  0062001B   DIVU V1, V0
9D0029E8  004001F4   TEQ V0, ZERO
9D0029EC  00001010   MFHI V0, 0
9D0029F0  304300FF   ANDI V1, V0, 255
9D0029F4  3C02A000   LUI V0, -24576
9D0029F8  24420230   ADDIU V0, V0, 560
9D0029FC  A043010D   SB V1, 269(V0)
211:                                                 SPI.TXBuffer= TRISThisData.data[SPI.TXIndex];
9D002A00  3C02A000   LUI V0, -24576
9D002A04  24420230   ADDIU V0, V0, 560
9D002A08  9042010D   LBU V0, 269(V0)
9D002A0C  00401821   ADDU V1, V0, ZERO
9D002A10  3C02A000   LUI V0, -24576
9D002A14  24420344   ADDIU V0, V0, 836
9D002A18  00621021   ADDU V0, V1, V0
9D002A1C  90430000   LBU V1, 0(V0)
9D002A20  3C02A000   LUI V0, -24576
9D002A24  24420230   ADDIU V0, V0, 560
9D002A28  A043010C   SB V1, 268(V0)
212:                                                 SPI.RXState = STATE_SPI_RX_READING;
9D002A2C  3C02A000   LUI V0, -24576
9D002A30  24420230   ADDIU V0, V0, 560
9D002A34  24030005   ADDIU V1, ZERO, 5
9D002A38  AC430110   SW V1, 272(V0)
213:                                                 break;
9D002A3C  0B400A9C   J 0x9D002A70
9D002A40  00000000   NOP
214:                                             }
215:                                             default:
216:                                             {
217:                                                 SPI.status.unknownCommandRX=TRUE;
9D002A44  3C02A000   LUI V0, -24576
9D002A48  24430230   ADDIU V1, V0, 560
9D002A4C  8C620008   LW V0, 8(V1)
9D002A50  24040001   ADDIU A0, ZERO, 1
9D002A54  7C8239C4   INS V0, A0, 7, 1
9D002A58  AC620008   SW V0, 8(V1)
218:                                                 SPI.RXState=STATE_SPI_RX_MYSTERY;
9D002A5C  3C02A000   LUI V0, -24576
9D002A60  24420230   ADDIU V0, V0, 560
9D002A64  24030006   ADDIU V1, ZERO, 6
9D002A68  AC430110   SW V1, 272(V0)
219:                                                 /* don't know what to do */
220:                                                 break;
9D002A6C  00000000   NOP
221:                                             }
222:                                         } 
223:                                     }
224:                                     break;
9D002A70  0B400AAA   J 0x9D002AA8
9D002A74  00000000   NOP
9D002AA4  00000000   NOP
225:                                 }
226:                                 case STATE_SPI_RX_COMPLETE:
227:                                 case STATE_SPI_RX_SPI_WRITE_COMPLETE:
228:                                 case STATE_SPI_RX_READING:
229:                                 case STATE_SPI_RX_MYSTERY:
230:                                 {
231:                                     break;
9D002A98  00000000   NOP
9D002A9C  0B400AAA   J 0x9D002AA8
9D002AA0  00000000   NOP
232:                                 }
233:                                 default:
234:                                 {
235:                                     SPI.status.RXMysteryState=TRUE;
9D002A78  3C02A000   LUI V0, -24576
9D002A7C  24430230   ADDIU V1, V0, 560
9D002A80  8C620008   LW V0, 8(V1)
9D002A84  24040001   ADDIU A0, ZERO, 1
9D002A88  7C823184   INS V0, A0, 6, 1
9D002A8C  AC620008   SW V0, 8(V1)
236:                                     break;
9D002A90  0B400AAA   J 0x9D002AA8
9D002A94  00000000   NOP
237:                                 }
238:                             }
239:                         }
240:                         //SPI_RX_INTERRUPT_FLAG_CLEAR;
241:                     }
242:                     if(SPI_TX_INTERRUPT_ENABLE&&SPI_TX_INTERRUPT_FLAG)
9D002AA8  3C02BF88   LUI V0, -16504
9D002AAC  8C431060   LW V1, 4192(V0)
9D002AB0  3C020200   LUI V0, 512
9D002AB4  00621024   AND V0, V1, V0
9D002AB8  1040002E   BEQ V0, ZERO, 0x9D002B74
9D002ABC  00000000   NOP
9D002AC0  3C02BF88   LUI V0, -16504
9D002AC4  8C431030   LW V1, 4144(V0)
9D002AC8  3C020200   LUI V0, 512
9D002ACC  00621024   AND V0, V1, V0
9D002AD0  10400028   BEQ V0, ZERO, 0x9D002B74
9D002AD4  00000000   NOP
243:                     {
244:                         SPI_TX_INTERRUPT_FLAG_CLEAR;
9D002AD8  3C02BF88   LUI V0, -16504
9D002ADC  3C030200   LUI V1, 512
9D002AE0  AC431034   SW V1, 4148(V0)
245:                         RPI_SPI_BUF=SPI.TXBuffer;
9D002AE4  3C02A000   LUI V0, -24576
9D002AE8  24420230   ADDIU V0, V0, 560
9D002AEC  9042010C   LBU V0, 268(V0)
9D002AF0  00401821   ADDU V1, V0, ZERO
9D002AF4  3C02BF80   LUI V0, -16512
9D002AF8  AC435E20   SW V1, 24096(V0)
246:                         SPI.TXIndex++;
9D002AFC  3C02A000   LUI V0, -24576
9D002B00  24420230   ADDIU V0, V0, 560
9D002B04  9042010D   LBU V0, 269(V0)
9D002B08  24420001   ADDIU V0, V0, 1
9D002B0C  304300FF   ANDI V1, V0, 255
9D002B10  3C02A000   LUI V0, -24576
9D002B14  24420230   ADDIU V0, V0, 560
9D002B18  A043010D   SB V1, 269(V0)
247:                         SPI.TXIndex = SPI.TXIndex % sizeof (TRISThisData);
9D002B1C  3C02A000   LUI V0, -24576
9D002B20  24420230   ADDIU V0, V0, 560
9D002B24  9043010D   LBU V1, 269(V0)
9D002B28  2402002C   ADDIU V0, ZERO, 44
9D002B2C  0062001B   DIVU V1, V0
9D002B30  004001F4   TEQ V0, ZERO
9D002B34  00001010   MFHI V0, 0
9D002B38  304300FF   ANDI V1, V0, 255
9D002B3C  3C02A000   LUI V0, -24576
9D002B40  24420230   ADDIU V0, V0, 560
9D002B44  A043010D   SB V1, 269(V0)
248:                         /* get the next byte ready */
249:                         SPI.TXBuffer=TRISThisData.data[SPI.TXIndex];
9D002B48  3C02A000   LUI V0, -24576
9D002B4C  24420230   ADDIU V0, V0, 560
9D002B50  9042010D   LBU V0, 269(V0)
9D002B54  00401821   ADDU V1, V0, ZERO
9D002B58  3C02A000   LUI V0, -24576
9D002B5C  24420344   ADDIU V0, V0, 836
9D002B60  00621021   ADDU V0, V1, V0
9D002B64  90430000   LBU V1, 0(V0)
9D002B68  3C02A000   LUI V0, -24576
9D002B6C  24420230   ADDIU V0, V0, 560
9D002B70  A043010C   SB V1, 268(V0)
250:                     }
251:                     if(SPI_INTERRUPT_ERROR_ENABLE&&SPI_INTERRUPT_ERROR_FLAG)
9D002B74  3C02BF88   LUI V0, -16504
9D002B78  8C431060   LW V1, 4192(V0)
9D002B7C  3C020080   LUI V0, 128
9D002B80  00621024   AND V0, V1, V0
9D002B84  10400014   BEQ V0, ZERO, 0x9D002BD8
9D002B88  00000000   NOP
9D002B8C  3C02BF88   LUI V0, -16504
9D002B90  8C431030   LW V1, 4144(V0)
9D002B94  3C020080   LUI V0, 128
9D002B98  00621024   AND V0, V1, V0
9D002B9C  1040000E   BEQ V0, ZERO, 0x9D002BD8
9D002BA0  00000000   NOP
252:                     {
253:                         SPI_INTERRUPT_ERROR_FLAG_CLEAR;
9D002BA4  3C02BF88   LUI V0, -16504
9D002BA8  3C030080   LUI V1, 128
9D002BAC  AC431034   SW V1, 4148(V0)
254:                         RPI_SPI_RX_OVERFLOW_CLEAR;
9D002BB0  3C03BF80   LUI V1, -16512
9D002BB4  8C625E10   LW V0, 24080(V1)
9D002BB8  7C023184   INS V0, ZERO, 6, 1
9D002BBC  AC625E10   SW V0, 24080(V1)
255:                         SPI.status.RXOverflow=TRUE;
9D002BC0  3C02A000   LUI V0, -24576
9D002BC4  24430230   ADDIU V1, V0, 560
9D002BC8  8C620008   LW V0, 8(V1)
9D002BCC  24040001   ADDIU A0, ZERO, 1
9D002BD0  7C822104   INS V0, A0, 4, 1
9D002BD4  AC620008   SW V0, 8(V1)
256:                     }
257:                 }
9D002BD8  03C0E821   ADDU SP, S8, ZERO
9D002BDC  8FA2001C   LW V0, 28(SP)
9D002BE0  00400013   MTLO V0, 0
9D002BE4  8FA30018   LW V1, 24(SP)
9D002BE8  00600011   MTHI V1, 0
9D002BEC  8FBE0014   LW S8, 20(SP)
9D002BF0  8FA50010   LW A1, 16(SP)
9D002BF4  8FA4000C   LW A0, 12(SP)
9D002BF8  8FA30008   LW V1, 8(SP)
9D002BFC  8FA20004   LW V0, 4(SP)
9D002C00  41606000   DI ZERO
9D002C04  000000C0   EHB
9D002C08  8FBA002C   LW K0, 44(SP)
9D002C0C  8FBB0028   LW K1, 40(SP)
9D002C10  409A7000   MTC0 K0, EPC
9D002C14  8FBA0024   LW K0, 36(SP)
9D002C18  27BD0030   ADDIU SP, SP, 48
9D002C1C  409A6002   MTC0 K0, SRSCtl
9D002C20  41DDE800   WRPGPR SP, SP
9D002C24  409B6000   MTC0 K1, Status
9D002C28  42000018   ERET
258:                 
259:                 /******************************************************************************/
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/TRISThis.c  -----------------------------------
1:                   /******************************************************************************/
2:                   /* File:   TRISThis.c                                                         */
3:                   /* Author: matt                                                               */
4:                   /*                                                                            */
5:                   /* Created on September 14, 2013, 4:19 PM                                     */
6:                   /******************************************************************************/
7:                   
8:                   // <editor-fold defaultstate="collapsed" desc="SLA">
9:                   /******************************************************************************/
10:                  /* Software License Agreement                                                 */
11:                  /*                                                                            */
12:                  /*                                                                            */
13:                  /******************************************************************************/
14:                  
15:                  
16:                  #include <common.h>
17:                  #include <LED.h>
18:                  #include <commsToRPi.h>
19:                  #include <int.h>
20:                  #include <PAC1710.h>
21:                  #include <TRISThis.h>
22:                  
23:                  TRISTHIS_DATA_TYPE TRISThisData;
24:                  
25:                  /******************************************************************************/
26:                  
27:                  BOOL TRISThisConfigure(void)
28:                  {
9D002C2C  27BDFFE0   ADDIU SP, SP, -32
9D002C30  AFBF001C   SW RA, 28(SP)
9D002C34  AFBE0018   SW S8, 24(SP)
9D002C38  03A0F021   ADDU S8, SP, ZERO
29:                      int index;
30:                      index=sizeof(TRISThisData);
9D002C3C  2402002C   ADDIU V0, ZERO, 44
9D002C40  AFC20010   SW V0, 16(S8)
31:                      for(index=0;index<sizeof(TRISThisData);index++)
9D002C44  AFC00010   SW ZERO, 16(S8)
9D002C48  0B400B1C   J 0x9D002C70
9D002C4C  00000000   NOP
9D002C64  8FC20010   LW V0, 16(S8)
9D002C68  24420001   ADDIU V0, V0, 1
9D002C6C  AFC20010   SW V0, 16(S8)
9D002C70  8FC20010   LW V0, 16(S8)
9D002C74  2C42002C   SLTIU V0, V0, 44
9D002C78  1440FFF5   BNE V0, ZERO, 0x9D002C50
9D002C7C  00000000   NOP
32:                      {
33:                          TRISThisData.data[index]=0;
9D002C50  3C02A000   LUI V0, -24576
9D002C54  24430344   ADDIU V1, V0, 836
9D002C58  8FC20010   LW V0, 16(S8)
9D002C5C  00621021   ADDU V0, V1, V0
9D002C60  A0400000   SB ZERO, 0(V0)
34:                      }
35:                      TRISThisData.status.configured=FALSE;
9D002C80  3C03A000   LUI V1, -24576
9D002C84  8C620344   LW V0, 836(V1)
9D002C88  7C020004   INS V0, ZERO, 0, 1
9D002C8C  AC620344   SW V0, 836(V1)
36:                      if(TRISThisDigitalConfigure())
9D002C90  0F400B37   JAL TRISThisDigitalConfigure
9D002C94  00000000   NOP
9D002C98  10400006   BEQ V0, ZERO, 0x9D002CB4
9D002C9C  00000000   NOP
37:                      {
38:                          TRISThisData.status.configured=TRUE;
9D002CA0  3C03A000   LUI V1, -24576
9D002CA4  8C620344   LW V0, 836(V1)
9D002CA8  24040001   ADDIU A0, ZERO, 1
9D002CAC  7C820004   INS V0, A0, 0, 1
9D002CB0  AC620344   SW V0, 836(V1)
39:                      }
40:                      return TRISThisData.status.configured;
9D002CB4  3C02A000   LUI V0, -24576
9D002CB8  8C420344   LW V0, 836(V0)
9D002CBC  7C420000   EXT V0, V0, 0, 1
9D002CC0  304200FF   ANDI V0, V0, 255
41:                  }
9D002CC4  03C0E821   ADDU SP, S8, ZERO
9D002CC8  8FBF001C   LW RA, 28(SP)
9D002CCC  8FBE0018   LW S8, 24(SP)
9D002CD0  27BD0020   ADDIU SP, SP, 32
9D002CD4  03E00008   JR RA
9D002CD8  00000000   NOP
42:                  
43:                  /******************************************************************************/
44:                  
45:                  BOOL TRISThisDigitalConfigure(void)
46:                  {
9D002CDC  27BDFFE0   ADDIU SP, SP, -32
9D002CE0  AFBF001C   SW RA, 28(SP)
9D002CE4  AFBE0018   SW S8, 24(SP)
9D002CE8  03A0F021   ADDU S8, SP, ZERO
47:                      UINT32 index;
48:                      IO_OUT00=FALSE;
9D002CEC  3C03BF88   LUI V1, -16504
9D002CF0  8C6260E0   LW V0, 24800(V1)
9D002CF4  7C020844   INS V0, ZERO, 1, 1
9D002CF8  AC6260E0   SW V0, 24800(V1)
49:                      IO_OUT01=FALSE;
9D002CFC  3C03BF88   LUI V1, -16504
9D002D00  8C6260E0   LW V0, 24800(V1)
9D002D04  7C021084   INS V0, ZERO, 2, 1
9D002D08  AC6260E0   SW V0, 24800(V1)
50:                      IO_OUT02=FALSE;
9D002D0C  3C03BF88   LUI V1, -16504
9D002D10  8C6260E0   LW V0, 24800(V1)
9D002D14  7C0218C4   INS V0, ZERO, 3, 1
9D002D18  AC6260E0   SW V0, 24800(V1)
51:                      IO_OUT03=FALSE;
9D002D1C  3C03BF88   LUI V1, -16504
9D002D20  8C6260E0   LW V0, 24800(V1)
9D002D24  7C022104   INS V0, ZERO, 4, 1
9D002D28  AC6260E0   SW V0, 24800(V1)
52:                      IO_OUT04=FALSE;
9D002D2C  3C03BF88   LUI V1, -16504
9D002D30  8C6260E0   LW V0, 24800(V1)
9D002D34  7C022944   INS V0, ZERO, 5, 1
9D002D38  AC6260E0   SW V0, 24800(V1)
53:                      IO_OUT05=FALSE;
9D002D3C  3C03BF88   LUI V1, -16504
9D002D40  8C6260E0   LW V0, 24800(V1)
9D002D44  7C023184   INS V0, ZERO, 6, 1
9D002D48  AC6260E0   SW V0, 24800(V1)
54:                      IO_OUT06=FALSE;
9D002D4C  3C03BF88   LUI V1, -16504
9D002D50  8C6260E0   LW V0, 24800(V1)
9D002D54  7C0239C4   INS V0, ZERO, 7, 1
9D002D58  AC6260E0   SW V0, 24800(V1)
55:                      IO_OUT07=FALSE;
9D002D5C  3C03BF88   LUI V1, -16504
9D002D60  8C6260E0   LW V0, 24800(V1)
9D002D64  7C024204   INS V0, ZERO, 8, 1
9D002D68  AC6260E0   SW V0, 24800(V1)
56:                      IO_OUT08=FALSE;
9D002D6C  3C03BF88   LUI V1, -16504
9D002D70  8C626120   LW V0, 24864(V1)
9D002D74  7C020004   INS V0, ZERO, 0, 1
9D002D78  AC626120   SW V0, 24864(V1)
57:                      IO_OUT09=FALSE;
9D002D7C  3C03BF88   LUI V1, -16504
9D002D80  8C626120   LW V0, 24864(V1)
9D002D84  7C020844   INS V0, ZERO, 1, 1
9D002D88  AC626120   SW V0, 24864(V1)
58:                      IO_OUT10=FALSE;
9D002D8C  3C03BF88   LUI V1, -16504
9D002D90  8C626120   LW V0, 24864(V1)
9D002D94  7C021084   INS V0, ZERO, 2, 1
9D002D98  AC626120   SW V0, 24864(V1)
59:                      IO_OUT11=FALSE;
9D002D9C  3C03BF88   LUI V1, -16504
9D002DA0  8C626120   LW V0, 24864(V1)
9D002DA4  7C0218C4   INS V0, ZERO, 3, 1
9D002DA8  AC626120   SW V0, 24864(V1)
60:                      IO_OUT12=FALSE;
9D002DAC  3C03BF88   LUI V1, -16504
9D002DB0  8C626120   LW V0, 24864(V1)
9D002DB4  7C022104   INS V0, ZERO, 4, 1
9D002DB8  AC626120   SW V0, 24864(V1)
61:                      IO_OUT13=FALSE;
9D002DBC  3C03BF88   LUI V1, -16504
9D002DC0  8C626120   LW V0, 24864(V1)
9D002DC4  7C022944   INS V0, ZERO, 5, 1
9D002DC8  AC626120   SW V0, 24864(V1)
62:                      IO_OUT14=FALSE;
9D002DCC  3C03BF88   LUI V1, -16504
9D002DD0  8C626120   LW V0, 24864(V1)
9D002DD4  7C023184   INS V0, ZERO, 6, 1
9D002DD8  AC626120   SW V0, 24864(V1)
63:                      IO_OUT15=FALSE;
9D002DDC  3C03BF88   LUI V1, -16504
9D002DE0  8C626120   LW V0, 24864(V1)
9D002DE4  7C0239C4   INS V0, ZERO, 7, 1
9D002DE8  AC626120   SW V0, 24864(V1)
64:                      IO_DIRECTION00=TRIS_IN;
9D002DEC  3C03BF88   LUI V1, -16504
9D002DF0  8C6260C0   LW V0, 24768(V1)
9D002DF4  24040001   ADDIU A0, ZERO, 1
9D002DF8  7C820844   INS V0, A0, 1, 1
9D002DFC  AC6260C0   SW V0, 24768(V1)
65:                      IO_DIRECTION01=TRIS_IN;
9D002E00  3C03BF88   LUI V1, -16504
9D002E04  8C6260C0   LW V0, 24768(V1)
9D002E08  24040001   ADDIU A0, ZERO, 1
9D002E0C  7C821084   INS V0, A0, 2, 1
9D002E10  AC6260C0   SW V0, 24768(V1)
66:                      IO_DIRECTION02=TRIS_IN;
9D002E14  3C03BF88   LUI V1, -16504
9D002E18  8C6260C0   LW V0, 24768(V1)
9D002E1C  24040001   ADDIU A0, ZERO, 1
9D002E20  7C8218C4   INS V0, A0, 3, 1
9D002E24  AC6260C0   SW V0, 24768(V1)
67:                      IO_DIRECTION03=TRIS_IN;
9D002E28  3C03BF88   LUI V1, -16504
9D002E2C  8C6260C0   LW V0, 24768(V1)
9D002E30  24040001   ADDIU A0, ZERO, 1
9D002E34  7C822104   INS V0, A0, 4, 1
9D002E38  AC6260C0   SW V0, 24768(V1)
68:                      IO_DIRECTION04=TRIS_IN;
9D002E3C  3C03BF88   LUI V1, -16504
9D002E40  8C6260C0   LW V0, 24768(V1)
9D002E44  24040001   ADDIU A0, ZERO, 1
9D002E48  7C822944   INS V0, A0, 5, 1
9D002E4C  AC6260C0   SW V0, 24768(V1)
69:                      IO_DIRECTION05=TRIS_IN;
9D002E50  3C03BF88   LUI V1, -16504
9D002E54  8C6260C0   LW V0, 24768(V1)
9D002E58  24040001   ADDIU A0, ZERO, 1
9D002E5C  7C823184   INS V0, A0, 6, 1
9D002E60  AC6260C0   SW V0, 24768(V1)
70:                      IO_DIRECTION06=TRIS_IN;
9D002E64  3C03BF88   LUI V1, -16504
9D002E68  8C6260C0   LW V0, 24768(V1)
9D002E6C  24040001   ADDIU A0, ZERO, 1
9D002E70  7C8239C4   INS V0, A0, 7, 1
9D002E74  AC6260C0   SW V0, 24768(V1)
71:                      IO_DIRECTION07=TRIS_IN;
9D002E78  3C03BF88   LUI V1, -16504
9D002E7C  8C6260C0   LW V0, 24768(V1)
9D002E80  24040001   ADDIU A0, ZERO, 1
9D002E84  7C824204   INS V0, A0, 8, 1
9D002E88  AC6260C0   SW V0, 24768(V1)
72:                      IO_DIRECTION08=TRIS_IN;
9D002E8C  3C03BF88   LUI V1, -16504
9D002E90  8C626100   LW V0, 24832(V1)
9D002E94  24040001   ADDIU A0, ZERO, 1
9D002E98  7C820004   INS V0, A0, 0, 1
9D002E9C  AC626100   SW V0, 24832(V1)
73:                      IO_DIRECTION09=TRIS_IN;
9D002EA0  3C03BF88   LUI V1, -16504
9D002EA4  8C626100   LW V0, 24832(V1)
9D002EA8  24040001   ADDIU A0, ZERO, 1
9D002EAC  7C820844   INS V0, A0, 1, 1
9D002EB0  AC626100   SW V0, 24832(V1)
74:                      IO_DIRECTION10=TRIS_IN;
9D002EB4  3C03BF88   LUI V1, -16504
9D002EB8  8C626100   LW V0, 24832(V1)
9D002EBC  24040001   ADDIU A0, ZERO, 1
9D002EC0  7C821084   INS V0, A0, 2, 1
9D002EC4  AC626100   SW V0, 24832(V1)
75:                      IO_DIRECTION11=TRIS_IN;
9D002EC8  3C03BF88   LUI V1, -16504
9D002ECC  8C626100   LW V0, 24832(V1)
9D002ED0  24040001   ADDIU A0, ZERO, 1
9D002ED4  7C8218C4   INS V0, A0, 3, 1
9D002ED8  AC626100   SW V0, 24832(V1)
76:                      IO_DIRECTION12=TRIS_IN;
9D002EDC  3C03BF88   LUI V1, -16504
9D002EE0  8C626100   LW V0, 24832(V1)
9D002EE4  24040001   ADDIU A0, ZERO, 1
9D002EE8  7C822104   INS V0, A0, 4, 1
9D002EEC  AC626100   SW V0, 24832(V1)
77:                      IO_DIRECTION13=TRIS_IN;
9D002EF0  3C03BF88   LUI V1, -16504
9D002EF4  8C626100   LW V0, 24832(V1)
9D002EF8  24040001   ADDIU A0, ZERO, 1
9D002EFC  7C822944   INS V0, A0, 5, 1
9D002F00  AC626100   SW V0, 24832(V1)
78:                      IO_DIRECTION14=TRIS_IN;
9D002F04  3C03BF88   LUI V1, -16504
9D002F08  8C626100   LW V0, 24832(V1)
9D002F0C  24040001   ADDIU A0, ZERO, 1
9D002F10  7C823184   INS V0, A0, 6, 1
9D002F14  AC626100   SW V0, 24832(V1)
79:                      IO_DIRECTION15=TRIS_IN;
9D002F18  3C03BF88   LUI V1, -16504
9D002F1C  8C626100   LW V0, 24832(V1)
9D002F20  24040001   ADDIU A0, ZERO, 1
9D002F24  7C8239C4   INS V0, A0, 7, 1
9D002F28  AC626100   SW V0, 24832(V1)
80:                      /* clear out the data array */
81:                      for(index=0;index<TRISTHIS_DATA_SIZE;index++)
9D002F2C  AFC00010   SW ZERO, 16(S8)
9D002F30  0B400BD6   J 0x9D002F58
9D002F34  00000000   NOP
9D002F4C  8FC20010   LW V0, 16(S8)
9D002F50  24420001   ADDIU V0, V0, 1
9D002F54  AFC20010   SW V0, 16(S8)
9D002F58  8FC20010   LW V0, 16(S8)
9D002F5C  2C42002C   SLTIU V0, V0, 44
9D002F60  1440FFF5   BNE V0, ZERO, 0x9D002F38
9D002F64  00000000   NOP
82:                      {
83:                          TRISThisData.data[index]=0;
9D002F38  3C02A000   LUI V0, -24576
9D002F3C  24430344   ADDIU V1, V0, 836
9D002F40  8FC20010   LW V0, 16(S8)
9D002F44  00621021   ADDU V0, V1, V0
9D002F48  A0400000   SB ZERO, 0(V0)
84:                      }
85:                      /* read in the current state */
86:                      TRISThisData.digital.port.Val=TRISThisReadDigitalInputs();
9D002F68  0F400BF3   JAL TRISThisReadDigitalInputs
9D002F6C  00000000   NOP
9D002F70  00401821   ADDU V1, V0, ZERO
9D002F74  3C02A000   LUI V0, -24576
9D002F78  24420344   ADDIU V0, V0, 836
9D002F7C  AC43000C   SW V1, 12(V0)
87:                      TRISThisData.digital.latch.Val=TRISThisReadDigitalLatches();
9D002F80  0F400C06   JAL TRISThisReadDigitalLatches
9D002F84  00000000   NOP
9D002F88  00401821   ADDU V1, V0, ZERO
9D002F8C  3C02A000   LUI V0, -24576
9D002F90  24420344   ADDIU V0, V0, 836
9D002F94  AC430008   SW V1, 8(V0)
88:                      TRISThisData.digital.direction.Val=TRISThisReadDigitalDirection();
9D002F98  0F400C19   JAL TRISThisReadDigitalDirection
9D002F9C  00000000   NOP
9D002FA0  00401821   ADDU V1, V0, ZERO
9D002FA4  3C02A000   LUI V0, -24576
9D002FA8  24420344   ADDIU V0, V0, 836
9D002FAC  AC430010   SW V1, 16(V0)
89:                      return TRUE;
9D002FB0  24020001   ADDIU V0, ZERO, 1
90:                  }
9D002FB4  03C0E821   ADDU SP, S8, ZERO
9D002FB8  8FBF001C   LW RA, 28(SP)
9D002FBC  8FBE0018   LW S8, 24(SP)
9D002FC0  27BD0020   ADDIU SP, SP, 32
9D002FC4  03E00008   JR RA
9D002FC8  00000000   NOP
91:                  
92:                  /******************************************************************************/
93:                  
94:                  UINT32 TRISThisReadDigitalInputs(void)
95:                  {
9D002FCC  27BDFFF0   ADDIU SP, SP, -16
9D002FD0  AFBE000C   SW S8, 12(SP)
9D002FD4  03A0F021   ADDU S8, SP, ZERO
96:                      UINT32_VAL readTemp;
97:                      readTemp.Val=0;
9D002FD8  AFC00000   SW ZERO, 0(S8)
98:                      readTemp.byte.LB=(0xff&(PORTD>>1));
9D002FDC  3C02BF88   LUI V0, -16504
9D002FE0  8C4260D0   LW V0, 24784(V0)
9D002FE4  00021042   SRL V0, V0, 1
9D002FE8  304200FF   ANDI V0, V0, 255
9D002FEC  A3C20000   SB V0, 0(S8)
99:                      readTemp.byte.HB=(0xff&(PORTE));
9D002FF0  3C02BF88   LUI V0, -16504
9D002FF4  8C426110   LW V0, 24848(V0)
9D002FF8  304200FF   ANDI V0, V0, 255
9D002FFC  A3C20001   SB V0, 1(S8)
100:                     return readTemp.Val;
9D003000  8FC20000   LW V0, 0(S8)
101:                 }
9D003004  03C0E821   ADDU SP, S8, ZERO
9D003008  8FBE000C   LW S8, 12(SP)
9D00300C  27BD0010   ADDIU SP, SP, 16
9D003010  03E00008   JR RA
9D003014  00000000   NOP
102:                 
103:                 /******************************************************************************/
104:                 
105:                 UINT32 TRISThisReadDigitalLatches(void)
106:                 {
9D003018  27BDFFF0   ADDIU SP, SP, -16
9D00301C  AFBE000C   SW S8, 12(SP)
9D003020  03A0F021   ADDU S8, SP, ZERO
107:                     UINT32_VAL readTemp;
108:                     readTemp.Val=0;
9D003024  AFC00000   SW ZERO, 0(S8)
109:                     readTemp.byte.LB=(0xff&(LATD>>1));
9D003028  3C02BF88   LUI V0, -16504
9D00302C  8C4260E0   LW V0, 24800(V0)
9D003030  00021042   SRL V0, V0, 1
9D003034  304200FF   ANDI V0, V0, 255
9D003038  A3C20000   SB V0, 0(S8)
110:                     readTemp.byte.HB=(0xff&(LATE));
9D00303C  3C02BF88   LUI V0, -16504
9D003040  8C426120   LW V0, 24864(V0)
9D003044  304200FF   ANDI V0, V0, 255
9D003048  A3C20001   SB V0, 1(S8)
111:                     return readTemp.Val;
9D00304C  8FC20000   LW V0, 0(S8)
112:                 }
9D003050  03C0E821   ADDU SP, S8, ZERO
9D003054  8FBE000C   LW S8, 12(SP)
9D003058  27BD0010   ADDIU SP, SP, 16
9D00305C  03E00008   JR RA
9D003060  00000000   NOP
113:                 
114:                 /******************************************************************************/
115:                 
116:                 UINT32 TRISThisReadDigitalDirection(void)
117:                 {
9D003064  27BDFFF0   ADDIU SP, SP, -16
9D003068  AFBE000C   SW S8, 12(SP)
9D00306C  03A0F021   ADDU S8, SP, ZERO
118:                     UINT32_VAL readTemp;
119:                     readTemp.Val=0;
9D003070  AFC00000   SW ZERO, 0(S8)
120:                     readTemp.byte.LB=(0xff&(TRISD>>1));
9D003074  3C02BF88   LUI V0, -16504
9D003078  8C4260C0   LW V0, 24768(V0)
9D00307C  00021042   SRL V0, V0, 1
9D003080  304200FF   ANDI V0, V0, 255
9D003084  A3C20000   SB V0, 0(S8)
121:                     readTemp.byte.HB=(0xff&(TRISE));
9D003088  3C02BF88   LUI V0, -16504
9D00308C  8C426100   LW V0, 24832(V0)
9D003090  304200FF   ANDI V0, V0, 255
9D003094  A3C20001   SB V0, 1(S8)
122:                     return readTemp.Val;
9D003098  8FC20000   LW V0, 0(S8)
123:                 }
9D00309C  03C0E821   ADDU SP, S8, ZERO
9D0030A0  8FBE000C   LW S8, 12(SP)
9D0030A4  27BD0010   ADDIU SP, SP, 16
9D0030A8  03E00008   JR RA
9D0030AC  00000000   NOP
124:                 
125:                 /******************************************************************************/
126:                 
127:                 BOOL TRISThisSetDigitalLatches(UINT32_VAL toSet)
128:                 {
9D0030B0  27BDFFF0   ADDIU SP, SP, -16
9D0030B4  AFBE000C   SW S8, 12(SP)
9D0030B8  03A0F021   ADDU S8, SP, ZERO
9D0030BC  AFC40010   SW A0, 16(S8)
129:                     BOOL returnValue=FALSE;
9D0030C0  AFC00000   SW ZERO, 0(S8)
130:                     LATD=toSet.byte.LB<<1;
9D0030C4  93C20010   LBU V0, 16(S8)
9D0030C8  00021040   SLL V0, V0, 1
9D0030CC  00401821   ADDU V1, V0, ZERO
9D0030D0  3C02BF88   LUI V0, -16504
9D0030D4  AC4360E0   SW V1, 24800(V0)
131:                     LATE=toSet.byte.HB;
9D0030D8  93C20011   LBU V0, 17(S8)
9D0030DC  00401821   ADDU V1, V0, ZERO
9D0030E0  3C02BF88   LUI V0, -16504
9D0030E4  AC436120   SW V1, 24864(V0)
132:                     return returnValue;
9D0030E8  8FC20000   LW V0, 0(S8)
133:                 }
9D0030EC  03C0E821   ADDU SP, S8, ZERO
9D0030F0  8FBE000C   LW S8, 12(SP)
9D0030F4  27BD0010   ADDIU SP, SP, 16
9D0030F8  03E00008   JR RA
9D0030FC  00000000   NOP
134:                 
135:                 /******************************************************************************/
136:                 
137:                 BOOL TRISThisSetDigitalDirection(UINT32_VAL toSet)
138:                 {
9D003100  27BDFFF0   ADDIU SP, SP, -16
9D003104  AFBE000C   SW S8, 12(SP)
9D003108  03A0F021   ADDU S8, SP, ZERO
9D00310C  AFC40010   SW A0, 16(S8)
139:                     BOOL returnValue=FALSE;
9D003110  AFC00000   SW ZERO, 0(S8)
140:                     TRISD=toSet.byte.LB<<1;
9D003114  93C20010   LBU V0, 16(S8)
9D003118  00021040   SLL V0, V0, 1
9D00311C  00401821   ADDU V1, V0, ZERO
9D003120  3C02BF88   LUI V0, -16504
9D003124  AC4360C0   SW V1, 24768(V0)
141:                     TRISE=toSet.byte.HB;
9D003128  93C20011   LBU V0, 17(S8)
9D00312C  00401821   ADDU V1, V0, ZERO
9D003130  3C02BF88   LUI V0, -16504
9D003134  AC436100   SW V1, 24832(V0)
142:                     return returnValue;
9D003138  8FC20000   LW V0, 0(S8)
143:                 }
9D00313C  03C0E821   ADDU SP, S8, ZERO
9D003140  8FBE000C   LW S8, 12(SP)
9D003144  27BD0010   ADDIU SP, SP, 16
9D003148  03E00008   JR RA
9D00314C  00000000   NOP
144:                 
145:                 /******************************************************************************/
146:                 
147:                 void DoTRISThis(void)
148:                 {
9D003150  27BDFFE0   ADDIU SP, SP, -32
9D003154  AFBF001C   SW RA, 28(SP)
9D003158  AFBE0018   SW S8, 24(SP)
9D00315C  AFB00014   SW S0, 20(SP)
9D003160  03A0F021   ADDU S8, SP, ZERO
149:                     static UINT32_VAL tempHolding;
150:                 
151:                     TRISThisData.digital.port.Val=TRISThisReadDigitalInputs();
9D003164  0F400BF3   JAL TRISThisReadDigitalInputs
9D003168  00000000   NOP
9D00316C  00401821   ADDU V1, V0, ZERO
9D003170  3C02A000   LUI V0, -24576
9D003174  24420344   ADDIU V0, V0, 836
9D003178  AC43000C   SW V1, 12(V0)
152:                     TRISThisData.digital.latch.Val=TRISThisReadDigitalLatches();
9D00317C  0F400C06   JAL TRISThisReadDigitalLatches
9D003180  00000000   NOP
9D003184  00401821   ADDU V1, V0, ZERO
9D003188  3C02A000   LUI V0, -24576
9D00318C  24420344   ADDIU V0, V0, 836
9D003190  AC430008   SW V1, 8(V0)
153:                     TRISThisData.digital.direction.Val=TRISThisReadDigitalDirection();
9D003194  0F400C19   JAL TRISThisReadDigitalDirection
9D003198  00000000   NOP
9D00319C  00401821   ADDU V1, V0, ZERO
9D0031A0  3C02A000   LUI V0, -24576
9D0031A4  24420344   ADDIU V0, V0, 836
9D0031A8  AC430010   SW V1, 16(V0)
154:                     TRISThisData.status.autoLEDmode=GetLEDAutoMode();
9D0031AC  0F40147E   JAL GetLEDAutoMode
9D0031B0  00000000   NOP
9D0031B4  304200FF   ANDI V0, V0, 255
9D0031B8  30420001   ANDI V0, V0, 1
9D0031BC  304400FF   ANDI A0, V0, 255
9D0031C0  3C03A000   LUI V1, -24576
9D0031C4  8C620344   LW V0, 836(V1)
9D0031C8  7C821084   INS V0, A0, 2, 1
9D0031CC  AC620344   SW V0, 836(V1)
155:                     TRISThisData.status.V5p0Good=P5V_POWER_GOOD;
9D0031D0  3C02BF88   LUI V0, -16504
9D0031D4  8C426110   LW V0, 24848(V0)
9D0031D8  7C420240   EXT V0, V0, 9, 1
9D0031DC  304400FF   ANDI A0, V0, 255
9D0031E0  3C03A000   LUI V1, -24576
9D0031E4  8C620344   LW V0, 836(V1)
9D0031E8  7C820844   INS V0, A0, 1, 1
9D0031EC  AC620344   SW V0, 836(V1)
156:                     if(SPIDataReady())
9D0031F0  0F40089E   JAL SPIDataReady
9D0031F4  00000000   NOP
9D0031F8  1040005C   BEQ V0, ZERO, 0x9D00336C
9D0031FC  00000000   NOP
157:                     {
158:                         /* if there is data available from the SPI, figure out what it is, and*/
159:                         /* put it */
160:                         INTEnable( INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL),INT_DISABLED);
9D003200  24040025   ADDIU A0, ZERO, 37
9D003204  00002821   ADDU A1, ZERO, ZERO
9D003208  0F4016DC   JAL INTEnable
9D00320C  00000000   NOP
161:                         /* called a lot- save churn on the stack?                             */
162:                         static UINT32_VAL tempData;
163:                         /* check the data we read                                             */
164:                         SPIByteGet(INDEX_STATUS_MB,&tempData.byte.MB);
9D003210  00002021   ADDU A0, ZERO, ZERO
9D003214  2785802F   ADDIU A1, GP, -32721
9D003218  0F400879   JAL SPIByteGet
9D00321C  00000000   NOP
165:                         SPIByteGet(INDEX_STATUS_UB,&tempData.byte.UB);
9D003220  24040001   ADDIU A0, ZERO, 1
9D003224  2785802E   ADDIU A1, GP, -32722
9D003228  0F400879   JAL SPIByteGet
9D00322C  00000000   NOP
166:                         SPIByteGet(INDEX_STATUS_HB,&tempData.byte.HB);
9D003230  24040002   ADDIU A0, ZERO, 2
9D003234  2785802D   ADDIU A1, GP, -32723
9D003238  0F400879   JAL SPIByteGet
9D00323C  00000000   NOP
167:                         SPIByteGet(INDEX_STATUS_LB,&tempData.byte.LB);
9D003240  24040003   ADDIU A0, ZERO, 3
9D003244  2785802C   ADDIU A1, GP, -32724
9D003248  0F400879   JAL SPIByteGet
9D00324C  00000000   NOP
168:                         /* tempdata is the status */
169:                         tempData.Val|=STATUS_READ_ONLY_MASK;
9D003250  8F82802C   LW V0, -32724(GP)
9D003254  34420003   ORI V0, V0, 3
9D003258  AF82802C   SW V0, -32724(GP)
170:                         if(tempData.Val!=(TRISThisReadStatus()|STATUS_READ_ONLY_MASK))
9D00325C  8F90802C   LW S0, -32724(GP)
9D003260  0F400D0B   JAL TRISThisReadStatus
9D003264  00000000   NOP
9D003268  34420003   ORI V0, V0, 3
9D00326C  1202000C   BEQ S0, V0, 0x9D0032A0
9D003270  00000000   NOP
171:                         {
172:                             TRISThisSetStatus(tempData.Val);
9D003274  8F82802C   LW V0, -32724(GP)
9D003278  00402021   ADDU A0, V0, ZERO
9D00327C  0F400D1D   JAL TRISThisSetStatus
9D003280  00000000   NOP
173:                             LEDAutoMode(TRISThisData.status.autoLEDmode);
9D003284  3C02A000   LUI V0, -24576
9D003288  8C420344   LW V0, 836(V0)
9D00328C  7C420080   EXT V0, V0, 2, 1
9D003290  304200FF   ANDI V0, V0, 255
9D003294  00402021   ADDU A0, V0, ZERO
9D003298  0F401469   JAL LEDAutoMode
9D00329C  00000000   NOP
174:                         }
175:                         SPIByteGet(INDEX_LED,&tempData.byte.LB);
9D0032A0  24040007   ADDIU A0, ZERO, 7
9D0032A4  2785802C   ADDIU A1, GP, -32724
9D0032A8  0F400879   JAL SPIByteGet
9D0032AC  00000000   NOP
176:                         if(tempData.byte.LB!=ReadLEDs())
9D0032B0  9390802C   LBU S0, -32724(GP)
9D0032B4  0F40133F   JAL ReadLEDs
9D0032B8  00000000   NOP
9D0032BC  12020005   BEQ S0, V0, 0x9D0032D4
9D0032C0  00000000   NOP
177:                         {
178:                             SetLEDs(tempData.byte.LB);
9D0032C4  9382802C   LBU V0, -32724(GP)
9D0032C8  00402021   ADDU A0, V0, ZERO
9D0032CC  0F401388   JAL SetLEDs
9D0032D0  00000000   NOP
179:                         }
180:                         tempData.Val=0;
9D0032D4  AF80802C   SW ZERO, -32724(GP)
181:                         SPIByteGet(INDEX_DIGITAL_DIRECTION_LB,&tempData.byte.LB);
9D0032D8  2404000F   ADDIU A0, ZERO, 15
9D0032DC  2785802C   ADDIU A1, GP, -32724
9D0032E0  0F400879   JAL SPIByteGet
9D0032E4  00000000   NOP
182:                         SPIByteGet(INDEX_DIGITAL_DIRECTION_HB,&tempData.byte.HB);
9D0032E8  2404000E   ADDIU A0, ZERO, 14
9D0032EC  2785802D   ADDIU A1, GP, -32723
9D0032F0  0F400879   JAL SPIByteGet
9D0032F4  00000000   NOP
183:                         if(tempData.Val!=TRISThisReadDigitalDirection())
9D0032F8  8F90802C   LW S0, -32724(GP)
9D0032FC  0F400C19   JAL TRISThisReadDigitalDirection
9D003300  00000000   NOP
9D003304  12020004   BEQ S0, V0, 0x9D003318
9D003308  00000000   NOP
184:                         {
185:                             TRISThisSetDigitalDirection(tempData);
9D00330C  8F84802C   LW A0, -32724(GP)
9D003310  0F400C40   JAL TRISThisSetDigitalDirection
9D003314  00000000   NOP
186:                         }
187:                         tempData.Val=0;
9D003318  AF80802C   SW ZERO, -32724(GP)
188:                         SPIByteGet(INDEX_DIGITAL_LATCH_LB,&tempData.byte.LB);
9D00331C  2404000B   ADDIU A0, ZERO, 11
9D003320  2785802C   ADDIU A1, GP, -32724
9D003324  0F400879   JAL SPIByteGet
9D003328  00000000   NOP
189:                         SPIByteGet(INDEX_DIGITAL_LATCH_HB,&tempData.byte.HB);
9D00332C  2404000A   ADDIU A0, ZERO, 10
9D003330  2785802D   ADDIU A1, GP, -32723
9D003334  0F400879   JAL SPIByteGet
9D003338  00000000   NOP
190:                         if(tempData.Val!=TRISThisReadDigitalLatches())
9D00333C  8F90802C   LW S0, -32724(GP)
9D003340  0F400C06   JAL TRISThisReadDigitalLatches
9D003344  00000000   NOP
9D003348  12020004   BEQ S0, V0, 0x9D00335C
9D00334C  00000000   NOP
191:                         {
192:                             TRISThisSetDigitalLatches(tempData);
9D003350  8F84802C   LW A0, -32724(GP)
9D003354  0F400C2C   JAL TRISThisSetDigitalLatches
9D003358  00000000   NOP
193:                         }
194:                         INTEnable( INT_SOURCE_SPI_TX(RPI_SPI_CHANNEL),INT_ENABLED);
9D00335C  24040025   ADDIU A0, ZERO, 37
9D003360  24050001   ADDIU A1, ZERO, 1
9D003364  0F4016DC   JAL INTEnable
9D003368  00000000   NOP
195:                     }
196:                     /* update the data that the SPI might read */
197:                     if(PAC1710GetData(PAC1710_DATA_CURRENT,&tempHolding.w[0]))
9D00336C  27828030   ADDIU V0, GP, -32720
9D003370  00002021   ADDU A0, ZERO, ZERO
9D003374  00402821   ADDU A1, V0, ZERO
9D003378  0F40083F   JAL PAC1710GetData
9D00337C  00000000   NOP
9D003380  1040000A   BEQ V0, ZERO, 0x9D0033AC
9D003384  00000000   NOP
198:                     {
199:                         TRISThisData.supplyCurrent.w[0]=tempHolding.w[0];
9D003388  97838030   LHU V1, -32720(GP)
9D00338C  3C02A000   LUI V0, -24576
9D003390  24420344   ADDIU V0, V0, 836
9D003394  A4430024   SH V1, 36(V0)
200:                         TRISThisData.status.freshSupplyCurrent=TRUE;
9D003398  3C03A000   LUI V1, -24576
9D00339C  8C620344   LW V0, 836(V1)
9D0033A0  24040001   ADDIU A0, ZERO, 1
9D0033A4  7C822104   INS V0, A0, 4, 1
9D0033A8  AC620344   SW V0, 836(V1)
201:                     }
202:                     if(PAC1710GetData(PAC1710_DATA_VOLTAGE,&tempHolding.w[0]))
9D0033AC  27828030   ADDIU V0, GP, -32720
9D0033B0  24040001   ADDIU A0, ZERO, 1
9D0033B4  00402821   ADDU A1, V0, ZERO
9D0033B8  0F40083F   JAL PAC1710GetData
9D0033BC  00000000   NOP
9D0033C0  1040000A   BEQ V0, ZERO, 0x9D0033EC
9D0033C4  00000000   NOP
203:                     {
204:                         TRISThisData.supplyVoltage.w[0]=tempHolding.w[0];
9D0033C8  97838030   LHU V1, -32720(GP)
9D0033CC  3C02A000   LUI V0, -24576
9D0033D0  24420344   ADDIU V0, V0, 836
9D0033D4  A4430028   SH V1, 40(V0)
205:                         TRISThisData.status.freshSupplyVoltage=TRUE;
9D0033D8  3C03A000   LUI V1, -24576
9D0033DC  8C620344   LW V0, 836(V1)
9D0033E0  24040001   ADDIU A0, ZERO, 1
9D0033E4  7C8218C4   INS V0, A0, 3, 1
9D0033E8  AC620344   SW V0, 836(V1)
206:                     }
207:                     TRISThisData.status.autoLEDmode=GetLEDAutoMode();
9D0033EC  0F40147E   JAL GetLEDAutoMode
9D0033F0  00000000   NOP
9D0033F4  304200FF   ANDI V0, V0, 255
9D0033F8  30420001   ANDI V0, V0, 1
9D0033FC  304400FF   ANDI A0, V0, 255
9D003400  3C03A000   LUI V1, -24576
9D003404  8C620344   LW V0, 836(V1)
9D003408  7C821084   INS V0, A0, 2, 1
9D00340C  AC620344   SW V0, 836(V1)
208:                     
209:                 
210:                 }
9D003410  03C0E821   ADDU SP, S8, ZERO
9D003414  8FBF001C   LW RA, 28(SP)
9D003418  8FBE0018   LW S8, 24(SP)
9D00341C  8FB00014   LW S0, 20(SP)
9D003420  27BD0020   ADDIU SP, SP, 32
9D003424  03E00008   JR RA
9D003428  00000000   NOP
211:                 
212:                 /******************************************************************************/
213:                 
214:                 UINT32 TRISThisReadStatus(void)
215:                 {
9D00342C  27BDFFF8   ADDIU SP, SP, -8
9D003430  AFBE0004   SW S8, 4(SP)
9D003434  03A0F021   ADDU S8, SP, ZERO
216:                     TRISThisData.status.V5p0Good=P5V_POWER_GOOD;
9D003438  3C02BF88   LUI V0, -16504
9D00343C  8C426110   LW V0, 24848(V0)
9D003440  7C420240   EXT V0, V0, 9, 1
9D003444  304400FF   ANDI A0, V0, 255
9D003448  3C03A000   LUI V1, -24576
9D00344C  8C620344   LW V0, 836(V1)
9D003450  7C820844   INS V0, A0, 1, 1
9D003454  AC620344   SW V0, 836(V1)
217:                     return TRISThisData.status.w.Val;
9D003458  3C02A000   LUI V0, -24576
9D00345C  8C420344   LW V0, 836(V0)
218:                 }
9D003460  03C0E821   ADDU SP, S8, ZERO
9D003464  8FBE0004   LW S8, 4(SP)
9D003468  27BD0008   ADDIU SP, SP, 8
9D00346C  03E00008   JR RA
9D003470  00000000   NOP
219:                 
220:                 /******************************************************************************/
221:                 
222:                 UINT32 TRISThisSetStatus(UINT32 toSet)
223:                 {
9D003474  27BDFFE8   ADDIU SP, SP, -24
9D003478  AFBF0014   SW RA, 20(SP)
9D00347C  AFBE0010   SW S8, 16(SP)
9D003480  03A0F021   ADDU S8, SP, ZERO
9D003484  AFC40018   SW A0, 24(S8)
224:                     TRISThisData.status.w.Val=(toSet & ~STATUS_READ_ONLY_MASK)|
9D003488  8FC30018   LW V1, 24(S8)
9D00348C  2402FFFC   ADDIU V0, ZERO, -4
9D003490  00621824   AND V1, V1, V0
9D0034A0  00621825   OR V1, V1, V0
9D0034A4  3C02A000   LUI V0, -24576
9D0034A8  AC430344   SW V1, 836(V0)
225:                             (STATUS_READ_ONLY_MASK & TRISThisData.status.w.Val);
9D003494  3C02A000   LUI V0, -24576
9D003498  8C420344   LW V0, 836(V0)
9D00349C  30420003   ANDI V0, V0, 3
226:                     LEDAutoMode(TRISThisData.status.autoLEDmode);
9D0034AC  3C02A000   LUI V0, -24576
9D0034B0  8C420344   LW V0, 836(V0)
9D0034B4  7C420080   EXT V0, V0, 2, 1
9D0034B8  304200FF   ANDI V0, V0, 255
9D0034BC  00402021   ADDU A0, V0, ZERO
9D0034C0  0F401469   JAL LEDAutoMode
9D0034C4  00000000   NOP
227:                     return TRISThisData.status.w.Val;
9D0034C8  3C02A000   LUI V0, -24576
9D0034CC  8C420344   LW V0, 836(V0)
228:                 }
9D0034D0  03C0E821   ADDU SP, S8, ZERO
9D0034D4  8FBF0014   LW RA, 20(SP)
9D0034D8  8FBE0010   LW S8, 16(SP)
9D0034DC  27BD0018   ADDIU SP, SP, 24
9D0034E0  03E00008   JR RA
9D0034E4  00000000   NOP
229:                 
230:                 /******************************************************************************/
231:                 
232:                 BOOL TRISThisReadLEDMode(void)
233:                 {
9D0034E8  27BDFFF8   ADDIU SP, SP, -8
9D0034EC  AFBE0004   SW S8, 4(SP)
9D0034F0  03A0F021   ADDU S8, SP, ZERO
234:                     return TRISThisData.status.autoLEDmode;
9D0034F4  3C02A000   LUI V0, -24576
9D0034F8  8C420344   LW V0, 836(V0)
9D0034FC  7C420080   EXT V0, V0, 2, 1
9D003500  304200FF   ANDI V0, V0, 255
235:                 }
9D003504  03C0E821   ADDU SP, S8, ZERO
9D003508  8FBE0004   LW S8, 4(SP)
9D00350C  27BD0008   ADDIU SP, SP, 8
9D003510  03E00008   JR RA
9D003514  00000000   NOP
236:                 
237:                 /******************************************************************************/
238:                 
239:                 void TRISThisSetLEDAutoMode(BOOL autoLED)
240:                 {
9D003518  27BDFFE8   ADDIU SP, SP, -24
9D00351C  AFBF0014   SW RA, 20(SP)
9D003520  AFBE0010   SW S8, 16(SP)
9D003524  03A0F021   ADDU S8, SP, ZERO
9D003528  AFC40018   SW A0, 24(S8)
241:                     TRISThisData.status.autoLEDmode=LEDAutoMode(autoLED);
9D00352C  8FC40018   LW A0, 24(S8)
9D003530  0F401469   JAL LEDAutoMode
9D003534  00000000   NOP
9D003538  304200FF   ANDI V0, V0, 255
9D00353C  30420001   ANDI V0, V0, 1
9D003540  304400FF   ANDI A0, V0, 255
9D003544  3C03A000   LUI V1, -24576
9D003548  8C620344   LW V0, 836(V1)
9D00354C  7C821084   INS V0, A0, 2, 1
9D003550  AC620344   SW V0, 836(V1)
242:                 }
9D003554  03C0E821   ADDU SP, S8, ZERO
9D003558  8FBF0014   LW RA, 20(SP)
9D00355C  8FBE0010   LW S8, 16(SP)
9D003560  27BD0018   ADDIU SP, SP, 24
9D003564  03E00008   JR RA
9D003568  00000000   NOP
243:                 
244:                 /******************************************************************************/
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/PAC1710.c  ------------------------------------
1:                   /******************************************************************************/
2:                   /* File:   PAC1710.c                                                          */
3:                   /* Author: Matt Bennett                                                       */
4:                   /*                                                                            */
5:                   /* Created on                                                                 */
6:                   /* Updated August 2013                                                        */
7:                   /******************************************************************************/
8:                   /* code to talk to the PAC1710 power/voltage/current monitor                  */
9:                   /******************************************************************************/
10:                  
11:                  #include <common.h>
12:                  #include <PAC1710.h>
13:                  #include <I2C_Bus_Master.h>
14:                  
15:                  BOOL INTalertAsserted;
16:                  PAC1710_STATUS_FLAGS_TYPE PAC1710SubsystemFlags;
17:                  
18:                  PAC1710_Subsystem_TYPE PAC1710subsystem;
19:                  
20:                  UINT16_VAL monitorCurrentHolding;
21:                  UINT16_VAL monitorVoltageHolding;
22:                  
23:                  /******************************************************************************/
24:                  
25:                  BOOL PAC1710SubsystemInitialize(UINT32 address)
26:                  {
9D00147C  27BDFFE8   ADDIU SP, SP, -24
9D001480  AFBF0014   SW RA, 20(SP)
9D001484  AFBE0010   SW S8, 16(SP)
9D001488  03A0F021   ADDU S8, SP, ZERO
9D00148C  AFC40018   SW A0, 24(S8)
27:                      if(MasterI2CAvailable()&&MasterI2CClaimPort(POWER_MONITOR))
9D001490  0F4004FF   JAL MasterI2CAvailable
9D001494  00000000   NOP
9D001498  1040002E   BEQ V0, ZERO, 0x9D001554
9D00149C  00000000   NOP
9D0014A0  24040002   ADDIU A0, ZERO, 2
9D0014A4  0F4004DA   JAL MasterI2CClaimPort
9D0014A8  00000000   NOP
9D0014AC  10400029   BEQ V0, ZERO, 0x9D001554
9D0014B0  00000000   NOP
28:                      {
29:                          PAC1710SubsystemFlags.w=0;
9D0014B4  AF80804C   SW ZERO, -32692(GP)
30:                          if(PAC1710Present(address))
9D0014B8  8FC40018   LW A0, 24(S8)
9D0014BC  0F40055D   JAL PAC1710Present
9D0014C0  00000000   NOP
9D0014C4  1040001E   BEQ V0, ZERO, 0x9D001540
9D0014C8  00000000   NOP
31:                          {
32:                              if(PAC1710Configure(address))
9D0014CC  8FC40018   LW A0, 24(S8)
9D0014D0  0F4005B3   JAL PAC1710Configure
9D0014D4  00000000   NOP
9D0014D8  10400014   BEQ V0, ZERO, 0x9D00152C
9D0014DC  00000000   NOP
33:                              {
34:                                  PAC1710SubsystemFlags.monitorConfigured=TRUE;
9D0014E0  8F82804C   LW V0, -32692(GP)
9D0014E4  24030001   ADDIU V1, ZERO, 1
9D0014E8  7C620844   INS V0, V1, 1, 1
9D0014EC  AF82804C   SW V0, -32692(GP)
35:                                  /* Yay! */
36:                              }
37:                              else
38:                              {
39:                                  MasterI2CReleasePort();
9D00152C  0F4004F6   JAL MasterI2CReleasePort
9D001530  00000000   NOP
40:                                  return FALSE;
9D001534  00001021   ADDU V0, ZERO, ZERO
9D001538  0B400557   J 0x9D00155C
9D00153C  00000000   NOP
41:                              }
42:                          }
43:                          else
44:                          {
45:                              MasterI2CReleasePort();
9D001540  0F4004F6   JAL MasterI2CReleasePort
9D001544  00000000   NOP
46:                              return FALSE;
9D001548  00001021   ADDU V0, ZERO, ZERO
9D00154C  0B400557   J 0x9D00155C
9D001550  00000000   NOP
9D001554  0B400557   J 0x9D00155C
9D001558  00000000   NOP
47:                              //while(TRUE);
48:                          }
49:                          PAC1710AlertConfigure();
9D0014F0  0F400612   JAL PAC1710AlertConfigure
9D0014F4  00000000   NOP
50:                          /* is at least one configured? */
51:                          PAC1710SubsystemFlags.subsystemConfigured=
9D001504  8F82804C   LW V0, -32692(GP)
9D001508  7C622104   INS V0, V1, 4, 1
9D00150C  AF82804C   SW V0, -32692(GP)
52:                                  PAC1710SubsystemFlags.monitorConfigured;
9D0014F8  8F82804C   LW V0, -32692(GP)
9D0014FC  7C420040   EXT V0, V0, 1, 1
9D001500  304300FF   ANDI V1, V0, 255
53:                          MasterI2CReleasePort();
9D001510  0F4004F6   JAL MasterI2CReleasePort
9D001514  00000000   NOP
54:                          return PAC1710SubsystemFlags.subsystemConfigured;
9D001518  8F82804C   LW V0, -32692(GP)
9D00151C  7C420100   EXT V0, V0, 4, 1
9D001520  304200FF   ANDI V0, V0, 255
9D001524  0B400557   J 0x9D00155C
9D001528  00000000   NOP
55:                      }
56:                  }
9D00155C  03C0E821   ADDU SP, S8, ZERO
9D001560  8FBF0014   LW RA, 20(SP)
9D001564  8FBE0010   LW S8, 16(SP)
9D001568  27BD0018   ADDIU SP, SP, 24
9D00156C  03E00008   JR RA
9D001570  00000000   NOP
57:                  
58:                  /******************************************************************************/
59:                  
60:                  BOOL PAC1710Present(UINT32 address)
61:                  {
9D001574  27BDFFD0   ADDIU SP, SP, -48
9D001578  AFBF002C   SW RA, 44(SP)
9D00157C  AFBE0028   SW S8, 40(SP)
9D001580  03A0F021   ADDU S8, SP, ZERO
9D001584  AFC40030   SW A0, 48(S8)
62:                      UINT8 productID=0;
9D001588  A3C00020   SB ZERO, 32(S8)
63:                      UINT8 SMSCID=0;
9D00158C  A3C00021   SB ZERO, 33(S8)
64:                      UINT8 revision=0;
9D001590  A3C00022   SB ZERO, 34(S8)
65:                      BOOL productIDGoodRead=FALSE;
9D001594  AFC00010   SW ZERO, 16(S8)
66:                      BOOL SMSCIDGoodRead=FALSE;
9D001598  AFC00014   SW ZERO, 20(S8)
67:                      BOOL revisionGoodRead=FALSE;
9D00159C  AFC00018   SW ZERO, 24(S8)
68:                      BOOL returnValue=FALSE;
9D0015A0  AFC0001C   SW ZERO, 28(S8)
69:                      if(MasterI2CHasPort(POWER_MONITOR))
9D0015A4  24040002   ADDIU A0, ZERO, 2
9D0015A8  0F40050E   JAL MasterI2CHasPort
9D0015AC  00000000   NOP
9D0015B0  10400028   BEQ V0, ZERO, 0x9D001654
9D0015B4  00000000   NOP
70:                      //if(MasterI2CAvailable()&&MasterI2CClaimPort(POWER_MONITOR))
71:                      {
72:                          if(MasterI2CReadByte(address,PAC1710_REG_PRODUCT_ID,&productID))
9D0015B8  8FC20030   LW V0, 48(S8)
9D0015BC  304200FF   ANDI V0, V0, 255
9D0015C0  00401821   ADDU V1, V0, ZERO
9D0015C4  27C20020   ADDIU V0, S8, 32
9D0015C8  00602021   ADDU A0, V1, ZERO
9D0015CC  240500FD   ADDIU A1, ZERO, 253
9D0015D0  00403021   ADDU A2, V0, ZERO
9D0015D4  0F4003DE   JAL MasterI2CReadByte
9D0015D8  00000000   NOP
9D0015DC  10400003   BEQ V0, ZERO, 0x9D0015EC
9D0015E0  00000000   NOP
73:                          {
74:                              productIDGoodRead=TRUE;
9D0015E4  24020001   ADDIU V0, ZERO, 1
9D0015E8  AFC20010   SW V0, 16(S8)
75:                          }
76:                          if(MasterI2CReadByte(address,PAC1710_REG_SMSC_ID,&SMSCID))
9D0015EC  8FC20030   LW V0, 48(S8)
9D0015F0  304200FF   ANDI V0, V0, 255
9D0015F4  00401821   ADDU V1, V0, ZERO
9D0015F8  27C20021   ADDIU V0, S8, 33
9D0015FC  00602021   ADDU A0, V1, ZERO
9D001600  240500FE   ADDIU A1, ZERO, 254
9D001604  00403021   ADDU A2, V0, ZERO
9D001608  0F4003DE   JAL MasterI2CReadByte
9D00160C  00000000   NOP
9D001610  10400003   BEQ V0, ZERO, 0x9D001620
9D001614  00000000   NOP
77:                          {
78:                              SMSCIDGoodRead=TRUE;
9D001618  24020001   ADDIU V0, ZERO, 1
9D00161C  AFC20014   SW V0, 20(S8)
79:                          }
80:                          if(MasterI2CReadByte(address,PAC1710_REG_REVISION,&revision))
9D001620  8FC20030   LW V0, 48(S8)
9D001624  304200FF   ANDI V0, V0, 255
9D001628  00401821   ADDU V1, V0, ZERO
9D00162C  27C20022   ADDIU V0, S8, 34
9D001630  00602021   ADDU A0, V1, ZERO
9D001634  240500FF   ADDIU A1, ZERO, 255
9D001638  00403021   ADDU A2, V0, ZERO
9D00163C  0F4003DE   JAL MasterI2CReadByte
9D001640  00000000   NOP
9D001644  10400003   BEQ V0, ZERO, 0x9D001654
9D001648  00000000   NOP
81:                          {
82:                              revisionGoodRead=TRUE;
9D00164C  24020001   ADDIU V0, ZERO, 1
9D001650  AFC20018   SW V0, 24(S8)
83:                          }
84:                      }
85:                      if ((productIDGoodRead&&(productID==PAC1710_PRODUCT_ID))&&
9D001654  8FC20010   LW V0, 16(S8)
9D001658  10400015   BEQ V0, ZERO, 0x9D0016B0
9D00165C  00000000   NOP
9D001660  93C30020   LBU V1, 32(S8)
9D001664  24020058   ADDIU V0, ZERO, 88
9D001668  14620011   BNE V1, V0, 0x9D0016B0
9D00166C  00000000   NOP
9D001670  8FC20014   LW V0, 20(S8)
9D001674  1040000E   BEQ V0, ZERO, 0x9D0016B0
9D001678  00000000   NOP
86:                          (SMSCIDGoodRead&&(SMSCID==PAC1710_SMSC_ID))&&
9D00167C  93C30021   LBU V1, 33(S8)
9D001680  2402005D   ADDIU V0, ZERO, 93
9D001684  1462000A   BNE V1, V0, 0x9D0016B0
9D001688  00000000   NOP
9D00168C  8FC20018   LW V0, 24(S8)
9D001690  10400007   BEQ V0, ZERO, 0x9D0016B0
9D001694  00000000   NOP
87:                          (revisionGoodRead&&(revision==PAC1710_REVISION)))
9D001698  93C30022   LBU V1, 34(S8)
9D00169C  24020081   ADDIU V0, ZERO, 129
9D0016A0  14620003   BNE V1, V0, 0x9D0016B0
9D0016A4  00000000   NOP
88:                      {
89:                          returnValue=TRUE;
9D0016A8  24020001   ADDIU V0, ZERO, 1
9D0016AC  AFC2001C   SW V0, 28(S8)
90:                      }
91:                      //MasterI2CReleasePort();
92:                      return returnValue;
9D0016B0  8FC2001C   LW V0, 28(S8)
93:                  }
9D0016B4  03C0E821   ADDU SP, S8, ZERO
9D0016B8  8FBF002C   LW RA, 44(SP)
9D0016BC  8FBE0028   LW S8, 40(SP)
9D0016C0  27BD0030   ADDIU SP, SP, 48
9D0016C4  03E00008   JR RA
9D0016C8  00000000   NOP
94:                  
95:                  /******************************************************************************/
96:                  
97:                  BOOL PAC1710Configure(UINT32 address)
98:                  {
9D0016CC  27BDFFD0   ADDIU SP, SP, -48
9D0016D0  AFBF002C   SW RA, 44(SP)
9D0016D4  AFBE0028   SW S8, 40(SP)
9D0016D8  03A0F021   ADDU S8, SP, ZERO
9D0016DC  AFC40030   SW A0, 48(S8)
99:                      UINT8 dataRead;
100:                     PAC1710_CONFIGURATION_REG_TYPE config;
101:                     PAC1710_VSENSE_REG_TYPE vsense;
102:                     PAC1710_VSOURCE_SAMPLING_CONFIG_REG_TYPE vsourceConfig;
103:                     BOOL returnValue=FALSE;
9D0016E0  AFC00010   SW ZERO, 16(S8)
104:                     if(MasterI2CHasPort(POWER_MONITOR))
9D0016E4  24040002   ADDIU A0, ZERO, 2
9D0016E8  0F40050E   JAL MasterI2CHasPort
9D0016EC  00000000   NOP
9D0016F0  1040004C   BEQ V0, ZERO, 0x9D001824
9D0016F4  00000000   NOP
105:                     //if(MasterI2CAvailable()&&MasterI2CClaimPort(POWER_MONITOR))
106:                     {
107:                         vsourceConfig.b=0;
9D0016F8  A3C00020   SB ZERO, 32(S8)
108:                         vsense.b=0;
9D0016FC  A3C0001C   SB ZERO, 28(S8)
109:                         config.b=0;
9D001700  A3C00018   SB ZERO, 24(S8)
110:                         config.b=0;
9D001704  A3C00018   SB ZERO, 24(S8)
111:                         vsourceConfig.VSRC_AVG=VSRC_AVERAGE_DISABLED;
9D001708  8FC20020   LW V0, 32(S8)
9D00170C  7C021884   INS V0, ZERO, 2, 2
9D001710  AFC20020   SW V0, 32(S8)
112:                         vsourceConfig.VSRC_SAMP_TIME=VSRC_SAMPLE_TIME_20_MS;
9D001714  8FC20020   LW V0, 32(S8)
9D001718  24030003   ADDIU V1, ZERO, 3
9D00171C  7C620804   INS V0, V1, 0, 2
9D001720  AFC20020   SW V0, 32(S8)
113:                         vsense.CS_RNG=CS_RANGE_10MV;
9D001724  8FC2001C   LW V0, 28(S8)
9D001728  7C020804   INS V0, ZERO, 0, 2
9D00172C  AFC2001C   SW V0, 28(S8)
114:                         vsense.CS_SAMP_AVG=CS_SAMP_DISABLED;
9D001730  8FC2001C   LW V0, 28(S8)
9D001734  7C021884   INS V0, ZERO, 2, 2
9D001738  AFC2001C   SW V0, 28(S8)
115:                         vsense.CS_SAMP_TIME=CS_SAMPLE_TIME_10_MS;
9D00173C  8FC2001C   LW V0, 28(S8)
9D001740  24030002   ADDIU V1, ZERO, 2
9D001744  7C623104   INS V0, V1, 4, 3
9D001748  AFC2001C   SW V0, 28(S8)
116:                         config.CONV_DONE_EN=TRUE;
9D00174C  8FC20018   LW V0, 24(S8)
9D001750  24030001   ADDIU V1, ZERO, 1
9D001754  7C623184   INS V0, V1, 6, 1
9D001758  AFC20018   SW V0, 24(S8)
117:                         //config.MASK_ALL=TRUE;
118:                 
119:                         if(MasterI2CWriteVerifyByteNoRetry(address,PAC1710_REG_CONFIGURATION,config.b))
9D00175C  8FC20030   LW V0, 48(S8)
9D001760  304200FF   ANDI V0, V0, 255
9D001764  00401821   ADDU V1, V0, ZERO
9D001768  93C20018   LBU V0, 24(S8)
9D00176C  00602021   ADDU A0, V1, ZERO
9D001770  00002821   ADDU A1, ZERO, ZERO
9D001774  00403021   ADDU A2, V0, ZERO
9D001778  0F400452   JAL MasterI2CWriteVerifyByteNoRetry
9D00177C  00000000   NOP
9D001780  10400028   BEQ V0, ZERO, 0x9D001824
9D001784  00000000   NOP
120:                         {
121:                             if(MasterI2CWriteVerifyByteNoRetry(address,PAC1710_REG_VSOURCE_CONFIG,vsourceConfig.b))
9D001788  8FC20030   LW V0, 48(S8)
9D00178C  304200FF   ANDI V0, V0, 255
9D001790  00401821   ADDU V1, V0, ZERO
9D001794  93C20020   LBU V0, 32(S8)
9D001798  00602021   ADDU A0, V1, ZERO
9D00179C  2405000A   ADDIU A1, ZERO, 10
9D0017A0  00403021   ADDU A2, V0, ZERO
9D0017A4  0F400452   JAL MasterI2CWriteVerifyByteNoRetry
9D0017A8  00000000   NOP
9D0017AC  1040001D   BEQ V0, ZERO, 0x9D001824
9D0017B0  00000000   NOP
122:                             {
123:                                 if(MasterI2CWriteVerifyByteNoRetry(address,PAC1710_REG_VSENSE_CONFIG,vsense.b))
9D0017B4  8FC20030   LW V0, 48(S8)
9D0017B8  304200FF   ANDI V0, V0, 255
9D0017BC  00401821   ADDU V1, V0, ZERO
9D0017C0  93C2001C   LBU V0, 28(S8)
9D0017C4  00602021   ADDU A0, V1, ZERO
9D0017C8  2405000B   ADDIU A1, ZERO, 11
9D0017CC  00403021   ADDU A2, V0, ZERO
9D0017D0  0F400452   JAL MasterI2CWriteVerifyByteNoRetry
9D0017D4  00000000   NOP
9D0017D8  10400012   BEQ V0, ZERO, 0x9D001824
9D0017DC  00000000   NOP
124:                                 {
125:                                     if(MasterI2CReadByte(address,PAC1710_REG_CONV_RATE,&dataRead))
9D0017E0  8FC20030   LW V0, 48(S8)
9D0017E4  304200FF   ANDI V0, V0, 255
9D0017E8  00401821   ADDU V1, V0, ZERO
9D0017EC  27C20014   ADDIU V0, S8, 20
9D0017F0  00602021   ADDU A0, V1, ZERO
9D0017F4  24050001   ADDIU A1, ZERO, 1
9D0017F8  00403021   ADDU A2, V0, ZERO
9D0017FC  0F4003DE   JAL MasterI2CReadByte
9D001800  00000000   NOP
9D001804  10400007   BEQ V0, ZERO, 0x9D001824
9D001808  00000000   NOP
126:                                     {
127:                                         if(dataRead==0x03)
9D00180C  93C30014   LBU V1, 20(S8)
9D001810  24020003   ADDIU V0, ZERO, 3
9D001814  14620003   BNE V1, V0, 0x9D001824
9D001818  00000000   NOP
128:                                         {
129:                                             returnValue= TRUE;
9D00181C  24020001   ADDIU V0, ZERO, 1
9D001820  AFC20010   SW V0, 16(S8)
130:                                         }
131:                                     }
132:                                 }
133:                             }
134:                         }
135:                     }
136:                     MasterI2CReleasePort();
9D001824  0F4004F6   JAL MasterI2CReleasePort
9D001828  00000000   NOP
137:                     return returnValue;
9D00182C  8FC20010   LW V0, 16(S8)
138:                 }
9D001830  03C0E821   ADDU SP, S8, ZERO
9D001834  8FBF002C   LW RA, 44(SP)
9D001838  8FBE0028   LW S8, 40(SP)
9D00183C  27BD0030   ADDIU SP, SP, 48
9D001840  03E00008   JR RA
9D001844  00000000   NOP
139:                 
140:                 /******************************************************************************/
141:                 
142:                 void PAC1710AlertConfigure(void)
143:                 {
9D001848  27BDFFE8   ADDIU SP, SP, -24
9D00184C  AFBF0014   SW RA, 20(SP)
9D001850  AFBE0010   SW S8, 16(SP)
9D001854  03A0F021   ADDU S8, SP, ZERO
144:                     ALERT_N_DIRECTION=TRIS_IN;
9D001858  3C03BF88   LUI V1, -16504
9D00185C  8C626100   LW V0, 24832(V1)
9D001860  24040001   ADDIU A0, ZERO, 1
9D001864  7C824204   INS V0, A0, 8, 1
9D001868  AC626100   SW V0, 24832(V1)
145:                     INTalertAsserted=FALSE;
9D00186C  AF808054   SW ZERO, -32684(GP)
146:                     PAC1710SubsystemFlags.alertAsserted=FALSE;
9D001870  8F82804C   LW V0, -32692(GP)
9D001874  7C020004   INS V0, ZERO, 0, 1
9D001878  AF82804C   SW V0, -32692(GP)
147:                     INTCONbits.INT1EP=FALSE; /* set for falling edge interrupt */
9D00187C  3C03BF88   LUI V1, -16504
9D001880  8C621000   LW V0, 4096(V1)
9D001884  7C020844   INS V0, ZERO, 1, 1
9D001888  AC621000   SW V0, 4096(V1)
148:                     INTSetVectorPriority(INT_INT1,ALERT_INT_PRIORITY);
9D00188C  24040004   ADDIU A0, ZERO, 4
9D001890  24050004   ADDIU A1, ZERO, 4
9D001894  0F401752   JAL INTSetVectorPriority
9D001898  00000000   NOP
149:                     INTClearFlag(INT_INT1);
9D00189C  24040004   ADDIU A0, ZERO, 4
9D0018A0  0F4017B7   JAL INTClearFlag
9D0018A4  00000000   NOP
150:                     INTEnable(INT_INT1,INT_ENABLED);
9D0018A8  24040004   ADDIU A0, ZERO, 4
9D0018AC  24050001   ADDIU A1, ZERO, 1
9D0018B0  0F4016DC   JAL INTEnable
9D0018B4  00000000   NOP
151:                 }
9D0018B8  03C0E821   ADDU SP, S8, ZERO
9D0018BC  8FBF0014   LW RA, 20(SP)
9D0018C0  8FBE0010   LW S8, 16(SP)
9D0018C4  27BD0018   ADDIU SP, SP, 24
9D0018C8  03E00008   JR RA
9D0018CC  00000000   NOP
152:                 
153:                 /******************************************************************************/
154:                 
155:                 BOOL IsAlertAsserted(void)
156:                 {
9D0018D0  27BDFFE0   ADDIU SP, SP, -32
9D0018D4  AFBF001C   SW RA, 28(SP)
9D0018D8  AFBE0018   SW S8, 24(SP)
9D0018DC  03A0F021   ADDU S8, SP, ZERO
157:                     BOOL returnValue;
158:                     INTEnable(INT_INT1,INT_DISABLED);
9D0018E0  24040004   ADDIU A0, ZERO, 4
9D0018E4  00002821   ADDU A1, ZERO, ZERO
9D0018E8  0F4016DC   JAL INTEnable
9D0018EC  00000000   NOP
159:                     returnValue=INTalertAsserted;
9D0018F0  8F828054   LW V0, -32684(GP)
9D0018F4  AFC20010   SW V0, 16(S8)
160:                     /* if alert is not asserted, re-enable the interrupt */
161:                     if(!returnValue)
9D0018F8  8FC20010   LW V0, 16(S8)
9D0018FC  14400005   BNE V0, ZERO, 0x9D001914
9D001900  00000000   NOP
162:                     {
163:                         INTEnable(INT_INT1,INT_ENABLED);
9D001904  24040004   ADDIU A0, ZERO, 4
9D001908  24050001   ADDIU A1, ZERO, 1
9D00190C  0F4016DC   JAL INTEnable
9D001910  00000000   NOP
164:                     }
165:                     return returnValue;
9D001914  8FC20010   LW V0, 16(S8)
166:                 }
9D001918  03C0E821   ADDU SP, S8, ZERO
9D00191C  8FBF001C   LW RA, 28(SP)
9D001920  8FBE0018   LW S8, 24(SP)
9D001924  27BD0020   ADDIU SP, SP, 32
9D001928  03E00008   JR RA
9D00192C  00000000   NOP
167:                 
168:                 /******************************************************************************/
169:                 
170:                 void ClearAlertAsserted(void)
171:                 {
9D001930  27BDFFE8   ADDIU SP, SP, -24
9D001934  AFBF0014   SW RA, 20(SP)
9D001938  AFBE0010   SW S8, 16(SP)
9D00193C  03A0F021   ADDU S8, SP, ZERO
172:                     INTEnable(INT_INT1,INT_DISABLED);
9D001940  24040004   ADDIU A0, ZERO, 4
9D001944  00002821   ADDU A1, ZERO, ZERO
9D001948  0F4016DC   JAL INTEnable
9D00194C  00000000   NOP
173:                     INTalertAsserted=FALSE;
9D001950  AF808054   SW ZERO, -32684(GP)
174:                     INTEnable(INT_INT1,INT_ENABLED);
9D001954  24040004   ADDIU A0, ZERO, 4
9D001958  24050001   ADDIU A1, ZERO, 1
9D00195C  0F4016DC   JAL INTEnable
9D001960  00000000   NOP
175:                 }
9D001964  03C0E821   ADDU SP, S8, ZERO
9D001968  8FBF0014   LW RA, 20(SP)
9D00196C  8FBE0010   LW S8, 16(SP)
9D001970  27BD0018   ADDIU SP, SP, 24
9D001974  03E00008   JR RA
9D001978  00000000   NOP
176:                 
177:                 /******************************************************************************/
178:                 
179:                 void __ISR (_EXTERNAL_1_VECTOR,ALERT_INT_PRIORITY_ISR) _INT1Interrupt(void)
180:                 {
9D00197C  415DE800   RDPGPR SP, SP
9D001980  401A7000   MFC0 K0, EPC
9D001984  401B6000   MFC0 K1, Status
9D001988  27BDFF90   ADDIU SP, SP, -112
9D00198C  AFBA006C   SW K0, 108(SP)
9D001990  AFBB0068   SW K1, 104(SP)
9D001994  7C1B7844   INS K1, ZERO, 1, 15
9D001998  377B1000   ORI K1, K1, 4096
9D00199C  409B6000   MTC0 K1, Status
9D0019A0  AFBF005C   SW RA, 92(SP)
9D0019A4  AFBE0058   SW S8, 88(SP)
9D0019A8  AFB90054   SW T9, 84(SP)
9D0019AC  AFB80050   SW T8, 80(SP)
9D0019B0  AFAF004C   SW T7, 76(SP)
9D0019B4  AFAE0048   SW T6, 72(SP)
9D0019B8  AFAD0044   SW T5, 68(SP)
9D0019BC  AFAC0040   SW T4, 64(SP)
9D0019C0  AFAB003C   SW T3, 60(SP)
9D0019C4  AFAA0038   SW T2, 56(SP)
9D0019C8  AFA90034   SW T1, 52(SP)
9D0019CC  AFA80030   SW T0, 48(SP)
9D0019D0  AFA7002C   SW A3, 44(SP)
9D0019D4  AFA60028   SW A2, 40(SP)
9D0019D8  AFA50024   SW A1, 36(SP)
9D0019DC  AFA40020   SW A0, 32(SP)
9D0019E0  AFA3001C   SW V1, 28(SP)
9D0019E4  AFA20018   SW V0, 24(SP)
9D0019E8  AFA10014   SW AT, 20(SP)
9D0019EC  00001012   MFLO V0, 0
9D0019F0  AFA20064   SW V0, 100(SP)
9D0019F4  00001810   MFHI V1, 0
9D0019F8  AFA30060   SW V1, 96(SP)
9D0019FC  03A0F021   ADDU S8, SP, ZERO
181:                     INTEnable(INT_INT1,INT_DISABLED);
9D001A00  24040004   ADDIU A0, ZERO, 4
9D001A04  00002821   ADDU A1, ZERO, ZERO
9D001A08  0F4016DC   JAL INTEnable
9D001A0C  00000000   NOP
182:                     INTClearFlag(INT_INT1);
9D001A10  24040004   ADDIU A0, ZERO, 4
9D001A14  0F4017B7   JAL INTClearFlag
9D001A18  00000000   NOP
183:                     INTalertAsserted=TRUE;
9D001A1C  24020001   ADDIU V0, ZERO, 1
9D001A20  AF828054   SW V0, -32684(GP)
184:                 }
9D001A24  03C0E821   ADDU SP, S8, ZERO
9D001A28  8FA20064   LW V0, 100(SP)
9D001A2C  00400013   MTLO V0, 0
9D001A30  8FA30060   LW V1, 96(SP)
9D001A34  00600011   MTHI V1, 0
9D001A38  8FBF005C   LW RA, 92(SP)
9D001A3C  8FBE0058   LW S8, 88(SP)
9D001A40  8FB90054   LW T9, 84(SP)
9D001A44  8FB80050   LW T8, 80(SP)
9D001A48  8FAF004C   LW T7, 76(SP)
9D001A4C  8FAE0048   LW T6, 72(SP)
9D001A50  8FAD0044   LW T5, 68(SP)
9D001A54  8FAC0040   LW T4, 64(SP)
9D001A58  8FAB003C   LW T3, 60(SP)
9D001A5C  8FAA0038   LW T2, 56(SP)
9D001A60  8FA90034   LW T1, 52(SP)
9D001A64  8FA80030   LW T0, 48(SP)
9D001A68  8FA7002C   LW A3, 44(SP)
9D001A6C  8FA60028   LW A2, 40(SP)
9D001A70  8FA50024   LW A1, 36(SP)
9D001A74  8FA40020   LW A0, 32(SP)
9D001A78  8FA3001C   LW V1, 28(SP)
9D001A7C  8FA20018   LW V0, 24(SP)
9D001A80  8FA10014   LW AT, 20(SP)
9D001A84  41606000   DI ZERO
9D001A88  000000C0   EHB
9D001A8C  8FBA006C   LW K0, 108(SP)
9D001A90  8FBB0068   LW K1, 104(SP)
9D001A94  409A7000   MTC0 K0, EPC
9D001A98  27BD0070   ADDIU SP, SP, 112
9D001A9C  41DDE800   WRPGPR SP, SP
9D001AA0  409B6000   MTC0 K1, Status
9D001AA4  42000018   ERET
185:                 
186:                 /******************************************************************************/
187:                 
188:                 BOOL DoPowerMonState(void)
189:                 {
9D001AA8  27BDFFE0   ADDIU SP, SP, -32
9D001AAC  AFBF001C   SW RA, 28(SP)
9D001AB0  AFBE0018   SW S8, 24(SP)
9D001AB4  03A0F021   ADDU S8, SP, ZERO
190:                     static enum POWER_MONITOR_STATE_TYPE state=PM_STATE_IDLE;
191:                     static I2CBUS_COMMAND_TYPE command;
192:                     if(!PAC1710SubsystemFlags.subsystemConfigured)
9D001AB8  8F82804C   LW V0, -32692(GP)
9D001ABC  30420010   ANDI V0, V0, 16
9D001AC0  14400004   BNE V0, ZERO, 0x9D001AD4
9D001AC4  00000000   NOP
193:                     {
194:                         return FALSE;
9D001AC8  00001021   ADDU V0, ZERO, ZERO
9D001ACC  0B4007F3   J 0x9D001FCC
9D001AD0  00000000   NOP
195:                     }
196:                     if(!MasterI2CHasPort(POWER_MONITOR))
9D001AD4  24040002   ADDIU A0, ZERO, 2
9D001AD8  0F40050E   JAL MasterI2CHasPort
9D001ADC  00000000   NOP
9D001AE0  14400010   BNE V0, ZERO, 0x9D001B24
9D001AE4  00000000   NOP
197:                     {
198:                         if(MasterI2CAvailable())
9D001AE8  0F4004FF   JAL MasterI2CAvailable
9D001AEC  00000000   NOP
9D001AF0  10400009   BEQ V0, ZERO, 0x9D001B18
9D001AF4  00000000   NOP
199:                         {
200:                             /* if the port is available, claim it */
201:                             if(!MasterI2CClaimPort(POWER_MONITOR))
9D001AF8  24040002   ADDIU A0, ZERO, 2
9D001AFC  0F4004DA   JAL MasterI2CClaimPort
9D001B00  00000000   NOP
9D001B04  14400007   BNE V0, ZERO, 0x9D001B24
9D001B08  00000000   NOP
202:                             {
203:                                 return FALSE;
9D001B0C  00001021   ADDU V0, ZERO, ZERO
9D001B10  0B4007F3   J 0x9D001FCC
9D001B14  00000000   NOP
204:                             }
205:                         }
206:                         else
207:                         {
208:                             /* port not available */
209:                             return FALSE;
9D001B18  00001021   ADDU V0, ZERO, ZERO
9D001B1C  0B4007F3   J 0x9D001FCC
9D001B20  00000000   NOP
210:                         }
211:                     }
212:                     /* only get here if the port is claimed by the power monitor subsystem */
213:                     PAC1710SubsystemFlags.alertAsserted=IsAlertAsserted();
9D001B24  0F400634   JAL IsAlertAsserted
9D001B28  00000000   NOP
9D001B2C  304200FF   ANDI V0, V0, 255
9D001B30  30420001   ANDI V0, V0, 1
9D001B34  304300FF   ANDI V1, V0, 255
9D001B38  8F82804C   LW V0, -32692(GP)
9D001B3C  7C620004   INS V0, V1, 0, 1
9D001B40  AF82804C   SW V0, -32692(GP)
214:                     switch (state)
9D001B44  8F828020   LW V0, -32736(GP)
9D001B48  2C430009   SLTIU V1, V0, 9
9D001B4C  106000FD   BEQ V1, ZERO, 0x9D001F44
9D001B50  00000000   NOP
9D001B54  00021880   SLL V1, V0, 2
9D001B58  3C029D00   LUI V0, -25344
9D001B5C  24421B70   ADDIU V0, V0, 7024
9D001B60  00621021   ADDU V0, V1, V0
9D001B64  8C420000   LW V0, 0(V0)
9D001B68  00400008   JR V0
9D001B6C  00000000   NOP
215:                     {
216:                         case PM_STATE_IDLE:
217:                         {
218:                             if (PAC1710SubsystemFlags.alertAsserted)
9D001B94  8F82804C   LW V0, -32692(GP)
9D001B98  30420001   ANDI V0, V0, 1
9D001B9C  104000EE   BEQ V0, ZERO, 0x9D001F58
9D001BA0  00000000   NOP
219:                             {
220:                                 if (PAC1710SubsystemFlags.monitorConfigured)
9D001BA4  8F82804C   LW V0, -32692(GP)
9D001BA8  30420002   ANDI V0, V0, 2
9D001BAC  10400005   BEQ V0, ZERO, 0x9D001BC4
9D001BB0  00000000   NOP
221:                                 {
222:                                     state = PM_STATE_CHECK_MONITOR;
9D001BB4  24020001   ADDIU V0, ZERO, 1
9D001BB8  AF828020   SW V0, -32736(GP)
223:                                 } 
224:                                 else
225:                                 {
226:                                     state = PM_STATE_ALERT_WRAP_UP;
9D001BC4  24020008   ADDIU V0, ZERO, 8
9D001BC8  AF828020   SW V0, -32736(GP)
227:                                 }
228:                             }
229:                             break;
9D001BBC  0B4007F2   J 0x9D001FC8
9D001BC0  00000000   NOP
9D001BCC  0B4007F2   J 0x9D001FC8
9D001BD0  00000000   NOP
9D001F58  00000000   NOP
9D001F5C  0B4007F2   J 0x9D001FC8
9D001F60  00000000   NOP
230:                         }
231:                         case PM_STATE_CHECK_MONITOR:
232:                         {
233:                             if (!MasterI2CIsBusy())
9D001BD4  0F400396   JAL MasterI2CIsBusy
9D001BD8  00000000   NOP
9D001BDC  144000E1   BNE V0, ZERO, 0x9D001F64
9D001BE0  00000000   NOP
234:                             {
235:                                 command.status.flags.I2C_read = TRUE;
9D001BE4  3C03A000   LUI V1, -24576
9D001BE8  8C620370   LW V0, 880(V1)
9D001BEC  24040001   ADDIU A0, ZERO, 1
9D001BF0  7C821084   INS V0, A0, 2, 1
9D001BF4  AC620370   SW V0, 880(V1)
236:                                 command.target_address = PAC1710_ADDRESS;
9D001BF8  3C02A000   LUI V0, -24576
9D001BFC  24420370   ADDIU V0, V0, 880
9D001C00  24030030   ADDIU V1, ZERO, 48
9D001C04  A0430004   SB V1, 4(V0)
237:                                 command.Word[0] = PAC1710_REG_HIGH_LIMIT_STATUS;
9D001C08  3C02A000   LUI V0, -24576
9D001C0C  24420370   ADDIU V0, V0, 880
9D001C10  24030004   ADDIU V1, ZERO, 4
9D001C14  A0430005   SB V1, 5(V0)
238:                                 command.WordSize = 1;
9D001C18  3C02A000   LUI V0, -24576
9D001C1C  24420370   ADDIU V0, V0, 880
9D001C20  24030001   ADDIU V1, ZERO, 1
9D001C24  A043001A   SB V1, 26(V0)
239:                                 command.DataSize = 1;
9D001C28  3C02A000   LUI V0, -24576
9D001C2C  24420370   ADDIU V0, V0, 880
9D001C30  24030001   ADDIU V1, ZERO, 1
9D001C34  A0430019   SB V1, 25(V0)
240:                                 if (MasterI2CQueueCommand(&command))
9D001C38  3C02A000   LUI V0, -24576
9D001C3C  24440370   ADDIU A0, V0, 880
9D001C40  0F400271   JAL MasterI2CQueueCommand
9D001C44  00000000   NOP
9D001C48  104000C9   BEQ V0, ZERO, 0x9D001F70
9D001C4C  00000000   NOP
241:                                 {
242:                                     state = PM_STATE_CHECK_MONITOR_WAIT;
9D001C50  24020002   ADDIU V0, ZERO, 2
9D001C54  AF828020   SW V0, -32736(GP)
243:                                 }
244:                             }
245:                             break;
9D001C58  0B4007F2   J 0x9D001FC8
9D001C5C  00000000   NOP
9D001F64  00000000   NOP
9D001F68  0B4007F2   J 0x9D001FC8
9D001F6C  00000000   NOP
9D001F70  00000000   NOP
9D001F74  0B4007F2   J 0x9D001FC8
9D001F78  00000000   NOP
246:                         }
247:                         case PM_STATE_CHECK_MONITOR_WAIT:
248:                         {
249:                             if (MasterI2CUpdateQueuedCommand(&command))
9D001C60  3C02A000   LUI V0, -24576
9D001C64  24440370   ADDIU A0, V0, 880
9D001C68  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D001C6C  00000000   NOP
9D001C70  10400011   BEQ V0, ZERO, 0x9D001CB8
9D001C74  00000000   NOP
250:                             {
251:                                 PAC1710_HIGH_LIMIT_STATUS_REG_TYPE reg;
252:                                 reg.b = command.Data[0];
9D001C78  3C02A000   LUI V0, -24576
9D001C7C  24420370   ADDIU V0, V0, 880
9D001C80  9042000F   LBU V0, 15(V0)
9D001C84  A3C20010   SB V0, 16(S8)
253:                                 if (reg.CONV_DONE)
9D001C88  8FC20010   LW V0, 16(S8)
9D001C8C  30420080   ANDI V0, V0, 128
9D001C90  10400005   BEQ V0, ZERO, 0x9D001CA8
9D001C94  00000000   NOP
254:                                 {
255:                                     state = PM_STATE_READ_MONITOR_VOLTAGE;
9D001C98  24020003   ADDIU V0, ZERO, 3
9D001C9C  AF828020   SW V0, -32736(GP)
256:                                 }
257:                                 else
258:                                 {
259:                                     state = PM_STATE_ALERT_WRAP_UP;
9D001CA8  24020008   ADDIU V0, ZERO, 8
9D001CAC  AF828020   SW V0, -32736(GP)
260:                                 }
261:                             } 
262:                             else if (command.status.flags.I2C_error)
9D001CB8  3C02A000   LUI V0, -24576
9D001CBC  8C420370   LW V0, 880(V0)
9D001CC0  30420040   ANDI V0, V0, 64
9D001CC4  104000AD   BEQ V0, ZERO, 0x9D001F7C
9D001CC8  00000000   NOP
263:                             {
264:                                 /* check the other current monitor */
265:                                 state = PM_STATE_ALERT_WRAP_UP;
9D001CCC  24020008   ADDIU V0, ZERO, 8
9D001CD0  AF828020   SW V0, -32736(GP)
266:                             }
267:                             break;
9D001CA0  0B4007F2   J 0x9D001FC8
9D001CA4  00000000   NOP
9D001CB0  0B4007F2   J 0x9D001FC8
9D001CB4  00000000   NOP
9D001CD4  0B4007F2   J 0x9D001FC8
9D001CD8  00000000   NOP
9D001F7C  00000000   NOP
9D001F80  0B4007F2   J 0x9D001FC8
9D001F84  00000000   NOP
268:                         }
269:                         case PM_STATE_READ_MONITOR_VOLTAGE:
270:                         {
271:                             if (!MasterI2CIsBusy())
9D001CDC  0F400396   JAL MasterI2CIsBusy
9D001CE0  00000000   NOP
9D001CE4  144000A8   BNE V0, ZERO, 0x9D001F88
9D001CE8  00000000   NOP
272:                             {
273:                                 command.status.flags.I2C_read = TRUE;
9D001CEC  3C03A000   LUI V1, -24576
9D001CF0  8C620370   LW V0, 880(V1)
9D001CF4  24040001   ADDIU A0, ZERO, 1
9D001CF8  7C821084   INS V0, A0, 2, 1
9D001CFC  AC620370   SW V0, 880(V1)
274:                                 command.target_address = PAC1710_ADDRESS;
9D001D00  3C02A000   LUI V0, -24576
9D001D04  24420370   ADDIU V0, V0, 880
9D001D08  24030030   ADDIU V1, ZERO, 48
9D001D0C  A0430004   SB V1, 4(V0)
275:                                 command.Word[0] = PAC1710_REG_VSOURCE_VOLTAGE_HIGH;
9D001D10  3C02A000   LUI V0, -24576
9D001D14  24420370   ADDIU V0, V0, 880
9D001D18  24030011   ADDIU V1, ZERO, 17
9D001D1C  A0430005   SB V1, 5(V0)
276:                                 command.WordSize = 1;
9D001D20  3C02A000   LUI V0, -24576
9D001D24  24420370   ADDIU V0, V0, 880
9D001D28  24030001   ADDIU V1, ZERO, 1
9D001D2C  A043001A   SB V1, 26(V0)
277:                                 command.DataSize = 2;
9D001D30  3C02A000   LUI V0, -24576
9D001D34  24420370   ADDIU V0, V0, 880
9D001D38  24030002   ADDIU V1, ZERO, 2
9D001D3C  A0430019   SB V1, 25(V0)
278:                                 if (MasterI2CQueueCommand(&command))
9D001D40  3C02A000   LUI V0, -24576
9D001D44  24440370   ADDIU A0, V0, 880
9D001D48  0F400271   JAL MasterI2CQueueCommand
9D001D4C  00000000   NOP
9D001D50  10400090   BEQ V0, ZERO, 0x9D001F94
9D001D54  00000000   NOP
279:                                 {
280:                                     state = PM_STATE_READ_MONITOR_VOLTAGE_WAIT;
9D001D58  24020004   ADDIU V0, ZERO, 4
9D001D5C  AF828020   SW V0, -32736(GP)
281:                                 }
282:                             }
283:                             break;
9D001D60  0B4007F2   J 0x9D001FC8
9D001D64  00000000   NOP
9D001F88  00000000   NOP
9D001F8C  0B4007F2   J 0x9D001FC8
9D001F90  00000000   NOP
9D001F94  00000000   NOP
9D001F98  0B4007F2   J 0x9D001FC8
9D001F9C  00000000   NOP
284:                         }
285:                         case PM_STATE_READ_MONITOR_VOLTAGE_WAIT:
286:                         {
287:                             if (MasterI2CUpdateQueuedCommand(&command))
9D001D68  3C02A000   LUI V0, -24576
9D001D6C  24440370   ADDIU A0, V0, 880
9D001D70  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D001D74  00000000   NOP
9D001D78  10400011   BEQ V0, ZERO, 0x9D001DC0
9D001D7C  00000000   NOP
288:                             {
289:                                 monitorVoltageHolding.byte.HB = command.Data[0];
9D001D80  3C02A000   LUI V0, -24576
9D001D84  24420370   ADDIU V0, V0, 880
9D001D88  9042000F   LBU V0, 15(V0)
9D001D8C  A382805D   SB V0, -32675(GP)
290:                                 monitorVoltageHolding.byte.LB = command.Data[1];
9D001D90  3C02A000   LUI V0, -24576
9D001D94  24420370   ADDIU V0, V0, 880
9D001D98  90420010   LBU V0, 16(V0)
9D001D9C  A382805C   SB V0, -32676(GP)
291:                                 PAC1710SubsystemFlags.monitorVoltageAvailable = TRUE;
9D001DA0  8F82804C   LW V0, -32692(GP)
9D001DA4  24030001   ADDIU V1, ZERO, 1
9D001DA8  7C6218C4   INS V0, V1, 3, 1
9D001DAC  AF82804C   SW V0, -32692(GP)
292:                                 state = PM_STATE_READ_MONITOR_CURRENT;
9D001DB0  24020005   ADDIU V0, ZERO, 5
9D001DB4  AF828020   SW V0, -32736(GP)
293:                             } 
294:                             else if (command.status.flags.I2C_error)
9D001DC0  3C02A000   LUI V0, -24576
9D001DC4  8C420370   LW V0, 880(V0)
9D001DC8  30420040   ANDI V0, V0, 64
9D001DCC  10400074   BEQ V0, ZERO, 0x9D001FA0
9D001DD0  00000000   NOP
295:                             {
296:                                 /* check the other current monitor */
297:                                 state = PM_STATE_ALERT_WRAP_UP;
9D001DD4  24020008   ADDIU V0, ZERO, 8
9D001DD8  AF828020   SW V0, -32736(GP)
298:                             }
299:                             break;
9D001DB8  0B4007F2   J 0x9D001FC8
9D001DBC  00000000   NOP
9D001DDC  0B4007F2   J 0x9D001FC8
9D001DE0  00000000   NOP
9D001FA0  00000000   NOP
9D001FA4  0B4007F2   J 0x9D001FC8
9D001FA8  00000000   NOP
300:                         }
301:                         case PM_STATE_READ_MONITOR_CURRENT:
302:                         {
303:                             if (!MasterI2CIsBusy())
9D001DE4  0F400396   JAL MasterI2CIsBusy
9D001DE8  00000000   NOP
9D001DEC  1440006F   BNE V0, ZERO, 0x9D001FAC
9D001DF0  00000000   NOP
304:                             {
305:                                 command.status.flags.I2C_read = TRUE;
9D001DF4  3C03A000   LUI V1, -24576
9D001DF8  8C620370   LW V0, 880(V1)
9D001DFC  24040001   ADDIU A0, ZERO, 1
9D001E00  7C821084   INS V0, A0, 2, 1
9D001E04  AC620370   SW V0, 880(V1)
306:                                 command.target_address = PAC1710_ADDRESS;
9D001E08  3C02A000   LUI V0, -24576
9D001E0C  24420370   ADDIU V0, V0, 880
9D001E10  24030030   ADDIU V1, ZERO, 48
9D001E14  A0430004   SB V1, 4(V0)
307:                                 command.Word[0] = PAC1710_REG_SENSE_VOLTAGE_HIGH;
9D001E18  3C02A000   LUI V0, -24576
9D001E1C  24420370   ADDIU V0, V0, 880
9D001E20  2403000D   ADDIU V1, ZERO, 13
9D001E24  A0430005   SB V1, 5(V0)
308:                                 command.WordSize = 1;
9D001E28  3C02A000   LUI V0, -24576
9D001E2C  24420370   ADDIU V0, V0, 880
9D001E30  24030001   ADDIU V1, ZERO, 1
9D001E34  A043001A   SB V1, 26(V0)
309:                                 command.DataSize = 2;
9D001E38  3C02A000   LUI V0, -24576
9D001E3C  24420370   ADDIU V0, V0, 880
9D001E40  24030002   ADDIU V1, ZERO, 2
9D001E44  A0430019   SB V1, 25(V0)
310:                                 if (MasterI2CQueueCommand(&command))
9D001E48  3C02A000   LUI V0, -24576
9D001E4C  24440370   ADDIU A0, V0, 880
9D001E50  0F400271   JAL MasterI2CQueueCommand
9D001E54  00000000   NOP
9D001E58  10400057   BEQ V0, ZERO, 0x9D001FB8
9D001E5C  00000000   NOP
311:                                 {
312:                                     state = PM_STATE_READ_MONITOR_CURRENT_WAIT;
9D001E60  24020006   ADDIU V0, ZERO, 6
9D001E64  AF828020   SW V0, -32736(GP)
313:                                 }
314:                             }
315:                             break;
9D001E68  0B4007F2   J 0x9D001FC8
9D001E6C  00000000   NOP
9D001FAC  00000000   NOP
9D001FB0  0B4007F2   J 0x9D001FC8
9D001FB4  00000000   NOP
9D001FB8  00000000   NOP
9D001FBC  0B4007F2   J 0x9D001FC8
9D001FC0  00000000   NOP
316:                         }
317:                         case PM_STATE_READ_MONITOR_CURRENT_WAIT:
318:                         {
319:                             if (MasterI2CUpdateQueuedCommand(&command))
9D001E70  3C02A000   LUI V0, -24576
9D001E74  24440370   ADDIU A0, V0, 880
9D001E78  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D001E7C  00000000   NOP
9D001E80  10400011   BEQ V0, ZERO, 0x9D001EC8
9D001E84  00000000   NOP
320:                             {
321:                                 monitorCurrentHolding.byte.HB = command.Data[0];
9D001E88  3C02A000   LUI V0, -24576
9D001E8C  24420370   ADDIU V0, V0, 880
9D001E90  9042000F   LBU V0, 15(V0)
9D001E94  A3828049   SB V0, -32695(GP)
322:                                 monitorCurrentHolding.byte.LB = command.Data[1];
9D001E98  3C02A000   LUI V0, -24576
9D001E9C  24420370   ADDIU V0, V0, 880
9D001EA0  90420010   LBU V0, 16(V0)
9D001EA4  A3828048   SB V0, -32696(GP)
323:                                 PAC1710SubsystemFlags.monitorCurrentAvailable = TRUE;
9D001EA8  8F82804C   LW V0, -32692(GP)
9D001EAC  24030001   ADDIU V1, ZERO, 1
9D001EB0  7C621084   INS V0, V1, 2, 1
9D001EB4  AF82804C   SW V0, -32692(GP)
324:                                 state = PM_STATE_ALERT_WRAP_UP;
9D001EB8  24020008   ADDIU V0, ZERO, 8
9D001EBC  AF828020   SW V0, -32736(GP)
325:                             } 
326:                             else if (command.status.flags.I2C_error)
9D001EC8  3C02A000   LUI V0, -24576
9D001ECC  8C420370   LW V0, 880(V0)
9D001ED0  30420040   ANDI V0, V0, 64
9D001ED4  1040003B   BEQ V0, ZERO, 0x9D001FC4
9D001ED8  00000000   NOP
327:                             {
328:                                 /* check the other current monitor */
329:                                 state = PM_STATE_ALERT_WRAP_UP;
9D001EDC  24020008   ADDIU V0, ZERO, 8
9D001EE0  AF828020   SW V0, -32736(GP)
330:                             }
331:                             break;
9D001EC0  0B4007F2   J 0x9D001FC8
9D001EC4  00000000   NOP
9D001EE4  0B4007F2   J 0x9D001FC8
9D001EE8  00000000   NOP
9D001FC4  00000000   NOP
332:                         }
333:                         case PM_STATE_MONITOR_WRAP_UP:
334:                         case PM_STATE_ALERT_WRAP_UP:
335:                         {
336:                             MasterI2CReleasePort();
9D001EEC  0F4004F6   JAL MasterI2CReleasePort
9D001EF0  00000000   NOP
337:                             if (PAC1710SubsystemFlags.monitorVoltageAvailable ||
9D001EF4  8F82804C   LW V0, -32692(GP)
9D001EF8  30420008   ANDI V0, V0, 8
9D001EFC  14400005   BNE V0, ZERO, 0x9D001F14
9D001F00  00000000   NOP
9D001F04  8F82804C   LW V0, -32692(GP)
9D001F08  30420004   ANDI V0, V0, 4
9D001F0C  10400005   BEQ V0, ZERO, 0x9D001F24
9D001F10  00000000   NOP
338:                                     PAC1710SubsystemFlags.monitorCurrentAvailable)
339:                             {
340:                                 PAC1710SubsystemFlags.newDataAvailable = TRUE;
9D001F14  8F82804C   LW V0, -32692(GP)
9D001F18  24030001   ADDIU V1, ZERO, 1
9D001F1C  7C622944   INS V0, V1, 5, 1
9D001F20  AF82804C   SW V0, -32692(GP)
341:                             }
342:                             ClearAlertAsserted();
9D001F24  0F40064C   JAL ClearAlertAsserted
9D001F28  00000000   NOP
343:                             PAC1710SubsystemFlags.alertAsserted = FALSE;
9D001F2C  8F82804C   LW V0, -32692(GP)
9D001F30  7C020004   INS V0, ZERO, 0, 1
9D001F34  AF82804C   SW V0, -32692(GP)
344:                             state = PM_STATE_IDLE;
9D001F38  AF808020   SW ZERO, -32736(GP)
345:                             break;
9D001F3C  0B4007F2   J 0x9D001FC8
9D001F40  00000000   NOP
346:                         }
347:                         default:
348:                         {
349:                             MasterI2CReleasePort();
9D001F44  0F4004F6   JAL MasterI2CReleasePort
9D001F48  00000000   NOP
350:                             state = PM_STATE_IDLE;
9D001F4C  AF808020   SW ZERO, -32736(GP)
351:                             break;
9D001F50  0B4007F2   J 0x9D001FC8
9D001F54  00000000   NOP
352:                         }
353:                     }
354:                     return TRUE;
9D001FC8  24020001   ADDIU V0, ZERO, 1
355:                 }
9D001FCC  03C0E821   ADDU SP, S8, ZERO
9D001FD0  8FBF001C   LW RA, 28(SP)
9D001FD4  8FBE0018   LW S8, 24(SP)
9D001FD8  27BD0020   ADDIU SP, SP, 32
9D001FDC  03E00008   JR RA
9D001FE0  00000000   NOP
356:                 
357:                 /******************************************************************************/
358:                 
359:                 BOOL GetCurrentData(UINT32 address, INT16 *current)
360:                 {
9D001FE4  27BDFFF0   ADDIU SP, SP, -16
9D001FE8  AFBE000C   SW S8, 12(SP)
9D001FEC  03A0F021   ADDU S8, SP, ZERO
9D001FF0  AFC40010   SW A0, 16(S8)
9D001FF4  AFC50014   SW A1, 20(S8)
361:                     BOOL returnValue=FALSE;
9D001FF8  AFC00000   SW ZERO, 0(S8)
362:                     switch(address)
9D001FFC  8FC30010   LW V1, 16(S8)
9D002000  24020030   ADDIU V0, ZERO, 48
9D002004  14620010   BNE V1, V0, 0x9D002048
9D002008  00000000   NOP
363:                     {
364:                         case PAC1710_ADDRESS:
365:                         {
366:                             if(PAC1710SubsystemFlags.monitorCurrentAvailable)
9D00200C  8F82804C   LW V0, -32692(GP)
9D002010  30420004   ANDI V0, V0, 4
9D002014  1040000F   BEQ V0, ZERO, 0x9D002054
9D002018  00000000   NOP
367:                             {
368:                                 PAC1710SubsystemFlags.monitorCurrentAvailable=FALSE;
9D00201C  8F82804C   LW V0, -32692(GP)
9D002020  7C021084   INS V0, ZERO, 2, 1
9D002024  AF82804C   SW V0, -32692(GP)
369:                                 *current=(INT16)monitorCurrentHolding.Val;
9D002028  97828048   LHU V0, -32696(GP)
9D00202C  7C021E20   SEH V1, V0
9D002030  8FC20014   LW V0, 20(S8)
9D002034  A4430000   SH V1, 0(V0)
370:                                 returnValue=TRUE;
9D002038  24020001   ADDIU V0, ZERO, 1
9D00203C  AFC20000   SW V0, 0(S8)
371:                             }
372:                             break;
9D002040  0B400816   J 0x9D002058
9D002044  00000000   NOP
9D002054  00000000   NOP
373:                         }
374:                         default:
375:                         {
376:                             break;
9D002048  00000000   NOP
9D00204C  0B400816   J 0x9D002058
9D002050  00000000   NOP
377:                         }
378:                     }
379:                     return returnValue;
9D002058  8FC20000   LW V0, 0(S8)
380:                 }
9D00205C  03C0E821   ADDU SP, S8, ZERO
9D002060  8FBE000C   LW S8, 12(SP)
9D002064  27BD0010   ADDIU SP, SP, 16
9D002068  03E00008   JR RA
9D00206C  00000000   NOP
381:                 
382:                 /******************************************************************************/
383:                 
384:                 BOOL GetVoltageData(UINT32 address, INT16 *voltage)
385:                 {
9D002070  27BDFFF0   ADDIU SP, SP, -16
9D002074  AFBE000C   SW S8, 12(SP)
9D002078  03A0F021   ADDU S8, SP, ZERO
9D00207C  AFC40010   SW A0, 16(S8)
9D002080  AFC50014   SW A1, 20(S8)
386:                     BOOL returnValue=FALSE;
9D002084  AFC00000   SW ZERO, 0(S8)
387:                     switch(address)
9D002088  8FC30010   LW V1, 16(S8)
9D00208C  24020030   ADDIU V0, ZERO, 48
9D002090  14620010   BNE V1, V0, 0x9D0020D4
9D002094  00000000   NOP
388:                     {
389:                         case PAC1710_ADDRESS:
390:                         {
391:                             if(PAC1710SubsystemFlags.monitorVoltageAvailable)
9D002098  8F82804C   LW V0, -32692(GP)
9D00209C  30420008   ANDI V0, V0, 8
9D0020A0  1040000F   BEQ V0, ZERO, 0x9D0020E0
9D0020A4  00000000   NOP
392:                             {
393:                                 PAC1710SubsystemFlags.monitorVoltageAvailable=FALSE;
9D0020A8  8F82804C   LW V0, -32692(GP)
9D0020AC  7C0218C4   INS V0, ZERO, 3, 1
9D0020B0  AF82804C   SW V0, -32692(GP)
394:                                 *voltage=(INT16)monitorVoltageHolding.Val;
9D0020B4  9782805C   LHU V0, -32676(GP)
9D0020B8  7C021E20   SEH V1, V0
9D0020BC  8FC20014   LW V0, 20(S8)
9D0020C0  A4430000   SH V1, 0(V0)
395:                                 returnValue=TRUE;
9D0020C4  24020001   ADDIU V0, ZERO, 1
9D0020C8  AFC20000   SW V0, 0(S8)
396:                             }
397:                             break;
9D0020CC  0B400839   J 0x9D0020E4
9D0020D0  00000000   NOP
9D0020E0  00000000   NOP
398:                         }
399:                         default:
400:                         {
401:                             break;
9D0020D4  00000000   NOP
9D0020D8  0B400839   J 0x9D0020E4
9D0020DC  00000000   NOP
402:                         }
403:                     }
404:                     return returnValue;
9D0020E4  8FC20000   LW V0, 0(S8)
405:                 }
9D0020E8  03C0E821   ADDU SP, S8, ZERO
9D0020EC  8FBE000C   LW S8, 12(SP)
9D0020F0  27BD0010   ADDIU SP, SP, 16
9D0020F4  03E00008   JR RA
9D0020F8  00000000   NOP
406:                 
407:                 /******************************************************************************/
408:                 
409:                 
410:                 BOOL PAC1710GetData(enum PAC1710_DATA_TYPE what, INT16 *data)
411:                 {
9D0020FC  27BDFFE0   ADDIU SP, SP, -32
9D002100  AFBF001C   SW RA, 28(SP)
9D002104  AFBE0018   SW S8, 24(SP)
9D002108  03A0F021   ADDU S8, SP, ZERO
9D00210C  AFC40020   SW A0, 32(S8)
9D002110  AFC50024   SW A1, 36(S8)
412:                     BOOL returnValue=FALSE;
9D002114  AFC00010   SW ZERO, 16(S8)
413:                     INT16 holding;
414:                     switch(what)
9D002118  8FC20020   LW V0, 32(S8)
9D00211C  10400006   BEQ V0, ZERO, 0x9D002138
9D002120  00000000   NOP
9D002124  24030001   ADDIU V1, ZERO, 1
9D002128  10430013   BEQ V0, V1, 0x9D002178
9D00212C  00000000   NOP
415:                     {
416:                         case PAC1710_DATA_CURRENT:
417:                         {
418:                             if(GetCurrentData(PAC1710_ADDRESS,&holding))
9D002138  27C20014   ADDIU V0, S8, 20
9D00213C  24040030   ADDIU A0, ZERO, 48
9D002140  00402821   ADDU A1, V0, ZERO
9D002144  0F4007F9   JAL GetCurrentData
9D002148  00000000   NOP
9D00214C  1040001A   BEQ V0, ZERO, 0x9D0021B8
9D002150  00000000   NOP
419:                             {
420:                                 *data=holding>>4;
9D002154  87C20014   LH V0, 20(S8)
9D002158  00021103   SRA V0, V0, 4
9D00215C  7C021E20   SEH V1, V0
9D002160  8FC20024   LW V0, 36(S8)
9D002164  A4430000   SH V1, 0(V0)
421:                                 returnValue=TRUE;
9D002168  24020001   ADDIU V0, ZERO, 1
9D00216C  AFC20010   SW V0, 16(S8)
422:                             }
423:                             break;
9D002170  0B400872   J 0x9D0021C8
9D002174  00000000   NOP
9D0021B8  00000000   NOP
9D0021BC  0B400872   J 0x9D0021C8
9D0021C0  00000000   NOP
424:                         }
425:                         case PAC1710_DATA_VOLTAGE:
426:                         {
427:                             if(GetVoltageData(PAC1710_ADDRESS,&holding))
9D002178  27C20014   ADDIU V0, S8, 20
9D00217C  24040030   ADDIU A0, ZERO, 48
9D002180  00402821   ADDU A1, V0, ZERO
9D002184  0F40081C   JAL GetVoltageData
9D002188  00000000   NOP
9D00218C  1040000D   BEQ V0, ZERO, 0x9D0021C4
9D002190  00000000   NOP
428:                             {
429:                                 *data=holding>>5;
9D002194  87C20014   LH V0, 20(S8)
9D002198  00021143   SRA V0, V0, 5
9D00219C  7C021E20   SEH V1, V0
9D0021A0  8FC20024   LW V0, 36(S8)
9D0021A4  A4430000   SH V1, 0(V0)
430:                                 returnValue=TRUE;
9D0021A8  24020001   ADDIU V0, ZERO, 1
9D0021AC  AFC20010   SW V0, 16(S8)
431:                             }
432:                             break;
9D0021B0  0B400872   J 0x9D0021C8
9D0021B4  00000000   NOP
9D0021C4  00000000   NOP
433:                         }
434:                         default:
435:                         {
436:                             break;
9D002130  0B400872   J 0x9D0021C8
9D002134  00000000   NOP
437:                         }
438:                     }
439:                     return returnValue;
9D0021C8  8FC20010   LW V0, 16(S8)
440:                 }
9D0021CC  03C0E821   ADDU SP, S8, ZERO
9D0021D0  8FBF001C   LW RA, 28(SP)
9D0021D4  8FBE0018   LW S8, 24(SP)
9D0021D8  27BD0020   ADDIU SP, SP, 32
9D0021DC  03E00008   JR RA
9D0021E0  00000000   NOP
441:                 /******************************************************************************/
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/MCP4461.c  ------------------------------------
1:                   #include <common.h>
2:                   #include <MCP4461.h>
3:                   #include <I2C_Bus_Master.h>
4:                   
5:                   DIGIPOT_SUBSYSTEM_TYPE digipotStatus;
6:                   DIGIPOT_TYPE digipot;
7:                   
8:                   BOOL DigipotStartGetStatus(void)
9:                   {
9D00356C  27BDFFF8   ADDIU SP, SP, -8
9D003570  AFBE0004   SW S8, 4(SP)
9D003574  03A0F021   ADDU S8, SP, ZERO
10:                      if(!digipotStatus.reading&&!digipotStatus.readStatus)
9D003578  8F828060   LW V0, -32672(GP)
9D00357C  30420040   ANDI V0, V0, 64
9D003580  1440000C   BNE V0, ZERO, 0x9D0035B4
9D003584  00000000   NOP
9D003588  8F828060   LW V0, -32672(GP)
9D00358C  30420100   ANDI V0, V0, 256
9D003590  14400008   BNE V0, ZERO, 0x9D0035B4
9D003594  00000000   NOP
11:                      {
12:                          digipotStatus.readStatus=TRUE;
9D003598  8F828060   LW V0, -32672(GP)
9D00359C  24030001   ADDIU V1, ZERO, 1
9D0035A0  7C624204   INS V0, V1, 8, 1
9D0035A4  AF828060   SW V0, -32672(GP)
13:                          return TRUE;
9D0035A8  24020001   ADDIU V0, ZERO, 1
9D0035AC  0B400D6E   J 0x9D0035B8
9D0035B0  00000000   NOP
14:                      }
15:                      return FALSE;
9D0035B4  00001021   ADDU V0, ZERO, ZERO
16:                  }
9D0035B8  03C0E821   ADDU SP, S8, ZERO
9D0035BC  8FBE0004   LW S8, 4(SP)
9D0035C0  27BD0008   ADDIU SP, SP, 8
9D0035C4  03E00008   JR RA
9D0035C8  00000000   NOP
17:                  
18:                  UINT8 DigipotGetStatus(void)
19:                  {
9D0035CC  27BDFFF8   ADDIU SP, SP, -8
9D0035D0  AFBE0004   SW S8, 4(SP)
9D0035D4  03A0F021   ADDU S8, SP, ZERO
20:                      return digipot.STATUS.b;
9D0035D8  3C02A000   LUI V0, -24576
9D0035DC  24420200   ADDIU V0, V0, 512
9D0035E0  9042002C   LBU V0, 44(V0)
21:                  }
9D0035E4  03C0E821   ADDU SP, S8, ZERO
9D0035E8  8FBE0004   LW S8, 4(SP)
9D0035EC  27BD0008   ADDIU SP, SP, 8
9D0035F0  03E00008   JR RA
9D0035F4  00000000   NOP
22:                  
23:                  BOOL DigipotGetReading(UINT8 channel,UINT16 *data)
24:                  {
9D0035F8  27BDFFF8   ADDIU SP, SP, -8
9D0035FC  AFBE0004   SW S8, 4(SP)
9D003600  03A0F021   ADDU S8, SP, ZERO
9D003604  00801021   ADDU V0, A0, ZERO
9D003608  AFC5000C   SW A1, 12(S8)
9D00360C  A3C20008   SB V0, 8(S8)
25:                      if((channel<4)&&(digipot.value[channel].goodRead))
9D003610  93C20008   LBU V0, 8(S8)
9D003614  2C420004   SLTIU V0, V0, 4
9D003618  10400019   BEQ V0, ZERO, 0x9D003680
9D00361C  00000000   NOP
9D003620  93C30008   LBU V1, 8(S8)
9D003624  3C02A000   LUI V0, -24576
9D003628  00031880   SLL V1, V1, 2
9D00362C  24420200   ADDIU V0, V0, 512
9D003630  00621021   ADDU V0, V1, V0
9D003634  8C420000   LW V0, 0(V0)
9D003638  7C420380   EXT V0, V0, 14, 1
9D00363C  304200FF   ANDI V0, V0, 255
9D003640  1040000F   BEQ V0, ZERO, 0x9D003680
9D003644  00000000   NOP
26:                      {
27:                          *data=digipot.value[channel].pot;
9D003648  93C30008   LBU V1, 8(S8)
9D00364C  3C02A000   LUI V0, -24576
9D003650  00031880   SLL V1, V1, 2
9D003654  24420200   ADDIU V0, V0, 512
9D003658  00621021   ADDU V0, V1, V0
9D00365C  8C420000   LW V0, 0(V0)
9D003660  7C424000   EXT V0, V0, 0, 9
9D003664  3042FFFF   ANDI V0, V0, -1
9D003668  00401821   ADDU V1, V0, ZERO
9D00366C  8FC2000C   LW V0, 12(S8)
9D003670  A4430000   SH V1, 0(V0)
28:                          return TRUE;
9D003674  24020001   ADDIU V0, ZERO, 1
9D003678  0B400DA1   J 0x9D003684
9D00367C  00000000   NOP
29:                      }
30:                      return FALSE;
9D003680  00001021   ADDU V0, ZERO, ZERO
31:                  }
9D003684  03C0E821   ADDU SP, S8, ZERO
9D003688  8FBE0004   LW S8, 4(SP)
9D00368C  27BD0008   ADDIU SP, SP, 8
9D003690  03E00008   JR RA
9D003694  00000000   NOP
32:                  
33:                  BOOL DigipotReadingReady(void)
34:                  {
9D003698  27BDFFF8   ADDIU SP, SP, -8
9D00369C  AFBE0004   SW S8, 4(SP)
9D0036A0  03A0F021   ADDU S8, SP, ZERO
35:                      return digipotStatus.readingReady;
9D0036A4  8F828060   LW V0, -32672(GP)
9D0036A8  7C4201C0   EXT V0, V0, 7, 1
9D0036AC  304200FF   ANDI V0, V0, 255
36:                  }
9D0036B0  03C0E821   ADDU SP, S8, ZERO
9D0036B4  8FBE0004   LW S8, 4(SP)
9D0036B8  27BD0008   ADDIU SP, SP, 8
9D0036BC  03E00008   JR RA
9D0036C0  00000000   NOP
37:                  
38:                  BOOL DigipotStartReadingAll(void)
39:                  {
9D0036C4  27BDFFF8   ADDIU SP, SP, -8
9D0036C8  AFBE0004   SW S8, 4(SP)
9D0036CC  03A0F021   ADDU S8, SP, ZERO
40:                      if(!digipotStatus.reading&&!digipotStatus.readAll&&!digipotStatus.readIndividual)
9D0036D0  8F828060   LW V0, -32672(GP)
9D0036D4  30420040   ANDI V0, V0, 64
9D0036D8  14400013   BNE V0, ZERO, 0x9D003728
9D0036DC  00000000   NOP
9D0036E0  8F828060   LW V0, -32672(GP)
9D0036E4  30420010   ANDI V0, V0, 16
9D0036E8  1440000F   BNE V0, ZERO, 0x9D003728
9D0036EC  00000000   NOP
9D0036F0  8F828060   LW V0, -32672(GP)
9D0036F4  30420020   ANDI V0, V0, 32
9D0036F8  1440000B   BNE V0, ZERO, 0x9D003728
9D0036FC  00000000   NOP
41:                      {
42:                          digipotStatus.readingReady=FALSE;
9D003700  8F828060   LW V0, -32672(GP)
9D003704  7C0239C4   INS V0, ZERO, 7, 1
9D003708  AF828060   SW V0, -32672(GP)
43:                          digipotStatus.readAll=TRUE;
9D00370C  8F828060   LW V0, -32672(GP)
9D003710  24030001   ADDIU V1, ZERO, 1
9D003714  7C622104   INS V0, V1, 4, 1
9D003718  AF828060   SW V0, -32672(GP)
44:                          return TRUE;
9D00371C  24020001   ADDIU V0, ZERO, 1
9D003720  0B400DCB   J 0x9D00372C
9D003724  00000000   NOP
45:                      }
46:                      return FALSE;
9D003728  00001021   ADDU V0, ZERO, ZERO
47:                  }
9D00372C  03C0E821   ADDU SP, S8, ZERO
9D003730  8FBE0004   LW S8, 4(SP)
9D003734  27BD0008   ADDIU SP, SP, 8
9D003738  03E00008   JR RA
9D00373C  00000000   NOP
48:                  
49:                  BOOL DigipotStartReading(UINT8 channelToRead)
50:                  {
9D003740  27BDFFF8   ADDIU SP, SP, -8
9D003744  AFBE0004   SW S8, 4(SP)
9D003748  03A0F021   ADDU S8, SP, ZERO
9D00374C  00801021   ADDU V0, A0, ZERO
9D003750  A3C20008   SB V0, 8(S8)
51:                      if(!digipotStatus.reading&&!digipotStatus.readAll&&!digipotStatus.readIndividual)
9D003754  8F828060   LW V0, -32672(GP)
9D003758  30420040   ANDI V0, V0, 64
9D00375C  1440001D   BNE V0, ZERO, 0x9D0037D4
9D003760  00000000   NOP
9D003764  8F828060   LW V0, -32672(GP)
9D003768  30420010   ANDI V0, V0, 16
9D00376C  14400019   BNE V0, ZERO, 0x9D0037D4
9D003770  00000000   NOP
9D003774  8F828060   LW V0, -32672(GP)
9D003778  30420020   ANDI V0, V0, 32
9D00377C  14400015   BNE V0, ZERO, 0x9D0037D4
9D003780  00000000   NOP
52:                      {
53:                          if(channelToRead<4)
9D003784  93C20008   LBU V0, 8(S8)
9D003788  2C420004   SLTIU V0, V0, 4
9D00378C  10400011   BEQ V0, ZERO, 0x9D0037D4
9D003790  00000000   NOP
54:                          {
55:                              digipotStatus.readingReady=FALSE;
9D003794  8F828060   LW V0, -32672(GP)
9D003798  7C0239C4   INS V0, ZERO, 7, 1
9D00379C  AF828060   SW V0, -32672(GP)
56:                              digipotStatus.channel=channelToRead;
9D0037A0  93C20008   LBU V0, 8(S8)
9D0037A4  30420003   ANDI V0, V0, 3
9D0037A8  304300FF   ANDI V1, V0, 255
9D0037AC  8F828060   LW V0, -32672(GP)
9D0037B0  7C625244   INS V0, V1, 9, 2
9D0037B4  AF828060   SW V0, -32672(GP)
57:                              digipotStatus.readIndividual=TRUE;
9D0037B8  8F828060   LW V0, -32672(GP)
9D0037BC  24030001   ADDIU V1, ZERO, 1
9D0037C0  7C622944   INS V0, V1, 5, 1
9D0037C4  AF828060   SW V0, -32672(GP)
58:                              return TRUE;
9D0037C8  24020001   ADDIU V0, ZERO, 1
9D0037CC  0B400DF6   J 0x9D0037D8
9D0037D0  00000000   NOP
59:                          }
60:                      }
61:                      return FALSE;
9D0037D4  00001021   ADDU V0, ZERO, ZERO
62:                  }
9D0037D8  03C0E821   ADDU SP, S8, ZERO
9D0037DC  8FBE0004   LW S8, 4(SP)
9D0037E0  27BD0008   ADDIU SP, SP, 8
9D0037E4  03E00008   JR RA
9D0037E8  00000000   NOP
63:                  
64:                  BOOL DigipotSubsystemInitialize(void)
65:                  {
9D0037EC  27BDFFF0   ADDIU SP, SP, -16
9D0037F0  AFBE000C   SW S8, 12(SP)
9D0037F4  03A0F021   ADDU S8, SP, ZERO
66:                      int index;
67:                      digipotStatus.w=0;
9D0037F8  A7808060   SH ZERO, -32672(GP)
68:                      for(index=0;index<4;index++)
9D0037FC  AFC00000   SW ZERO, 0(S8)
9D003800  0B400E0B   J 0x9D00382C
9D003804  00000000   NOP
9D003820  8FC20000   LW V0, 0(S8)
9D003824  24420001   ADDIU V0, V0, 1
9D003828  AFC20000   SW V0, 0(S8)
9D00382C  8FC20000   LW V0, 0(S8)
9D003830  28420004   SLTI V0, V0, 4
9D003834  1440FFF4   BNE V0, ZERO, 0x9D003808
9D003838  00000000   NOP
69:                      {
70:                          digipot.value[index].word.Val=0;
9D003808  3C02A000   LUI V0, -24576
9D00380C  8FC30000   LW V1, 0(S8)
9D003810  00031880   SLL V1, V1, 2
9D003814  24420200   ADDIU V0, V0, 512
9D003818  00621021   ADDU V0, V1, V0
9D00381C  A4400000   SH ZERO, 0(V0)
71:                      }
72:                      for(index=0;index<5;index++)
9D00383C  AFC00000   SW ZERO, 0(S8)
9D003840  0B400E1C   J 0x9D003870
9D003844  00000000   NOP
9D003864  8FC20000   LW V0, 0(S8)
9D003868  24420001   ADDIU V0, V0, 1
9D00386C  AFC20000   SW V0, 0(S8)
9D003870  8FC20000   LW V0, 0(S8)
9D003874  28420005   SLTI V0, V0, 5
9D003878  1440FFF3   BNE V0, ZERO, 0x9D003848
9D00387C  00000000   NOP
73:                      {
74:                          digipot.data[index].word.Val=0;
9D003848  3C02A000   LUI V0, -24576
9D00384C  8FC30000   LW V1, 0(S8)
9D003850  24630004   ADDIU V1, V1, 4
9D003854  00031880   SLL V1, V1, 2
9D003858  24420200   ADDIU V0, V0, 512
9D00385C  00621021   ADDU V0, V1, V0
9D003860  A4400000   SH ZERO, 0(V0)
75:                      }
76:                      return TRUE;
9D003880  24020001   ADDIU V0, ZERO, 1
77:                  }
9D003884  03C0E821   ADDU SP, S8, ZERO
9D003888  8FBE000C   LW S8, 12(SP)
9D00388C  27BD0010   ADDIU SP, SP, 16
9D003890  03E00008   JR RA
9D003894  00000000   NOP
78:                  
79:                  BOOL DoDigipot(void)
80:                  {
9D003898  27BDFFE0   ADDIU SP, SP, -32
9D00389C  AFBF001C   SW RA, 28(SP)
9D0038A0  AFBE0018   SW S8, 24(SP)
9D0038A4  03A0F021   ADDU S8, SP, ZERO
81:                      /* shouldn't need to be static- just a big structure that I see no need   */
82:                      /* to build up and take down with every pass through this function */
83:                      static I2CBUS_COMMAND_TYPE command;
84:                      static enum DIGIPOT_STATE_TYPE state=DIGIPOT_STATE_IDLE;
85:                  
86:                      if(!MasterI2CHasPort(DIGIPOT))
9D0038A8  24040001   ADDIU A0, ZERO, 1
9D0038AC  0F40050E   JAL MasterI2CHasPort
9D0038B0  00000000   NOP
9D0038B4  14400010   BNE V0, ZERO, 0x9D0038F8
9D0038B8  00000000   NOP
87:                      {
88:                          if(MasterI2CAvailable())
9D0038BC  0F4004FF   JAL MasterI2CAvailable
9D0038C0  00000000   NOP
9D0038C4  10400009   BEQ V0, ZERO, 0x9D0038EC
9D0038C8  00000000   NOP
89:                          {
90:                              /* if the port is available, claim it */
91:                              if(!MasterI2CClaimPort(DIGIPOT))
9D0038CC  24040001   ADDIU A0, ZERO, 1
9D0038D0  0F4004DA   JAL MasterI2CClaimPort
9D0038D4  00000000   NOP
9D0038D8  14400007   BNE V0, ZERO, 0x9D0038F8
9D0038DC  00000000   NOP
92:                              {
93:                                  return FALSE;
9D0038E0  00001021   ADDU V0, ZERO, ZERO
9D0038E4  0B400F7A   J 0x9D003DE8
9D0038E8  00000000   NOP
94:                              }
95:                          }
96:                          else
97:                          {
98:                              /* port not available */
99:                              return FALSE;
9D0038EC  00001021   ADDU V0, ZERO, ZERO
9D0038F0  0B400F7A   J 0x9D003DE8
9D0038F4  00000000   NOP
100:                         }
101:                     }
102:                     /* only get here if the port is claimed by the digipot subsystem */
103:                 
104:                    switch(state)
9D0038F8  8F828024   LW V0, -32732(GP)
9D0038FC  24030001   ADDIU V1, ZERO, 1
9D003900  1043002F   BEQ V0, V1, 0x9D0039C0
9D003904  00000000   NOP
9D003908  2C430001   SLTIU V1, V0, 1
9D00390C  14600009   BNE V1, ZERO, 0x9D003934
9D003910  00000000   NOP
9D003914  24030002   ADDIU V1, ZERO, 2
9D003918  10430090   BEQ V0, V1, 0x9D003B5C
9D00391C  00000000   NOP
9D003920  24030003   ADDIU V1, ZERO, 3
9D003924  10430112   BEQ V0, V1, 0x9D003D70
9D003928  00000000   NOP
9D00392C  0B400F6A   J 0x9D003DA8
9D003930  00000000   NOP
105:                     {
106:                         case DIGIPOT_STATE_IDLE:
107:                         {
108:                             if (digipotStatus.readAll)
9D003934  8F828060   LW V0, -32672(GP)
9D003938  30420010   ANDI V0, V0, 16
9D00393C  1040000C   BEQ V0, ZERO, 0x9D003970
9D003940  00000000   NOP
109:                             {
110:                                 digipotStatus.reading = TRUE;
9D003944  8F828060   LW V0, -32672(GP)
9D003948  24030001   ADDIU V1, ZERO, 1
9D00394C  7C623184   INS V0, V1, 6, 1
9D003950  AF828060   SW V0, -32672(GP)
111:                                 digipotStatus.channel = 0;
9D003954  8F828060   LW V0, -32672(GP)
9D003958  7C025244   INS V0, ZERO, 9, 2
9D00395C  AF828060   SW V0, -32672(GP)
112:                                 state = DIGIPOT_STATE_READ;
9D003960  24020001   ADDIU V0, ZERO, 1
9D003964  AF828024   SW V0, -32732(GP)
9D003968  0B400E70   J 0x9D0039C0
9D00396C  00000000   NOP
113:                             } 
114:                             else if (digipotStatus.readIndividual || digipotStatus.readStatus)
9D003970  8F828060   LW V0, -32672(GP)
9D003974  30420020   ANDI V0, V0, 32
9D003978  14400005   BNE V0, ZERO, 0x9D003990
9D00397C  00000000   NOP
9D003980  8F828060   LW V0, -32672(GP)
9D003984  30420100   ANDI V0, V0, 256
9D003988  10400009   BEQ V0, ZERO, 0x9D0039B0
9D00398C  00000000   NOP
115:                             {
116:                                 digipotStatus.reading = TRUE;
9D003990  8F828060   LW V0, -32672(GP)
9D003994  24030001   ADDIU V1, ZERO, 1
9D003998  7C623184   INS V0, V1, 6, 1
9D00399C  AF828060   SW V0, -32672(GP)
117:                                 state = DIGIPOT_STATE_READ;
9D0039A0  24020001   ADDIU V0, ZERO, 1
9D0039A4  AF828024   SW V0, -32732(GP)
9D0039A8  0B400E70   J 0x9D0039C0
9D0039AC  00000000   NOP
118:                             } 
119:                             else
120:                             {
121:                                 /* don't be greedy */
122:                                 MasterI2CReleasePort();
9D0039B0  0F4004F6   JAL MasterI2CReleasePort
9D0039B4  00000000   NOP
123:                                 break;
9D0039B8  0B400F79   J 0x9D003DE4
9D0039BC  00000000   NOP
124:                             }
125:                             /* no break */
126:                         }
127:                         case DIGIPOT_STATE_READ:
128:                         {
129:                             if (!MasterI2CIsBusy())
9D0039C0  0F400396   JAL MasterI2CIsBusy
9D0039C4  00000000   NOP
9D0039C8  144000FC   BNE V0, ZERO, 0x9D003DBC
9D0039CC  00000000   NOP
130:                             {
131:                                 UINT8 digipotCommand = 0;
9D0039D0  A3C00010   SB ZERO, 16(S8)
132:                                 if (digipotStatus.readAll || digipotStatus.readIndividual)
9D0039D4  8F828060   LW V0, -32672(GP)
9D0039D8  30420010   ANDI V0, V0, 16
9D0039DC  14400005   BNE V0, ZERO, 0x9D0039F4
9D0039E0  00000000   NOP
9D0039E4  8F828060   LW V0, -32672(GP)
9D0039E8  30420020   ANDI V0, V0, 32
9D0039EC  1040002E   BEQ V0, ZERO, 0x9D003AA8
9D0039F0  00000000   NOP
133:                                 {
134:                                     switch (digipotStatus.channel)
9D0039F4  8F828060   LW V0, -32672(GP)
9D0039F8  7C420A40   EXT V0, V0, 9, 2
9D0039FC  304200FF   ANDI V0, V0, 255
9D003A00  24030001   ADDIU V1, ZERO, 1
9D003A04  10430013   BEQ V0, V1, 0x9D003A54
9D003A08  00000000   NOP
9D003A0C  28430002   SLTI V1, V0, 2
9D003A10  10600005   BEQ V1, ZERO, 0x9D003A28
9D003A14  00000000   NOP
9D003A18  1040000B   BEQ V0, ZERO, 0x9D003A48
9D003A1C  00000000   NOP
9D003A20  0B400EA1   J 0x9D003A84
9D003A24  00000000   NOP
9D003A28  24030002   ADDIU V1, ZERO, 2
9D003A2C  1043000D   BEQ V0, V1, 0x9D003A64
9D003A30  00000000   NOP
9D003A34  24030003   ADDIU V1, ZERO, 3
9D003A38  1043000E   BEQ V0, V1, 0x9D003A74
9D003A3C  00000000   NOP
9D003A40  0B400EA1   J 0x9D003A84
9D003A44  00000000   NOP
135:                                     {
136:                                         case 0:
137:                                         {
138:                                             digipotCommand = MCP4461_VOLATILE_WIPER_0;
9D003A48  A3C00010   SB ZERO, 16(S8)
139:                                             break;
9D003A4C  0B400EA5   J 0x9D003A94
9D003A50  00000000   NOP
140:                                         }
141:                                         case 1:
142:                                         {
143:                                             digipotCommand = MCP4461_VOLATILE_WIPER_1;
9D003A54  24020010   ADDIU V0, ZERO, 16
9D003A58  A3C20010   SB V0, 16(S8)
144:                                             break;
9D003A5C  0B400EA5   J 0x9D003A94
9D003A60  00000000   NOP
145:                                         }
146:                                         case 2:
147:                                         {
148:                                             digipotCommand = MCP4461_VOLATILE_WIPER_2;
9D003A64  24020060   ADDIU V0, ZERO, 96
9D003A68  A3C20010   SB V0, 16(S8)
149:                                             break;
9D003A6C  0B400EA5   J 0x9D003A94
9D003A70  00000000   NOP
150:                                         }
151:                                         case 3:
152:                                         {
153:                                             digipotCommand = MCP4461_VOLATILE_WIPER_3;
9D003A74  24020070   ADDIU V0, ZERO, 112
9D003A78  A3C20010   SB V0, 16(S8)
154:                                             break;
9D003A7C  0B400EA5   J 0x9D003A94
9D003A80  00000000   NOP
155:                                         }
156:                                         default:
157:                                         {
158:                                             digipotStatus.channel = 0;
9D003A84  8F828060   LW V0, -32672(GP)
9D003A88  7C025244   INS V0, ZERO, 9, 2
9D003A8C  AF828060   SW V0, -32672(GP)
159:                                             break;
9D003A90  00000000   NOP
160:                                         }
161:                                     }
162:                                     digipotCommand |= MCP4461_COMMAND_READ;
9D003A94  93C20010   LBU V0, 16(S8)
9D003A98  3442000C   ORI V0, V0, 12
9D003A9C  A3C20010   SB V0, 16(S8)
9D003AA0  0B400EB6   J 0x9D003AD8
9D003AA4  00000000   NOP
163:                                 } 
164:                                 else if (digipotStatus.readStatus)
9D003AA8  8F828060   LW V0, -32672(GP)
9D003AAC  30420100   ANDI V0, V0, 256
9D003AB0  10400005   BEQ V0, ZERO, 0x9D003AC8
9D003AB4  00000000   NOP
165:                                 {
166:                                     digipotCommand = MCP4461_STATUS;
9D003AB8  24020050   ADDIU V0, ZERO, 80
9D003ABC  A3C20010   SB V0, 16(S8)
9D003AC0  0B400EB6   J 0x9D003AD8
9D003AC4  00000000   NOP
167:                                 } 
168:                                 else
169:                                 {
170:                                     /* not quite sure what is happening */
171:                                     state = DIGIPOT_STATE_CLEANUP;
9D003AC8  24020003   ADDIU V0, ZERO, 3
9D003ACC  AF828024   SW V0, -32732(GP)
172:                                     break;
9D003AD0  0B400F79   J 0x9D003DE4
9D003AD4  00000000   NOP
173:                                 }
174:                                 command.status.flags.I2C_read = TRUE;
9D003AD8  3C03A000   LUI V1, -24576
9D003ADC  8C62038C   LW V0, 908(V1)
9D003AE0  24040001   ADDIU A0, ZERO, 1
9D003AE4  7C821084   INS V0, A0, 2, 1
9D003AE8  AC62038C   SW V0, 908(V1)
175:                                 command.target_address = DIGIPOT_ADDRESS;
9D003AEC  3C02A000   LUI V0, -24576
9D003AF0  2442038C   ADDIU V0, V0, 908
9D003AF4  2403005E   ADDIU V1, ZERO, 94
9D003AF8  A0430004   SB V1, 4(V0)
176:                                 command.Word[0] = digipotCommand;
9D003AFC  3C02A000   LUI V0, -24576
9D003B00  2442038C   ADDIU V0, V0, 908
9D003B04  93C30010   LBU V1, 16(S8)
9D003B08  A0430005   SB V1, 5(V0)
177:                                 command.WordSize = 1;
9D003B0C  3C02A000   LUI V0, -24576
9D003B10  2442038C   ADDIU V0, V0, 908
9D003B14  24030001   ADDIU V1, ZERO, 1
9D003B18  A043001A   SB V1, 26(V0)
178:                                 command.DataSize = 2;
9D003B1C  3C02A000   LUI V0, -24576
9D003B20  2442038C   ADDIU V0, V0, 908
9D003B24  24030002   ADDIU V1, ZERO, 2
9D003B28  A0430019   SB V1, 25(V0)
179:                                 if (MasterI2CQueueCommand(&command))
9D003B2C  3C02A000   LUI V0, -24576
9D003B30  2444038C   ADDIU A0, V0, 908
9D003B34  0F400271   JAL MasterI2CQueueCommand
9D003B38  00000000   NOP
9D003B3C  10400003   BEQ V0, ZERO, 0x9D003B4C
9D003B40  00000000   NOP
180:                                 {
181:                                     state = DIGIPOT_STATE_READ_WAIT;
9D003B44  24020002   ADDIU V0, ZERO, 2
9D003B48  AF828024   SW V0, -32732(GP)
182:                                 }
183:                                 command.status.all = 0; /* just in case */
9D003B4C  3C02A000   LUI V0, -24576
9D003B50  AC40038C   SW ZERO, 908(V0)
184:                             }
185:                             break;
9D003B54  0B400F79   J 0x9D003DE4
9D003B58  00000000   NOP
9D003DBC  00000000   NOP
9D003DC0  0B400F79   J 0x9D003DE4
9D003DC4  00000000   NOP
186:                         }
187:                         case DIGIPOT_STATE_READ_WAIT:
188:                         {
189:                             if (MasterI2CIsQueuedCommandDone())
9D003B5C  0F4003BA   JAL MasterI2CIsQueuedCommandDone
9D003B60  00000000   NOP
9D003B64  10400098   BEQ V0, ZERO, 0x9D003DC8
9D003B68  00000000   NOP
190:                             {
191:                                 if (MasterI2CUpdateQueuedCommand(&command))
9D003B6C  3C02A000   LUI V0, -24576
9D003B70  2444038C   ADDIU A0, V0, 908
9D003B74  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D003B78  00000000   NOP
9D003B7C  10400061   BEQ V0, ZERO, 0x9D003D04
9D003B80  00000000   NOP
192:                                 {
193:                                     if (digipotStatus.readStatus)
9D003B84  8F828060   LW V0, -32672(GP)
9D003B88  30420100   ANDI V0, V0, 256
9D003B8C  1040000F   BEQ V0, ZERO, 0x9D003BCC
9D003B90  00000000   NOP
194:                                     {
195:                                         digipot.STATUS.b = command.Data[1];
9D003B94  3C02A000   LUI V0, -24576
9D003B98  2442038C   ADDIU V0, V0, 908
9D003B9C  90430010   LBU V1, 16(V0)
9D003BA0  3C02A000   LUI V0, -24576
9D003BA4  24420200   ADDIU V0, V0, 512
9D003BA8  A043002C   SB V1, 44(V0)
196:                                         digipotStatus.readingReady = TRUE;
9D003BAC  8F828060   LW V0, -32672(GP)
9D003BB0  24030001   ADDIU V1, ZERO, 1
9D003BB4  7C6239C4   INS V0, V1, 7, 1
9D003BB8  AF828060   SW V0, -32672(GP)
197:                                         state = DIGIPOT_STATE_CLEANUP;
9D003BBC  24020003   ADDIU V0, ZERO, 3
9D003BC0  AF828024   SW V0, -32732(GP)
198:                                     } 
199:                                     else
200:                                     {
201:                                         digipot.value[digipotStatus.channel].word.byte.HB = command.Data[0];
9D003BCC  8F828060   LW V0, -32672(GP)
9D003BD0  7C420A40   EXT V0, V0, 9, 2
9D003BD4  304200FF   ANDI V0, V0, 255
9D003BD8  00402021   ADDU A0, V0, ZERO
9D003BDC  3C02A000   LUI V0, -24576
9D003BE0  2442038C   ADDIU V0, V0, 908
9D003BE4  9043000F   LBU V1, 15(V0)
9D003BE8  3C02A000   LUI V0, -24576
9D003BEC  00042080   SLL A0, A0, 2
9D003BF0  24420200   ADDIU V0, V0, 512
9D003BF4  00821021   ADDU V0, A0, V0
9D003BF8  A0430001   SB V1, 1(V0)
202:                                         digipot.value[digipotStatus.channel].word.byte.LB = command.Data[1];
9D003BFC  8F828060   LW V0, -32672(GP)
9D003C00  7C420A40   EXT V0, V0, 9, 2
9D003C04  304200FF   ANDI V0, V0, 255
9D003C08  00402021   ADDU A0, V0, ZERO
9D003C0C  3C02A000   LUI V0, -24576
9D003C10  2442038C   ADDIU V0, V0, 908
9D003C14  90430010   LBU V1, 16(V0)
9D003C18  3C02A000   LUI V0, -24576
9D003C1C  00042080   SLL A0, A0, 2
9D003C20  24420200   ADDIU V0, V0, 512
9D003C24  00821021   ADDU V0, A0, V0
9D003C28  A0430000   SB V1, 0(V0)
203:                                         digipot.value[digipotStatus.channel].goodRead = TRUE;
9D003C2C  8F828060   LW V0, -32672(GP)
9D003C30  7C420A40   EXT V0, V0, 9, 2
9D003C34  304200FF   ANDI V0, V0, 255
9D003C38  00401821   ADDU V1, V0, ZERO
9D003C3C  3C02A000   LUI V0, -24576
9D003C40  00031880   SLL V1, V1, 2
9D003C44  24420200   ADDIU V0, V0, 512
9D003C48  00621821   ADDU V1, V1, V0
9D003C4C  8C620000   LW V0, 0(V1)
9D003C50  24040001   ADDIU A0, ZERO, 1
9D003C54  7C827384   INS V0, A0, 14, 1
9D003C58  AC620000   SW V0, 0(V1)
204:                                         if (digipotStatus.readIndividual)
9D003C5C  8F828060   LW V0, -32672(GP)
9D003C60  30420020   ANDI V0, V0, 32
9D003C64  10400009   BEQ V0, ZERO, 0x9D003C8C
9D003C68  00000000   NOP
205:                                         {
206:                                             digipotStatus.readingReady = TRUE;
9D003C6C  8F828060   LW V0, -32672(GP)
9D003C70  24030001   ADDIU V1, ZERO, 1
9D003C74  7C6239C4   INS V0, V1, 7, 1
9D003C78  AF828060   SW V0, -32672(GP)
207:                                             state = DIGIPOT_STATE_CLEANUP;
9D003C7C  24020003   ADDIU V0, ZERO, 3
9D003C80  AF828024   SW V0, -32732(GP)
208:                                         } 
209:                                         else if (digipotStatus.readAll)
9D003C8C  8F828060   LW V0, -32672(GP)
9D003C90  30420010   ANDI V0, V0, 16
9D003C94  1040004F   BEQ V0, ZERO, 0x9D003DD4
9D003C98  00000000   NOP
210:                                         {
211:                                             if (digipotStatus.channel == 3)
9D003C9C  8F828060   LW V0, -32672(GP)
9D003CA0  30430600   ANDI V1, V0, 1536
9D003CA4  24020600   ADDIU V0, ZERO, 1536
9D003CA8  14620009   BNE V1, V0, 0x9D003CD0
9D003CAC  00000000   NOP
212:                                             {
213:                                                 digipotStatus.readingReady = TRUE;
9D003CB0  8F828060   LW V0, -32672(GP)
9D003CB4  24030001   ADDIU V1, ZERO, 1
9D003CB8  7C6239C4   INS V0, V1, 7, 1
9D003CBC  AF828060   SW V0, -32672(GP)
214:                                                 state = DIGIPOT_STATE_CLEANUP;
9D003CC0  24020003   ADDIU V0, ZERO, 3
9D003CC4  AF828024   SW V0, -32732(GP)
215:                                             } 
216:                                             else
217:                                             {
218:                                                 digipotStatus.channel++;
9D003CD0  8F828060   LW V0, -32672(GP)
9D003CD4  7C420A40   EXT V0, V0, 9, 2
9D003CD8  304200FF   ANDI V0, V0, 255
9D003CDC  24420001   ADDIU V0, V0, 1
9D003CE0  30420003   ANDI V0, V0, 3
9D003CE4  304300FF   ANDI V1, V0, 255
9D003CE8  8F828060   LW V0, -32672(GP)
9D003CEC  7C625244   INS V0, V1, 9, 2
9D003CF0  AF828060   SW V0, -32672(GP)
219:                                                 state = DIGIPOT_STATE_READ;
9D003CF4  24020001   ADDIU V0, ZERO, 1
9D003CF8  AF828024   SW V0, -32732(GP)
220:                                             }
221:                                         }
222:                                     }
223:                                 } 
224:                                 else if (command.status.flags.I2C_error)
9D003D04  3C02A000   LUI V0, -24576
9D003D08  8C42038C   LW V0, 908(V0)
9D003D0C  30420040   ANDI V0, V0, 64
9D003D10  10400033   BEQ V0, ZERO, 0x9D003DE0
9D003D14  00000000   NOP
225:                                 {
226:                                     digipotStatus.error = TRUE;
9D003D18  8F828060   LW V0, -32672(GP)
9D003D1C  24030001   ADDIU V1, ZERO, 1
9D003D20  7C620004   INS V0, V1, 0, 1
9D003D24  AF828060   SW V0, -32672(GP)
227:                                     digipotStatus.errorNoACK = command.status.flags.I2C_no_slave_addr_ack;
9D003D28  3C02A000   LUI V0, -24576
9D003D2C  8C42038C   LW V0, 908(V0)
9D003D30  7C420100   EXT V0, V0, 4, 1
9D003D34  304300FF   ANDI V1, V0, 255
9D003D38  8F828060   LW V0, -32672(GP)
9D003D3C  7C620844   INS V0, V1, 1, 1
9D003D40  AF828060   SW V0, -32672(GP)
228:                                     digipotStatus.errorOnRead = TRUE;
9D003D44  8F828060   LW V0, -32672(GP)
9D003D48  24030001   ADDIU V1, ZERO, 1
9D003D4C  7C621084   INS V0, V1, 2, 1
9D003D50  AF828060   SW V0, -32672(GP)
229:                                     digipotStatus.readingReady = FALSE;
9D003D54  8F828060   LW V0, -32672(GP)
9D003D58  7C0239C4   INS V0, ZERO, 7, 1
9D003D5C  AF828060   SW V0, -32672(GP)
230:                                     state = DIGIPOT_STATE_CLEANUP;
9D003D60  24020003   ADDIU V0, ZERO, 3
9D003D64  AF828024   SW V0, -32732(GP)
231:                                 }
232:                             }
233:                             break;
9D003BC4  0B400F79   J 0x9D003DE4
9D003BC8  00000000   NOP
9D003C84  0B400F79   J 0x9D003DE4
9D003C88  00000000   NOP
9D003CC8  0B400F79   J 0x9D003DE4
9D003CCC  00000000   NOP
9D003CFC  0B400F79   J 0x9D003DE4
9D003D00  00000000   NOP
9D003D68  0B400F79   J 0x9D003DE4
9D003D6C  00000000   NOP
9D003DC8  00000000   NOP
9D003DCC  0B400F79   J 0x9D003DE4
9D003DD0  00000000   NOP
9D003DD4  00000000   NOP
9D003DD8  0B400F79   J 0x9D003DE4
9D003DDC  00000000   NOP
9D003DE0  00000000   NOP
234:                         }
235:                         case DIGIPOT_STATE_CLEANUP:
236:                         {
237:                             digipotStatus.readIndividual = FALSE;
9D003D70  8F828060   LW V0, -32672(GP)
9D003D74  7C022944   INS V0, ZERO, 5, 1
9D003D78  AF828060   SW V0, -32672(GP)
238:                             digipotStatus.readAll = FALSE;
9D003D7C  8F828060   LW V0, -32672(GP)
9D003D80  7C022104   INS V0, ZERO, 4, 1
9D003D84  AF828060   SW V0, -32672(GP)
239:                             digipotStatus.readStatus = FALSE;
9D003D88  8F828060   LW V0, -32672(GP)
9D003D8C  7C024204   INS V0, ZERO, 8, 1
9D003D90  AF828060   SW V0, -32672(GP)
240:                             MasterI2CReleasePort();
9D003D94  0F4004F6   JAL MasterI2CReleasePort
9D003D98  00000000   NOP
241:                             state = DIGIPOT_STATE_IDLE;
9D003D9C  AF808024   SW ZERO, -32732(GP)
242:                             break;
9D003DA0  0B400F79   J 0x9D003DE4
9D003DA4  00000000   NOP
243:                         }
244:                         default:
245:                         {
246:                             MasterI2CReleasePort();
9D003DA8  0F4004F6   JAL MasterI2CReleasePort
9D003DAC  00000000   NOP
247:                             state = DIGIPOT_STATE_IDLE;
9D003DB0  AF808024   SW ZERO, -32732(GP)
248:                             break;
9D003DB4  0B400F79   J 0x9D003DE4
9D003DB8  00000000   NOP
249:                         }
250:                     }
251:                     return TRUE;
9D003DE4  24020001   ADDIU V0, ZERO, 1
252:                 }
9D003DE8  03C0E821   ADDU SP, S8, ZERO
9D003DEC  8FBF001C   LW RA, 28(SP)
9D003DF0  8FBE0018   LW S8, 24(SP)
9D003DF4  27BD0020   ADDIU SP, SP, 32
9D003DF8  03E00008   JR RA
9D003DFC  00000000   NOP
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/LED.c  ----------------------------------------
1:                   /******************************************************************************/
2:                   #include <common.h>
3:                   #include <tick.h>
4:                   #include <TRISThis.h>
5:                   #include <LED.h>
6:                   BOOL autoMode;
7:                   enum LED_STATE_TYPE LEDState;
8:                   extern TRISTHIS_DATA_TYPE TRISThisData;
9:                   
10:                  /******************************************************************************/
11:                  
12:                  BOOL LEDInitialize(void)
13:                  {
9D004C70  27BDFFF8   ADDIU SP, SP, -8
9D004C74  AFBE0004   SW S8, 4(SP)
9D004C78  03A0F021   ADDU S8, SP, ZERO
14:                      LED_ALL_OFF;
9D004C7C  3C02BF88   LUI V0, -16504
9D004C80  3403E000   ORI V1, ZERO, -8192
9D004C84  AC4360E8   SW V1, 24808(V0)
9D004C88  3C02BF88   LUI V0, -16504
9D004C8C  2403013C   ADDIU V1, ZERO, 316
9D004C90  AC436168   SW V1, 24936(V0)
15:                      SET_LED_DIRECTION;
9D004C94  3C02BF88   LUI V0, -16504
9D004C98  3403E000   ORI V1, ZERO, -8192
9D004C9C  AC4360C4   SW V1, 24772(V0)
9D004CA0  3C02BF88   LUI V0, -16504
9D004CA4  2403013C   ADDIU V1, ZERO, 316
9D004CA8  AC436144   SW V1, 24900(V0)
16:                      //LED1_DIRECTION=TRIS_OUT;
17:                      //LED2_DIRECTION=TRIS_OUT;
18:                      //LED3_DIRECTION=TRIS_OUT;
19:                      //LED4_DIRECTION=TRIS_OUT;
20:                      //LED5_DIRECTION=TRIS_OUT;
21:                      //LED6_DIRECTION=TRIS_OUT;
22:                      //LED7_DIRECTION=TRIS_OUT;
23:                      //LED8_DIRECTION=TRIS_OUT;
24:                      //LEDState=LED_STATE_MANUAL;
25:                      LEDState=LED_STATE_ALL_OFF;
9D004CAC  AF808040   SW ZERO, -32704(GP)
26:                      autoMode=TRUE;
9D004CB0  24020001   ADDIU V0, ZERO, 1
9D004CB4  AF828044   SW V0, -32700(GP)
27:                      TRISThisData.status.autoLEDmode=autoMode;
9D004CB8  8F828044   LW V0, -32700(GP)
9D004CBC  304200FF   ANDI V0, V0, 255
9D004CC0  30420001   ANDI V0, V0, 1
9D004CC4  304400FF   ANDI A0, V0, 255
9D004CC8  3C03A000   LUI V1, -24576
9D004CCC  8C620344   LW V0, 836(V1)
9D004CD0  7C821084   INS V0, A0, 2, 1
9D004CD4  AC620344   SW V0, 836(V1)
28:                      TRISThisData.LEDs.w.Val=0;
9D004CD8  3C02A000   LUI V0, -24576
9D004CDC  24420344   ADDIU V0, V0, 836
9D004CE0  AC400004   SW ZERO, 4(V0)
29:                      return TRUE;
9D004CE4  24020001   ADDIU V0, ZERO, 1
30:                  }
9D004CE8  03C0E821   ADDU SP, S8, ZERO
9D004CEC  8FBE0004   LW S8, 4(SP)
9D004CF0  27BD0008   ADDIU SP, SP, 8
9D004CF4  03E00008   JR RA
9D004CF8  00000000   NOP
31:                  
32:                  /******************************************************************************/
33:                  
34:                  UINT8 ReadLEDs(void)
35:                  {
9D004CFC  27BDFFF0   ADDIU SP, SP, -16
9D004D00  AFBE000C   SW S8, 12(SP)
9D004D04  03A0F021   ADDU S8, SP, ZERO
36:                      UINT8_VAL LEDTemp;
37:                      LEDTemp.bits.b0=!LED1_OUT;
9D004D08  3C02BF88   LUI V0, -16504
9D004D0C  8C4260E0   LW V0, 24800(V0)
9D004D10  30424000   ANDI V0, V0, 16384
9D004D14  2C420001   SLTIU V0, V0, 1
9D004D18  304300FF   ANDI V1, V0, 255
9D004D1C  93C20000   LBU V0, 0(S8)
9D004D20  7C620004   INS V0, V1, 0, 1
9D004D24  A3C20000   SB V0, 0(S8)
38:                      LEDTemp.bits.b1=!LED2_OUT;
9D004D28  3C02BF88   LUI V0, -16504
9D004D2C  8C4260E0   LW V0, 24800(V0)
9D004D30  30428000   ANDI V0, V0, -32768
9D004D34  2C420001   SLTIU V0, V0, 1
9D004D38  304300FF   ANDI V1, V0, 255
9D004D3C  93C20000   LBU V0, 0(S8)
9D004D40  7C620844   INS V0, V1, 1, 1
9D004D44  A3C20000   SB V0, 0(S8)
39:                      LEDTemp.bits.b2=!LED3_OUT;
9D004D48  3C02BF88   LUI V0, -16504
9D004D4C  8C426160   LW V0, 24928(V0)
9D004D50  30420010   ANDI V0, V0, 16
9D004D54  2C420001   SLTIU V0, V0, 1
9D004D58  304300FF   ANDI V1, V0, 255
9D004D5C  93C20000   LBU V0, 0(S8)
9D004D60  7C621084   INS V0, V1, 2, 1
9D004D64  A3C20000   SB V0, 0(S8)
40:                      LEDTemp.bits.b3=!LED4_OUT;
9D004D68  3C02BF88   LUI V0, -16504
9D004D6C  8C426160   LW V0, 24928(V0)
9D004D70  30420020   ANDI V0, V0, 32
9D004D74  2C420001   SLTIU V0, V0, 1
9D004D78  304300FF   ANDI V1, V0, 255
9D004D7C  93C20000   LBU V0, 0(S8)
9D004D80  7C6218C4   INS V0, V1, 3, 1
9D004D84  A3C20000   SB V0, 0(S8)
41:                      LEDTemp.bits.b4=!LED5_OUT;
9D004D88  3C02BF88   LUI V0, -16504
9D004D8C  8C426160   LW V0, 24928(V0)
9D004D90  30420008   ANDI V0, V0, 8
9D004D94  2C420001   SLTIU V0, V0, 1
9D004D98  304300FF   ANDI V1, V0, 255
9D004D9C  93C20000   LBU V0, 0(S8)
9D004DA0  7C622104   INS V0, V1, 4, 1
9D004DA4  A3C20000   SB V0, 0(S8)
42:                      LEDTemp.bits.b5=!LED6_OUT;
9D004DA8  3C02BF88   LUI V0, -16504
9D004DAC  8C426160   LW V0, 24928(V0)
9D004DB0  30420004   ANDI V0, V0, 4
9D004DB4  2C420001   SLTIU V0, V0, 1
9D004DB8  304300FF   ANDI V1, V0, 255
9D004DBC  93C20000   LBU V0, 0(S8)
9D004DC0  7C622944   INS V0, V1, 5, 1
9D004DC4  A3C20000   SB V0, 0(S8)
43:                      LEDTemp.bits.b6=!LED7_OUT;
9D004DC8  3C02BF88   LUI V0, -16504
9D004DCC  8C426160   LW V0, 24928(V0)
9D004DD0  30420100   ANDI V0, V0, 256
9D004DD4  2C420001   SLTIU V0, V0, 1
9D004DD8  304300FF   ANDI V1, V0, 255
9D004DDC  93C20000   LBU V0, 0(S8)
9D004DE0  7C623184   INS V0, V1, 6, 1
9D004DE4  A3C20000   SB V0, 0(S8)
44:                      LEDTemp.bits.b7=!LED8_OUT;
9D004DE8  3C02BF88   LUI V0, -16504
9D004DEC  8C4260E0   LW V0, 24800(V0)
9D004DF0  30422000   ANDI V0, V0, 8192
9D004DF4  2C420001   SLTIU V0, V0, 1
9D004DF8  304300FF   ANDI V1, V0, 255
9D004DFC  93C20000   LBU V0, 0(S8)
9D004E00  7C6239C4   INS V0, V1, 7, 1
9D004E04  A3C20000   SB V0, 0(S8)
45:                      return LEDTemp.Val;
9D004E08  93C20000   LBU V0, 0(S8)
46:                  }
9D004E0C  03C0E821   ADDU SP, S8, ZERO
9D004E10  8FBE000C   LW S8, 12(SP)
9D004E14  27BD0010   ADDIU SP, SP, 16
9D004E18  03E00008   JR RA
9D004E1C  00000000   NOP
47:                  
48:                  /******************************************************************************/
49:                  
50:                  void SetLEDs(UINT8 toSet)
51:                  {
9D004E20  27BDFFF0   ADDIU SP, SP, -16
9D004E24  AFBE000C   SW S8, 12(SP)
9D004E28  03A0F021   ADDU S8, SP, ZERO
9D004E2C  00801021   ADDU V0, A0, ZERO
9D004E30  A3C20010   SB V0, 16(S8)
52:                      UINT8_VAL tempLEDs;
53:                      tempLEDs.Val=toSet;
9D004E34  93C20010   LBU V0, 16(S8)
9D004E38  A3C20000   SB V0, 0(S8)
54:                      LED1_OUT=!tempLEDs.bits.b0;
9D004E3C  93C20000   LBU V0, 0(S8)
9D004E40  30420001   ANDI V0, V0, 1
9D004E44  304200FF   ANDI V0, V0, 255
9D004E48  2C420001   SLTIU V0, V0, 1
9D004E4C  304400FF   ANDI A0, V0, 255
9D004E50  3C03BF88   LUI V1, -16504
9D004E54  8C6260E0   LW V0, 24800(V1)
9D004E58  7C827384   INS V0, A0, 14, 1
9D004E5C  AC6260E0   SW V0, 24800(V1)
55:                      LED2_OUT=!tempLEDs.bits.b1;
9D004E60  93C20000   LBU V0, 0(S8)
9D004E64  30420002   ANDI V0, V0, 2
9D004E68  304200FF   ANDI V0, V0, 255
9D004E6C  2C420001   SLTIU V0, V0, 1
9D004E70  304400FF   ANDI A0, V0, 255
9D004E74  3C03BF88   LUI V1, -16504
9D004E78  8C6260E0   LW V0, 24800(V1)
9D004E7C  7C827BC4   INS V0, A0, 15, 1
9D004E80  AC6260E0   SW V0, 24800(V1)
56:                      LED3_OUT=!tempLEDs.bits.b2;
9D004E84  93C20000   LBU V0, 0(S8)
9D004E88  30420004   ANDI V0, V0, 4
9D004E8C  304200FF   ANDI V0, V0, 255
9D004E90  2C420001   SLTIU V0, V0, 1
9D004E94  304400FF   ANDI A0, V0, 255
9D004E98  3C03BF88   LUI V1, -16504
9D004E9C  8C626160   LW V0, 24928(V1)
9D004EA0  7C822104   INS V0, A0, 4, 1
9D004EA4  AC626160   SW V0, 24928(V1)
57:                      LED4_OUT=!tempLEDs.bits.b3;
9D004EA8  93C20000   LBU V0, 0(S8)
9D004EAC  30420008   ANDI V0, V0, 8
9D004EB0  304200FF   ANDI V0, V0, 255
9D004EB4  2C420001   SLTIU V0, V0, 1
9D004EB8  304400FF   ANDI A0, V0, 255
9D004EBC  3C03BF88   LUI V1, -16504
9D004EC0  8C626160   LW V0, 24928(V1)
9D004EC4  7C822944   INS V0, A0, 5, 1
9D004EC8  AC626160   SW V0, 24928(V1)
58:                      LED5_OUT=!tempLEDs.bits.b4;
9D004ECC  93C20000   LBU V0, 0(S8)
9D004ED0  30420010   ANDI V0, V0, 16
9D004ED4  304200FF   ANDI V0, V0, 255
9D004ED8  2C420001   SLTIU V0, V0, 1
9D004EDC  304400FF   ANDI A0, V0, 255
9D004EE0  3C03BF88   LUI V1, -16504
9D004EE4  8C626160   LW V0, 24928(V1)
9D004EE8  7C8218C4   INS V0, A0, 3, 1
9D004EEC  AC626160   SW V0, 24928(V1)
59:                      LED6_OUT=!tempLEDs.bits.b5;
9D004EF0  93C20000   LBU V0, 0(S8)
9D004EF4  30420020   ANDI V0, V0, 32
9D004EF8  304200FF   ANDI V0, V0, 255
9D004EFC  2C420001   SLTIU V0, V0, 1
9D004F00  304400FF   ANDI A0, V0, 255
9D004F04  3C03BF88   LUI V1, -16504
9D004F08  8C626160   LW V0, 24928(V1)
9D004F0C  7C821084   INS V0, A0, 2, 1
9D004F10  AC626160   SW V0, 24928(V1)
60:                      LED7_OUT=!tempLEDs.bits.b6;
9D004F14  93C20000   LBU V0, 0(S8)
9D004F18  30420040   ANDI V0, V0, 64
9D004F1C  304200FF   ANDI V0, V0, 255
9D004F20  2C420001   SLTIU V0, V0, 1
9D004F24  304400FF   ANDI A0, V0, 255
9D004F28  3C03BF88   LUI V1, -16504
9D004F2C  8C626160   LW V0, 24928(V1)
9D004F30  7C824204   INS V0, A0, 8, 1
9D004F34  AC626160   SW V0, 24928(V1)
61:                      LED8_OUT=!tempLEDs.bits.b7;
9D004F38  93C20000   LBU V0, 0(S8)
9D004F3C  7C021420   SEB V0, V0
9D004F40  00021027   NOR V0, ZERO, V0
9D004F44  304200FF   ANDI V0, V0, 255
9D004F48  000211C2   SRL V0, V0, 7
9D004F4C  304400FF   ANDI A0, V0, 255
9D004F50  3C03BF88   LUI V1, -16504
9D004F54  8C6260E0   LW V0, 24800(V1)
9D004F58  7C826B44   INS V0, A0, 13, 1
9D004F5C  AC6260E0   SW V0, 24800(V1)
62:                  }
9D004F60  03C0E821   ADDU SP, S8, ZERO
9D004F64  8FBE000C   LW S8, 12(SP)
9D004F68  27BD0010   ADDIU SP, SP, 16
9D004F6C  03E00008   JR RA
9D004F70  00000000   NOP
63:                  
64:                  /******************************************************************************/
65:                  
66:                  void DoLEDs(void)
67:                  {
9D004F74  27BDFFE0   ADDIU SP, SP, -32
9D004F78  AFBF001C   SW RA, 28(SP)
9D004F7C  AFBE0018   SW S8, 24(SP)
9D004F80  03A0F021   ADDU S8, SP, ZERO
68:                      static TICK_TYPE timeoutTime=0;
69:                      TICK_TYPE now;
70:                      if(LEDState!=LED_STATE_MANUAL)
9D004F84  8F838040   LW V1, -32704(GP)
9D004F88  24020009   ADDIU V0, ZERO, 9
9D004F8C  10620073   BEQ V1, V0, 0x9D00515C
9D004F90  00000000   NOP
71:                      {
72:                          now=TickGet();
9D004F94  0F4014DB   JAL TickGet
9D004F98  00000000   NOP
9D004F9C  AFC20010   SW V0, 16(S8)
9D004FA0  AFC30014   SW V1, 20(S8)
73:                          if(now<timeoutTime)
9D004FA4  8F828018   LW V0, -32744(GP)
9D004FA8  8F83801C   LW V1, -32740(GP)
9D004FAC  8FC40014   LW A0, 20(S8)
9D004FB0  0083202B   SLTU A0, A0, V1
9D004FB4  14800071   BNE A0, ZERO, 0x9D00517C
9D004FB8  00000000   NOP
9D004FBC  8FC50014   LW A1, 20(S8)
9D004FC0  00602021   ADDU A0, V1, ZERO
9D004FC4  14A40005   BNE A1, A0, 0x9D004FDC
9D004FC8  00000000   NOP
9D004FCC  8FC40010   LW A0, 16(S8)
9D004FD0  0082102B   SLTU V0, A0, V0
9D004FD4  1440006C   BNE V0, ZERO, 0x9D005188
9D004FD8  00000000   NOP
74:                          {
75:                              return;
9D00517C  00000000   NOP
9D005180  0B401463   J 0x9D00518C
9D005184  00000000   NOP
9D005188  00000000   NOP
76:                          }
77:                          else
78:                          {
79:                              timeoutTime = now + LED_CASCADE_DELAY;
9D004FDC  8FC40010   LW A0, 16(S8)
9D004FE0  8FC50014   LW A1, 20(S8)
9D004FE4  24060064   ADDIU A2, ZERO, 100
9D004FE8  00003821   ADDU A3, ZERO, ZERO
9D004FEC  00861021   ADDU V0, A0, A2
9D004FF0  0044402B   SLTU T0, V0, A0
9D004FF4  00A71821   ADDU V1, A1, A3
9D004FF8  01032021   ADDU A0, T0, V1
9D004FFC  00801821   ADDU V1, A0, ZERO
9D005000  AF828018   SW V0, -32744(GP)
9D005004  AF83801C   SW V1, -32740(GP)
80:                          }
81:                          switch(LEDState)
9D005008  8F828040   LW V0, -32704(GP)
9D00500C  2C430009   SLTIU V1, V0, 9
9D005010  10600049   BEQ V1, ZERO, 0x9D005138
9D005014  00000000   NOP
9D005018  00021880   SLL V1, V0, 2
9D00501C  3C029D00   LUI V0, -25344
9D005020  24425034   ADDIU V0, V0, 20532
9D005024  00621021   ADDU V0, V1, V0
9D005028  8C420000   LW V0, 0(V0)
9D00502C  00400008   JR V0
9D005030  00000000   NOP
82:                          {
83:                              case LED_STATE_LED1_TOGGLE:
84:                              {
85:                                  LED1_TOGGLE;
9D005058  3C02BF88   LUI V0, -16504
9D00505C  24034000   ADDIU V1, ZERO, 16384
9D005060  AC4360EC   SW V1, 24812(V0)
86:                                  LEDState = LED_STATE_LED2_TOGGLE;
9D005064  24020002   ADDIU V0, ZERO, 2
9D005068  AF828040   SW V0, -32704(GP)
87:                                  break;
9D00506C  0B401457   J 0x9D00515C
9D005070  00000000   NOP
88:                              }
89:                              case LED_STATE_LED2_TOGGLE:
90:                              {
91:                                  LED2_TOGGLE;
9D005074  3C02BF88   LUI V0, -16504
9D005078  34038000   ORI V1, ZERO, -32768
9D00507C  AC4360EC   SW V1, 24812(V0)
92:                                  LEDState = LED_STATE_LED3_TOGGLE;
9D005080  24020003   ADDIU V0, ZERO, 3
9D005084  AF828040   SW V0, -32704(GP)
93:                                  break;
9D005088  0B401457   J 0x9D00515C
9D00508C  00000000   NOP
94:                              }
95:                              case LED_STATE_LED3_TOGGLE:
96:                              {
97:                                  LED3_TOGGLE;
9D005090  3C02BF88   LUI V0, -16504
9D005094  24030010   ADDIU V1, ZERO, 16
9D005098  AC43616C   SW V1, 24940(V0)
98:                                  LEDState = LED_STATE_LED4_TOGGLE;
9D00509C  24020004   ADDIU V0, ZERO, 4
9D0050A0  AF828040   SW V0, -32704(GP)
99:                                  break;
9D0050A4  0B401457   J 0x9D00515C
9D0050A8  00000000   NOP
100:                             }
101:                             case LED_STATE_LED4_TOGGLE:
102:                             {
103:                                 LED4_TOGGLE;
9D0050AC  3C02BF88   LUI V0, -16504
9D0050B0  24030020   ADDIU V1, ZERO, 32
9D0050B4  AC43616C   SW V1, 24940(V0)
104:                                 LEDState = LED_STATE_LED5_TOGGLE;
9D0050B8  24020005   ADDIU V0, ZERO, 5
9D0050BC  AF828040   SW V0, -32704(GP)
105:                                 break;
9D0050C0  0B401457   J 0x9D00515C
9D0050C4  00000000   NOP
106:                             }
107:                             case LED_STATE_LED5_TOGGLE:
108:                             {
109:                                 LED5_TOGGLE;
9D0050C8  3C02BF88   LUI V0, -16504
9D0050CC  24030008   ADDIU V1, ZERO, 8
9D0050D0  AC43616C   SW V1, 24940(V0)
110:                                 LEDState = LED_STATE_LED6_TOGGLE;
9D0050D4  24020006   ADDIU V0, ZERO, 6
9D0050D8  AF828040   SW V0, -32704(GP)
111:                                 break;
9D0050DC  0B401457   J 0x9D00515C
9D0050E0  00000000   NOP
112:                             }
113:                             case LED_STATE_LED6_TOGGLE:
114:                             {
115:                                 LED6_TOGGLE;
9D0050E4  3C02BF88   LUI V0, -16504
9D0050E8  24030004   ADDIU V1, ZERO, 4
9D0050EC  AC43616C   SW V1, 24940(V0)
116:                                 LEDState = LED_STATE_LED7_TOGGLE;
9D0050F0  24020007   ADDIU V0, ZERO, 7
9D0050F4  AF828040   SW V0, -32704(GP)
117:                                 break;
9D0050F8  0B401457   J 0x9D00515C
9D0050FC  00000000   NOP
118:                             }
119:                             case LED_STATE_LED7_TOGGLE:
120:                             {
121:                                 LED7_TOGGLE;
9D005100  3C02BF88   LUI V0, -16504
9D005104  24030100   ADDIU V1, ZERO, 256
9D005108  AC43616C   SW V1, 24940(V0)
122:                                 LEDState = LED_STATE_LED8_TOGGLE;
9D00510C  24020008   ADDIU V0, ZERO, 8
9D005110  AF828040   SW V0, -32704(GP)
123:                                 break;
9D005114  0B401457   J 0x9D00515C
9D005118  00000000   NOP
124:                             }
125:                             case LED_STATE_LED8_TOGGLE:
126:                             {
127:                                 LED8_TOGGLE;
9D00511C  3C02BF88   LUI V0, -16504
9D005120  24032000   ADDIU V1, ZERO, 8192
9D005124  AC4360EC   SW V1, 24812(V0)
128:                                 LEDState = LED_STATE_LED1_TOGGLE;
9D005128  24020001   ADDIU V0, ZERO, 1
9D00512C  AF828040   SW V0, -32704(GP)
129:                                 break;
9D005130  0B401457   J 0x9D00515C
9D005134  00000000   NOP
130:                             }
131:                             case LED_STATE_ALL_OFF:
132:                             default:
133:                             {
134:                                 LED_ALL_OFF;
9D005138  3C02BF88   LUI V0, -16504
9D00513C  3403E000   ORI V1, ZERO, -8192
9D005140  AC4360E8   SW V1, 24808(V0)
9D005144  3C02BF88   LUI V0, -16504
9D005148  2403013C   ADDIU V1, ZERO, 316
9D00514C  AC436168   SW V1, 24936(V0)
135:                                 LEDState = LED_STATE_LED1_TOGGLE;
9D005150  24020001   ADDIU V0, ZERO, 1
9D005154  AF828040   SW V0, -32704(GP)
136:                                 break;
9D005158  00000000   NOP
137:                             }
138:                         }
139:                     }
140:                     TRISThisData.LEDs.w.byte.LB=ReadLEDs();
9D00515C  0F40133F   JAL ReadLEDs
9D005160  00000000   NOP
9D005164  00401821   ADDU V1, V0, ZERO
9D005168  3C02A000   LUI V0, -24576
9D00516C  24420344   ADDIU V0, V0, 836
9D005170  A0430004   SB V1, 4(V0)
9D005174  0B401463   J 0x9D00518C
9D005178  00000000   NOP
141:                 }
9D00518C  03C0E821   ADDU SP, S8, ZERO
9D005190  8FBF001C   LW RA, 28(SP)
9D005194  8FBE0018   LW S8, 24(SP)
9D005198  27BD0020   ADDIU SP, SP, 32
9D00519C  03E00008   JR RA
9D0051A0  00000000   NOP
142:                 
143:                 /******************************************************************************/
144:                 
145:                 BOOL LEDAutoMode(BOOL toSet)
146:                 {
9D0051A4  27BDFFF0   ADDIU SP, SP, -16
9D0051A8  AFBE000C   SW S8, 12(SP)
9D0051AC  03A0F021   ADDU S8, SP, ZERO
9D0051B0  AFC40010   SW A0, 16(S8)
147:                     BOOL returnValue=FALSE;
9D0051B4  AFC00000   SW ZERO, 0(S8)
148:                     if(toSet)
9D0051B8  8FC20010   LW V0, 16(S8)
9D0051BC  10400006   BEQ V0, ZERO, 0x9D0051D8
9D0051C0  00000000   NOP
149:                     {
150:                         returnValue=TRUE;
9D0051C4  24020001   ADDIU V0, ZERO, 1
9D0051C8  AFC20000   SW V0, 0(S8)
151:                         LEDState=LED_STATE_ALL_OFF;
9D0051CC  AF808040   SW ZERO, -32704(GP)
9D0051D0  0B401478   J 0x9D0051E0
9D0051D4  00000000   NOP
152:                     }
153:                     else
154:                     {
155:                         LEDState=LED_STATE_MANUAL;
9D0051D8  24020009   ADDIU V0, ZERO, 9
9D0051DC  AF828040   SW V0, -32704(GP)
156:                     }
157:                     return returnValue;
9D0051E0  8FC20000   LW V0, 0(S8)
158:                 }
9D0051E4  03C0E821   ADDU SP, S8, ZERO
9D0051E8  8FBE000C   LW S8, 12(SP)
9D0051EC  27BD0010   ADDIU SP, SP, 16
9D0051F0  03E00008   JR RA
9D0051F4  00000000   NOP
159:                 
160:                 BOOL GetLEDAutoMode(void)
161:                 {
9D0051F8  27BDFFF8   ADDIU SP, SP, -8
9D0051FC  AFBE0004   SW S8, 4(SP)
9D005200  03A0F021   ADDU S8, SP, ZERO
162:                     return autoMode;
9D005204  8F828044   LW V0, -32700(GP)
163:                 }
9D005208  03C0E821   ADDU SP, S8, ZERO
9D00520C  8FBE0004   LW S8, 4(SP)
9D005210  27BD0008   ADDIU SP, SP, 8
9D005214  03E00008   JR RA
9D005218  00000000   NOP
164:                 /******************************************************************************/
---  /home/matt/Projects/TRISThis/TRISThisFWV1p0.X/source/I2C_Bus_Master.c  -----------------------------
1:                   /******************************************************************************/
2:                   /* File: I2C_Bus_Master.c                                                     */
3:                   /* Author: Matt Bennett                                                       */
4:                   /* Date: December 26, 2011                                                    */
5:                   /* Version: 0.95                                                              */
6:                   /*                                                                            */
7:                   /* Description: Interrupt driven code for an I2C master. State based.         */
8:                   /*  Queue a command, wait for it to be complete, copy the data from the       */
9:                   /*  interrupt accessible variables.                                           */
10:                  /*                                                                            */
11:                  /******************************************************************************/
12:                  
13:                  #include <common.h>
14:                  #include <i2c.h>
15:                  #include <int.h>
16:                  #include <delay.h>
17:                  #include <I2C_Bus_Master.h>
18:                  
19:                  /******************************************************************************/
20:                  
21:                  I2C_MASTER_PORT_TYPE MasterI2CPort;
22:                  
23:                  /* just here for being able to see this in a watch window                     */
24:                  //extern I2CBUS_COMMAND_TYPE I2CCommand;
25:                  
26:                  /******************************************************************************/
27:                  
28:                  #ifdef I2C_USE_TIMEOUT
29:                  /******************************************************************************/
30:                  /* Timeout interrupt                                                          */
31:                  /******************************************************************************/
32:                  
33:                  void __ISR(/*INT_TIMER_VECTOR(I2C_TIMEOUT_TIMER)*/_TIMER_5_VECTOR,TIMEOUT_INT_PRIORITY_ISR) I2CTimeoutInterrupt(void)
34:                  {
9D000020  415DE800   RDPGPR SP, SP
9D000024  401A7000   MFC0 K0, EPC
9D000028  401B6000   MFC0 K1, Status
9D00002C  27BDFF88   ADDIU SP, SP, -120
9D000030  AFBA0074   SW K0, 116(SP)
9D000034  401A6002   MFC0 K0, SRSCtl
9D000038  AFBB0070   SW K1, 112(SP)
9D00003C  AFBA006C   SW K0, 108(SP)
9D000040  7C1B7844   INS K1, ZERO, 1, 15
9D000044  377B1000   ORI K1, K1, 4096
9D000048  409B6000   MTC0 K1, Status
9D00004C  AFBF005C   SW RA, 92(SP)
9D000050  AFBE0058   SW S8, 88(SP)
9D000054  AFB90054   SW T9, 84(SP)
9D000058  AFB80050   SW T8, 80(SP)
9D00005C  AFAF004C   SW T7, 76(SP)
9D000060  AFAE0048   SW T6, 72(SP)
9D000064  AFAD0044   SW T5, 68(SP)
9D000068  AFAC0040   SW T4, 64(SP)
9D00006C  AFAB003C   SW T3, 60(SP)
9D000070  AFAA0038   SW T2, 56(SP)
9D000074  AFA90034   SW T1, 52(SP)
9D000078  AFA80030   SW T0, 48(SP)
9D00007C  AFA7002C   SW A3, 44(SP)
9D000080  AFA60028   SW A2, 40(SP)
9D000084  AFA50024   SW A1, 36(SP)
9D000088  AFA40020   SW A0, 32(SP)
9D00008C  AFA3001C   SW V1, 28(SP)
9D000090  AFA20018   SW V0, 24(SP)
9D000094  AFA10014   SW AT, 20(SP)
9D000098  00001012   MFLO V0, 0
9D00009C  AFA20064   SW V0, 100(SP)
9D0000A0  00001810   MFHI V1, 0
9D0000A4  AFA30060   SW V1, 96(SP)
9D0000A8  03A0F021   ADDU S8, SP, ZERO
35:                      INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D0000AC  2404000C   ADDIU A0, ZERO, 12
9D0000B0  0F4017B7   JAL INTClearFlag
9D0000B4  00000000   NOP
36:                      MasterI2CPort.status.flags.I2C_timeout=TRUE;
9D0000B8  3C03A000   LUI V1, -24576
9D0000BC  8C6201E4   LW V0, 484(V1)
9D0000C0  24040001   ADDIU A0, ZERO, 1
9D0000C4  7C825AC4   INS V0, A0, 11, 1
9D0000C8  AC6201E4   SW V0, 484(V1)
37:                      MasterI2CPort.status.flags.I2C_error=TRUE;
9D0000CC  3C03A000   LUI V1, -24576
9D0000D0  8C6201E4   LW V0, 484(V1)
9D0000D4  24040001   ADDIU A0, ZERO, 1
9D0000D8  7C823184   INS V0, A0, 6, 1
9D0000DC  AC6201E4   SW V0, 484(V1)
38:                      MasterI2CPort.status.flags.I2C_action_complete=TRUE;
9D0000E0  3C03A000   LUI V1, -24576
9D0000E4  8C6201E4   LW V0, 484(V1)
9D0000E8  24040001   ADDIU A0, ZERO, 1
9D0000EC  7C825284   INS V0, A0, 10, 1
9D0000F0  AC6201E4   SW V0, 484(V1)
39:                      MasterI2CPort.status.flags.I2C_busy=FALSE;
9D0000F4  3C03A000   LUI V1, -24576
9D0000F8  8C6201E4   LW V0, 484(V1)
9D0000FC  7C0218C4   INS V0, ZERO, 3, 1
9D000100  AC6201E4   SW V0, 484(V1)
40:                      mMasterI2CTimeoutStopTimer();
9D000104  3C03BF80   LUI V1, -16512
9D000108  8C620E00   LW V0, 3584(V1)
9D00010C  7C027BC4   INS V0, ZERO, 15, 1
9D000110  AC620E00   SW V0, 3584(V1)
41:                      INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000114  2404003D   ADDIU A0, ZERO, 61
9D000118  00002821   ADDU A1, ZERO, ZERO
9D00011C  0F4016DC   JAL INTEnable
9D000120  00000000   NOP
42:                  }
9D000124  03C0E821   ADDU SP, S8, ZERO
9D000128  8FA20064   LW V0, 100(SP)
9D00012C  00400013   MTLO V0, 0
9D000130  8FA30060   LW V1, 96(SP)
9D000134  00600011   MTHI V1, 0
9D000138  8FBF005C   LW RA, 92(SP)
9D00013C  8FBE0058   LW S8, 88(SP)
9D000140  8FB90054   LW T9, 84(SP)
9D000144  8FB80050   LW T8, 80(SP)
9D000148  8FAF004C   LW T7, 76(SP)
9D00014C  8FAE0048   LW T6, 72(SP)
9D000150  8FAD0044   LW T5, 68(SP)
9D000154  8FAC0040   LW T4, 64(SP)
9D000158  8FAB003C   LW T3, 60(SP)
9D00015C  8FAA0038   LW T2, 56(SP)
9D000160  8FA90034   LW T1, 52(SP)
9D000164  8FA80030   LW T0, 48(SP)
9D000168  8FA7002C   LW A3, 44(SP)
9D00016C  8FA60028   LW A2, 40(SP)
9D000170  8FA50024   LW A1, 36(SP)
9D000174  8FA40020   LW A0, 32(SP)
9D000178  8FA3001C   LW V1, 28(SP)
9D00017C  8FA20018   LW V0, 24(SP)
9D000180  8FA10014   LW AT, 20(SP)
9D000184  41606000   DI ZERO
9D000188  000000C0   EHB
9D00018C  8FBA0074   LW K0, 116(SP)
9D000190  8FBB0070   LW K1, 112(SP)
9D000194  409A7000   MTC0 K0, EPC
9D000198  8FBA006C   LW K0, 108(SP)
9D00019C  27BD0078   ADDIU SP, SP, 120
9D0001A0  409A6002   MTC0 K0, SRSCtl
9D0001A4  41DDE800   WRPGPR SP, SP
9D0001A8  409B6000   MTC0 K1, Status
9D0001AC  42000018   ERET
43:                  #endif
44:                  
45:                  /******************************************************************************/
46:                  /* I2C Master interrupt                                                       */
47:                  /******************************************************************************/
48:                  
49:                  void __ISR (_I2C_2_VECTOR,MI2C_INT_PRIORITY_ISR) _MI2C2Interrupt(void)
50:                  {
9D0001B0  415DE800   RDPGPR SP, SP
9D0001B4  401A7000   MFC0 K0, EPC
9D0001B8  401B6000   MFC0 K1, Status
9D0001BC  27BDFF88   ADDIU SP, SP, -120
9D0001C0  AFBA0074   SW K0, 116(SP)
9D0001C4  401A6002   MFC0 K0, SRSCtl
9D0001C8  AFBB0070   SW K1, 112(SP)
9D0001CC  AFBA006C   SW K0, 108(SP)
9D0001D0  7C1B7844   INS K1, ZERO, 1, 15
9D0001D4  377B1800   ORI K1, K1, 6144
9D0001D8  409B6000   MTC0 K1, Status
9D0001DC  AFBF005C   SW RA, 92(SP)
9D0001E0  AFBE0058   SW S8, 88(SP)
9D0001E4  AFB90054   SW T9, 84(SP)
9D0001E8  AFB80050   SW T8, 80(SP)
9D0001EC  AFAF004C   SW T7, 76(SP)
9D0001F0  AFAE0048   SW T6, 72(SP)
9D0001F4  AFAD0044   SW T5, 68(SP)
9D0001F8  AFAC0040   SW T4, 64(SP)
9D0001FC  AFAB003C   SW T3, 60(SP)
9D000200  AFAA0038   SW T2, 56(SP)
9D000204  AFA90034   SW T1, 52(SP)
9D000208  AFA80030   SW T0, 48(SP)
9D00020C  AFA7002C   SW A3, 44(SP)
9D000210  AFA60028   SW A2, 40(SP)
9D000214  AFA50024   SW A1, 36(SP)
9D000218  AFA40020   SW A0, 32(SP)
9D00021C  AFA3001C   SW V1, 28(SP)
9D000220  AFA20018   SW V0, 24(SP)
9D000224  AFA10014   SW AT, 20(SP)
9D000228  00001012   MFLO V0, 0
9D00022C  AFA20064   SW V0, 100(SP)
9D000230  00001810   MFHI V1, 0
9D000234  AFA30060   SW V1, 96(SP)
9D000238  03A0F021   ADDU S8, SP, ZERO
51:                      static UINT8 temp; /* used by dummy read to clear RBF flag */
52:                      INTClearFlag(INT_SOURCE_I2C_MASTER(I2C_PORT));
9D00023C  2404003D   ADDIU A0, ZERO, 61
9D000240  0F4017B7   JAL INTClearFlag
9D000244  00000000   NOP
53:                      /* save a copy of I2C2STAT */
54:                      MasterI2CPort.STATShadow.w=I2C_STATUS;
9D000248  3C02BF80   LUI V0, -16512
9D00024C  8C435410   LW V1, 21520(V0)
9D000250  3C02A000   LUI V0, -24576
9D000254  244201E4   ADDIU V0, V0, 484
9D000258  AC430018   SW V1, 24(V0)
55:                      #ifdef I2C_USE_TIMEOUT
56:                          mMasterI2CTimeoutClearTimer();
9D00025C  3C03BF80   LUI V1, -16512
9D000260  8C620E00   LW V0, 3584(V1)
9D000264  7C027BC4   INS V0, ZERO, 15, 1
9D000268  AC620E00   SW V0, 3584(V1)
9D00026C  3C02BF80   LUI V0, -16512
9D000270  AC400E10   SW ZERO, 3600(V0)
9D000274  3C03BF80   LUI V1, -16512
9D000278  8C620E00   LW V0, 3584(V1)
9D00027C  24040001   ADDIU A0, ZERO, 1
9D000280  7C827BC4   INS V0, A0, 15, 1
9D000284  AC620E00   SW V0, 3584(V1)
57:                          /* if we get an I2C interrupt, there wasn't a timeout*/
58:                          INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D000288  2404000C   ADDIU A0, ZERO, 12
9D00028C  0F4017B7   JAL INTClearFlag
9D000290  00000000   NOP
59:                      #endif /* #ifdef I2C_USE_TIMEOUT */
60:                      if((MasterI2CPort.STATShadow.I2COV==TRUE) ||
9D000294  3C02A000   LUI V0, -24576
9D000298  244201E4   ADDIU V0, V0, 484
9D00029C  8C420018   LW V0, 24(V0)
9D0002A0  30420040   ANDI V0, V0, 64
9D0002A4  14400007   BNE V0, ZERO, 0x9D0002C4
9D0002A8  00000000   NOP
9D0002BC  1040000F   BEQ V0, ZERO, 0x9D0002FC
9D0002C0  00000000   NOP
61:                         (MasterI2CPort.STATShadow.IWCOL==TRUE))
9D0002AC  3C02A000   LUI V0, -24576
9D0002B0  244201E4   ADDIU V0, V0, 484
9D0002B4  8C420018   LW V0, 24(V0)
9D0002B8  30420080   ANDI V0, V0, 128
62:                      {
63:                          MasterI2CPort.status.flags.I2C_error = TRUE;
9D0002C4  3C03A000   LUI V1, -24576
9D0002C8  8C6201E4   LW V0, 484(V1)
9D0002CC  24040001   ADDIU A0, ZERO, 1
9D0002D0  7C823184   INS V0, A0, 6, 1
9D0002D4  AC6201E4   SW V0, 484(V1)
64:                          MasterI2CPort.status.flags.I2C_error_overrun = TRUE;
9D0002D8  3C03A000   LUI V1, -24576
9D0002DC  8C6201E4   LW V0, 484(V1)
9D0002E0  24040001   ADDIU A0, ZERO, 1
9D0002E4  7C824A44   INS V0, A0, 9, 1
9D0002E8  AC6201E4   SW V0, 484(V1)
65:                          /* the STOP state does all the shutdown we need                       */
66:                          MasterI2CPort.state = MI2CINT_STOP;
9D0002EC  3C02A000   LUI V0, -24576
9D0002F0  244201E4   ADDIU V0, V0, 484
9D0002F4  24030008   ADDIU V1, ZERO, 8
9D0002F8  AC430014   SW V1, 20(V0)
67:                      }
68:                      switch(MasterI2CPort.state)
9D0002FC  3C02A000   LUI V0, -24576
9D000300  244201E4   ADDIU V0, V0, 484
9D000304  8C420014   LW V0, 20(V0)
9D000308  2C430009   SLTIU V1, V0, 9
9D00030C  10600174   BEQ V1, ZERO, 0x9D0008E0
9D000310  00000000   NOP
9D000314  00021880   SLL V1, V0, 2
9D000318  3C029D00   LUI V0, -25344
9D00031C  24420330   ADDIU V0, V0, 816
9D000320  00621021   ADDU V0, V1, V0
9D000324  8C420000   LW V0, 0(V0)
9D000328  00400008   JR V0
9D00032C  00000000   NOP
69:                      {
70:                          case MI2CINT_START:
71:                          {
72:                              /* send the address ... which one?                                */
73:                              if (MasterI2CPort.status.flags.I2C_receive)
9D000354  3C02A000   LUI V0, -24576
9D000358  8C4201E4   LW V0, 484(V0)
9D00035C  30420001   ANDI V0, V0, 1
9D000360  1040000F   BEQ V0, ZERO, 0x9D0003A0
9D000364  00000000   NOP
74:                              {
75:                                  /* send read address                                          */
76:                                  I2C2TRN = MasterI2CPort.target_address | I2C_READ_BIT;
9D000368  3C02A000   LUI V0, -24576
9D00036C  244201E4   ADDIU V0, V0, 484
9D000370  90420005   LBU V0, 5(V0)
9D000374  34420001   ORI V0, V0, 1
9D000378  304200FF   ANDI V0, V0, 255
9D00037C  00401821   ADDU V1, V0, ZERO
9D000380  3C02BF80   LUI V0, -16512
9D000384  AC435450   SW V1, 21584(V0)
77:                                  MasterI2CPort.state = MI2CINT_RX_ADDRESS_ACK;
9D000388  3C02A000   LUI V0, -24576
9D00038C  244201E4   ADDIU V0, V0, 484
9D000390  24030003   ADDIU V1, ZERO, 3
9D000394  AC430014   SW V1, 20(V0)
78:                              } 
79:                              else
80:                              {
81:                                  /* send write address                                         */
82:                                  I2C2TRN = MasterI2CPort.target_address | I2C_WRITE_BIT;
9D0003A0  3C02A000   LUI V0, -24576
9D0003A4  244201E4   ADDIU V0, V0, 484
9D0003A8  90420005   LBU V0, 5(V0)
9D0003AC  00401821   ADDU V1, V0, ZERO
9D0003B0  3C02BF80   LUI V0, -16512
9D0003B4  AC435450   SW V1, 21584(V0)
83:                                  MasterI2CPort.state = MI2CINT_TX_ADDRESS_ACK;
9D0003B8  3C02A000   LUI V0, -24576
9D0003BC  244201E4   ADDIU V0, V0, 484
9D0003C0  24030001   ADDIU V1, ZERO, 1
9D0003C4  AC430014   SW V1, 20(V0)
84:                              }
85:                              break;
9D000398  0B40024E   J 0x9D000938
9D00039C  00000000   NOP
9D0003C8  0B40024E   J 0x9D000938
9D0003CC  00000000   NOP
86:                          }
87:                          case MI2CINT_TX_ADDRESS_ACK:
88:                          {
89:                              if (MasterI2CPort.STATShadow.ACKSTAT == I2C_NAK)
9D0003D0  3C02A000   LUI V0, -24576
9D0003D4  244201E4   ADDIU V0, V0, 484
9D0003D8  8C420018   LW V0, 24(V0)
9D0003DC  30428000   ANDI V0, V0, -32768
9D0003E0  10400014   BEQ V0, ZERO, 0x9D000434
9D0003E4  00000000   NOP
90:                              {
91:                                  /* if NAK, nobody acknowledged                                */
92:                                  MasterI2CPort.status.flags.I2C_error = TRUE;
9D0003E8  3C03A000   LUI V1, -24576
9D0003EC  8C6201E4   LW V0, 484(V1)
9D0003F0  24040001   ADDIU A0, ZERO, 1
9D0003F4  7C823184   INS V0, A0, 6, 1
9D0003F8  AC6201E4   SW V0, 484(V1)
93:                                  MasterI2CPort.status.flags.I2C_no_slave_addr_ack = TRUE;
9D0003FC  3C03A000   LUI V1, -24576
9D000400  8C6201E4   LW V0, 484(V1)
9D000404  24040001   ADDIU A0, ZERO, 1
9D000408  7C822104   INS V0, A0, 4, 1
9D00040C  AC6201E4   SW V0, 484(V1)
94:                                  I2CStop(I2C_PORT);
9D000410  24040001   ADDIU A0, ZERO, 1
9D000414  0F4017F3   JAL I2CStop
9D000418  00000000   NOP
95:                                  MasterI2CPort.state = MI2CINT_STOP;
9D00041C  3C02A000   LUI V0, -24576
9D000420  244201E4   ADDIU V0, V0, 484
9D000424  24030008   ADDIU V1, ZERO, 8
9D000428  AC430014   SW V1, 20(V0)
96:                              } 
97:                              else
98:                              {
99:                                  /* there was an acknowledge, send the first byte              */
100:                                 I2C2TRN = MasterI2CPort.Word[0];
9D000434  3C02A000   LUI V0, -24576
9D000438  244201E4   ADDIU V0, V0, 484
9D00043C  8C420008   LW V0, 8(V0)
9D000440  90420000   LBU V0, 0(V0)
9D000444  00401821   ADDU V1, V0, ZERO
9D000448  3C02BF80   LUI V0, -16512
9D00044C  AC435450   SW V1, 21584(V0)
101:                                 /* point to the next piece of data to send                    */
102:                                 MasterI2CPort.data_index = 1;
9D000450  3C02A000   LUI V0, -24576
9D000454  244201E4   ADDIU V0, V0, 484
9D000458  24030001   ADDIU V1, ZERO, 1
9D00045C  A0430004   SB V1, 4(V0)
103:                                 MasterI2CPort.state = MI2CINT_TX_DATA_ACK;
9D000460  3C02A000   LUI V0, -24576
9D000464  244201E4   ADDIU V0, V0, 484
9D000468  24030002   ADDIU V1, ZERO, 2
9D00046C  AC430014   SW V1, 20(V0)
104:                             }
105:                             break;
9D00042C  0B40024E   J 0x9D000938
9D000430  00000000   NOP
9D000470  0B40024E   J 0x9D000938
9D000474  00000000   NOP
106:                         }
107:                         case MI2CINT_TX_DATA_ACK:
108:                         {
109:                             if (MasterI2CPort.STATShadow.ACKSTAT == I2C_NAK)
9D000478  3C02A000   LUI V0, -24576
9D00047C  244201E4   ADDIU V0, V0, 484
9D000480  8C420018   LW V0, 24(V0)
9D000484  30428000   ANDI V0, V0, -32768
9D000488  10400014   BEQ V0, ZERO, 0x9D0004DC
9D00048C  00000000   NOP
110:                             {
111:                                 /* if NAK, nobody acknowledged                                */
112:                                 MasterI2CPort.status.flags.I2C_error = TRUE;
9D000490  3C03A000   LUI V1, -24576
9D000494  8C6201E4   LW V0, 484(V1)
9D000498  24040001   ADDIU A0, ZERO, 1
9D00049C  7C823184   INS V0, A0, 6, 1
9D0004A0  AC6201E4   SW V0, 484(V1)
113:                                 MasterI2CPort.status.flags.I2C_no_slave_data_ack = TRUE;
9D0004A4  3C03A000   LUI V1, -24576
9D0004A8  8C6201E4   LW V0, 484(V1)
9D0004AC  24040001   ADDIU A0, ZERO, 1
9D0004B0  7C822944   INS V0, A0, 5, 1
9D0004B4  AC6201E4   SW V0, 484(V1)
114:                                 I2CStop(I2C_PORT);
9D0004B8  24040001   ADDIU A0, ZERO, 1
9D0004BC  0F4017F3   JAL I2CStop
9D0004C0  00000000   NOP
115:                                 //mMasterI2CStopStart(); /* Send the Stop condition            */
116:                                 MasterI2CPort.state = MI2CINT_STOP;
9D0004C4  3C02A000   LUI V0, -24576
9D0004C8  244201E4   ADDIU V0, V0, 484
9D0004CC  24030008   ADDIU V1, ZERO, 8
9D0004D0  AC430014   SW V1, 20(V0)
117:                             } 
118:                             else /* there was an ACK                                          */
119:                             {
120:                                 /* have I written all the data?                               */
121:                                 if (MasterI2CPort.data_index >= MasterI2CPort.WordSize)
9D0004DC  3C02A000   LUI V0, -24576
9D0004E0  244201E4   ADDIU V0, V0, 484
9D0004E4  90430004   LBU V1, 4(V0)
9D0004E8  3C02A000   LUI V0, -24576
9D0004EC  244201E4   ADDIU V0, V0, 484
9D0004F0  90420011   LBU V0, 17(V0)
9D0004F4  0062102B   SLTU V0, V1, V0
9D0004F8  1440001C   BNE V0, ZERO, 0x9D00056C
9D0004FC  00000000   NOP
122:                                 {
123:                                     /* done with what we're going to write                    */
124:                                     if (MasterI2CPort.status.flags.I2C_read)
9D000500  3C02A000   LUI V0, -24576
9D000504  8C4201E4   LW V0, 484(V0)
9D000508  30420004   ANDI V0, V0, 4
9D00050C  1040000E   BEQ V0, ZERO, 0x9D000548
9D000510  00000000   NOP
125:                                     {
126:                                         mMasterI2CClearRBF();
9D000514  3C02BF80   LUI V0, -16512
9D000518  8C425460   LW V0, 21600(V0)
9D00051C  304200FF   ANDI V0, V0, 255
9D000520  A3828014   SB V0, -32748(GP)
127:                                         I2CRepeatStart(I2C_PORT);
9D000524  24040001   ADDIU A0, ZERO, 1
9D000528  0F401795   JAL I2CRepeatStart
9D00052C  00000000   NOP
128:                                         MasterI2CPort.state = MI2CINT_RESTART_END;
9D000530  3C02A000   LUI V0, -24576
9D000534  244201E4   ADDIU V0, V0, 484
9D000538  24030004   ADDIU V1, ZERO, 4
9D00053C  AC430014   SW V1, 20(V0)
129:                                     } 
130:                                     else
131:                                     {
132:                                         /* must be a write, and we're done                    */
133:                                         I2CStop(I2C_PORT);
9D000548  24040001   ADDIU A0, ZERO, 1
9D00054C  0F4017F3   JAL I2CStop
9D000550  00000000   NOP
134:                                         MasterI2CPort.state = MI2CINT_STOP;
9D000554  3C02A000   LUI V0, -24576
9D000558  244201E4   ADDIU V0, V0, 484
9D00055C  24030008   ADDIU V1, ZERO, 8
9D000560  AC430014   SW V1, 20(V0)
135:                                     }
136:                                 } 
137:                                 else
138:                                 {
139:                                     /* bounds check so we don't overrun the .Word array       */
140:                                     if (MasterI2CPort.data_index < I2CBUS_WORD_LENGTH)
9D00056C  3C02A000   LUI V0, -24576
9D000570  244201E4   ADDIU V0, V0, 484
9D000574  90420004   LBU V0, 4(V0)
9D000578  2C42000A   SLTIU V0, V0, 10
9D00057C  10400016   BEQ V0, ZERO, 0x9D0005D8
9D000580  00000000   NOP
141:                                     {
142:                                         I2C2TRN = MasterI2CPort.Word[MasterI2CPort.data_index];
9D000584  3C02A000   LUI V0, -24576
9D000588  244201E4   ADDIU V0, V0, 484
9D00058C  8C430008   LW V1, 8(V0)
9D000590  3C02A000   LUI V0, -24576
9D000594  244201E4   ADDIU V0, V0, 484
9D000598  90420004   LBU V0, 4(V0)
9D00059C  00621021   ADDU V0, V1, V0
9D0005A0  90420000   LBU V0, 0(V0)
9D0005A4  00401821   ADDU V1, V0, ZERO
9D0005A8  3C02BF80   LUI V0, -16512
9D0005AC  AC435450   SW V1, 21584(V0)
143:                                         /* point at next bit of data to send                  */
144:                                         MasterI2CPort.data_index++;
9D0005B0  3C02A000   LUI V0, -24576
9D0005B4  244201E4   ADDIU V0, V0, 484
9D0005B8  90420004   LBU V0, 4(V0)
9D0005BC  24420001   ADDIU V0, V0, 1
9D0005C0  304300FF   ANDI V1, V0, 255
9D0005C4  3C02A000   LUI V0, -24576
9D0005C8  244201E4   ADDIU V0, V0, 484
9D0005CC  A0430004   SB V1, 4(V0)
145:                                         /* and stay in this state                             */
146:                                     } 
147:                                     else
148:                                     {
149:                                         /* something is making us overrun the .Word array     */
150:                                         MasterI2CPort.status.flags.I2C_error = TRUE;
9D0005D8  3C03A000   LUI V1, -24576
9D0005DC  8C6201E4   LW V0, 484(V1)
9D0005E0  24040001   ADDIU A0, ZERO, 1
9D0005E4  7C823184   INS V0, A0, 6, 1
9D0005E8  AC6201E4   SW V0, 484(V1)
151:                                         MasterI2CPort.status.flags.I2C_FUBAR_error = TRUE;
9D0005EC  3C03A000   LUI V1, -24576
9D0005F0  8C6201E4   LW V0, 484(V1)
9D0005F4  24040001   ADDIU A0, ZERO, 1
9D0005F8  7C8239C4   INS V0, A0, 7, 1
9D0005FC  AC6201E4   SW V0, 484(V1)
152:                                         I2CStop(I2C_PORT);
9D000600  24040001   ADDIU A0, ZERO, 1
9D000604  0F4017F3   JAL I2CStop
9D000608  00000000   NOP
153:                                         MasterI2CPort.state = MI2CINT_STOP;
9D00060C  3C02A000   LUI V0, -24576
9D000610  244201E4   ADDIU V0, V0, 484
9D000614  24030008   ADDIU V1, ZERO, 8
9D000618  AC430014   SW V1, 20(V0)
154:                                     }
155:                                 }
156:                             }
157:                             break;
9D0004D4  0B40024E   J 0x9D000938
9D0004D8  00000000   NOP
9D000540  0B40024E   J 0x9D000938
9D000544  00000000   NOP
9D000564  0B40024E   J 0x9D000938
9D000568  00000000   NOP
9D0005D0  0B40024E   J 0x9D000938
9D0005D4  00000000   NOP
9D00061C  0B40024E   J 0x9D000938
9D000620  00000000   NOP
158:                         }
159:                         case MI2CINT_RESTART_END:
160:                         {
161:                             /* send read address                                              */
162:                             I2C2TRN = MasterI2CPort.target_address | I2C_READ_BIT;
9D000624  3C02A000   LUI V0, -24576
9D000628  244201E4   ADDIU V0, V0, 484
9D00062C  90420005   LBU V0, 5(V0)
9D000630  34420001   ORI V0, V0, 1
9D000634  304200FF   ANDI V0, V0, 255
9D000638  00401821   ADDU V1, V0, ZERO
9D00063C  3C02BF80   LUI V0, -16512
9D000640  AC435450   SW V1, 21584(V0)
163:                             MasterI2CPort.state = MI2CINT_RX_ADDRESS_ACK;
9D000644  3C02A000   LUI V0, -24576
9D000648  244201E4   ADDIU V0, V0, 484
9D00064C  24030003   ADDIU V1, ZERO, 3
9D000650  AC430014   SW V1, 20(V0)
164:                             break;
9D000654  0B40024E   J 0x9D000938
9D000658  00000000   NOP
165:                         }
166:                         case MI2CINT_RX_ADDRESS_ACK:
167:                         {
168:                             if (MasterI2CPort.STATShadow.ACKSTAT == I2C_NAK)
9D00065C  3C02A000   LUI V0, -24576
9D000660  244201E4   ADDIU V0, V0, 484
9D000664  8C420018   LW V0, 24(V0)
9D000668  30428000   ANDI V0, V0, -32768
9D00066C  10400014   BEQ V0, ZERO, 0x9D0006C0
9D000670  00000000   NOP
169:                             {
170:                                 /* if NAK, nobody acknowledged                                */
171:                                 MasterI2CPort.status.flags.I2C_error = TRUE;
9D000674  3C03A000   LUI V1, -24576
9D000678  8C6201E4   LW V0, 484(V1)
9D00067C  24040001   ADDIU A0, ZERO, 1
9D000680  7C823184   INS V0, A0, 6, 1
9D000684  AC6201E4   SW V0, 484(V1)
172:                                 MasterI2CPort.status.flags.I2C_no_slave_addr_ack = TRUE;
9D000688  3C03A000   LUI V1, -24576
9D00068C  8C6201E4   LW V0, 484(V1)
9D000690  24040001   ADDIU A0, ZERO, 1
9D000694  7C822104   INS V0, A0, 4, 1
9D000698  AC6201E4   SW V0, 484(V1)
173:                                 /* Send the Stop condition                                    */
174:                                 I2CStop(I2C_PORT);
9D00069C  24040001   ADDIU A0, ZERO, 1
9D0006A0  0F4017F3   JAL I2CStop
9D0006A4  00000000   NOP
175:                                 MasterI2CPort.state = MI2CINT_STOP;
9D0006A8  3C02A000   LUI V0, -24576
9D0006AC  244201E4   ADDIU V0, V0, 484
9D0006B0  24030008   ADDIU V1, ZERO, 8
9D0006B4  AC430014   SW V1, 20(V0)
176:                             } 
177:                             else
178:                             {
179:                                 MasterI2CPort.data_index = 0;
9D0006C0  3C02A000   LUI V0, -24576
9D0006C4  244201E4   ADDIU V0, V0, 484
9D0006C8  A0400004   SB ZERO, 4(V0)
180:                                 mMasterI2CClearRBF();
9D0006CC  3C02BF80   LUI V0, -16512
9D0006D0  8C425460   LW V0, 21600(V0)
9D0006D4  304200FF   ANDI V0, V0, 255
9D0006D8  A3828014   SB V0, -32748(GP)
181:                                 I2CReceiverEnable(I2C_PORT,TRUE);
9D0006DC  24040001   ADDIU A0, ZERO, 1
9D0006E0  24050001   ADDIU A1, ZERO, 1
9D0006E4  0F40176E   JAL I2CReceiverEnable
9D0006E8  00000000   NOP
182:                                 MasterI2CPort.state = MI2CINT_RX_DATA;
9D0006EC  3C02A000   LUI V0, -24576
9D0006F0  244201E4   ADDIU V0, V0, 484
9D0006F4  24030005   ADDIU V1, ZERO, 5
9D0006F8  AC430014   SW V1, 20(V0)
183:                             }
184:                             break;
9D0006B8  0B40024E   J 0x9D000938
9D0006BC  00000000   NOP
9D0006FC  0B40024E   J 0x9D000938
9D000700  00000000   NOP
185:                         }
186:                         case MI2CINT_RX_DATA:
187:                         {
188:                             /* Bounds check data_index for safe access of .Data[]             */
189:                             if (MasterI2CPort.data_index < I2CBUS_DATA_LENGTH)
9D000704  3C02A000   LUI V0, -24576
9D000708  244201E4   ADDIU V0, V0, 484
9D00070C  90420004   LBU V0, 4(V0)
9D000710  2C42000A   SLTIU V0, V0, 10
9D000714  1040002E   BEQ V0, ZERO, 0x9D0007D0
9D000718  00000000   NOP
190:                             {
191:                                 MasterI2CPort.Data[MasterI2CPort.data_index++] = I2C2RCV;
9D00071C  3C02A000   LUI V0, -24576
9D000720  244201E4   ADDIU V0, V0, 484
9D000724  8C44000C   LW A0, 12(V0)
9D000728  3C02A000   LUI V0, -24576
9D00072C  244201E4   ADDIU V0, V0, 484
9D000730  90420004   LBU V0, 4(V0)
9D000734  00401821   ADDU V1, V0, ZERO
9D000738  00831821   ADDU V1, A0, V1
9D00073C  3C04BF80   LUI A0, -16512
9D000740  8C845460   LW A0, 21600(A0)
9D000744  308400FF   ANDI A0, A0, 255
9D000748  A0640000   SB A0, 0(V1)
9D00074C  24420001   ADDIU V0, V0, 1
9D000750  304300FF   ANDI V1, V0, 255
9D000754  3C02A000   LUI V0, -24576
9D000758  244201E4   ADDIU V0, V0, 484
9D00075C  A0430004   SB V1, 4(V0)
192:                                 if (MasterI2CPort.data_index == MasterI2CPort.DataSize) 
9D000760  3C02A000   LUI V0, -24576
9D000764  244201E4   ADDIU V0, V0, 484
9D000768  90430004   LBU V1, 4(V0)
9D00076C  3C02A000   LUI V0, -24576
9D000770  244201E4   ADDIU V0, V0, 484
9D000774  90420010   LBU V0, 16(V0)
9D000778  1462000B   BNE V1, V0, 0x9D0007A8
9D00077C  00000000   NOP
193:                                 {
194:                                     I2CAcknowledgeByte(I2C_PORT,FALSE);
9D000780  24040001   ADDIU A0, ZERO, 1
9D000784  00002821   ADDU A1, ZERO, ZERO
9D000788  0F4016F0   JAL I2CAcknowledgeByte
9D00078C  00000000   NOP
195:                                     MasterI2CPort.state = MI2CINT_RX_DATA_NAK;
9D000790  3C02A000   LUI V0, -24576
9D000794  244201E4   ADDIU V0, V0, 484
9D000798  24030007   ADDIU V1, ZERO, 7
9D00079C  AC430014   SW V1, 20(V0)
196:                                 } 
197:                                 else
198:                                 {
199:                                     /* send ACK to signify there will be more                 */
200:                                     I2CAcknowledgeByte(I2C_PORT,TRUE);
9D0007A8  24040001   ADDIU A0, ZERO, 1
9D0007AC  24050001   ADDIU A1, ZERO, 1
9D0007B0  0F4016F0   JAL I2CAcknowledgeByte
9D0007B4  00000000   NOP
201:                                     MasterI2CPort.state = MI2CINT_RX_DATA_ACK;
9D0007B8  3C02A000   LUI V0, -24576
9D0007BC  244201E4   ADDIU V0, V0, 484
9D0007C0  24030006   ADDIU V1, ZERO, 6
9D0007C4  AC430014   SW V1, 20(V0)
202:                                 }
203:                             } 
204:                             else
205:                             {
206:                                 MasterI2CPort.state = MI2CINT_RX_DATA_NAK;
9D0007D0  3C02A000   LUI V0, -24576
9D0007D4  244201E4   ADDIU V0, V0, 484
9D0007D8  24030007   ADDIU V1, ZERO, 7
9D0007DC  AC430014   SW V1, 20(V0)
207:                                 MasterI2CPort.status.flags.I2C_error = TRUE;
9D0007E0  3C03A000   LUI V1, -24576
9D0007E4  8C6201E4   LW V0, 484(V1)
9D0007E8  24040001   ADDIU A0, ZERO, 1
9D0007EC  7C823184   INS V0, A0, 6, 1
9D0007F0  AC6201E4   SW V0, 484(V1)
208:                                 MasterI2CPort.status.flags.I2C_FUBAR_error = TRUE;
9D0007F4  3C03A000   LUI V1, -24576
9D0007F8  8C6201E4   LW V0, 484(V1)
9D0007FC  24040001   ADDIU A0, ZERO, 1
9D000800  7C8239C4   INS V0, A0, 7, 1
9D000804  AC6201E4   SW V0, 484(V1)
209:                                 I2CAcknowledgeByte(I2C_PORT,FALSE);
9D000808  24040001   ADDIU A0, ZERO, 1
9D00080C  00002821   ADDU A1, ZERO, ZERO
9D000810  0F4016F0   JAL I2CAcknowledgeByte
9D000814  00000000   NOP
210:                             }
211:                             break;
9D0007A0  0B40024E   J 0x9D000938
9D0007A4  00000000   NOP
9D0007C8  0B40024E   J 0x9D000938
9D0007CC  00000000   NOP
9D000818  0B40024E   J 0x9D000938
9D00081C  00000000   NOP
212:                         }
213:                         case MI2CINT_RX_DATA_ACK:
214:                         {
215:                             /* still have more to recieve- start another RX cycle             */
216:                             I2CReceiverEnable(I2C_PORT,TRUE);
9D000820  24040001   ADDIU A0, ZERO, 1
9D000824  24050001   ADDIU A1, ZERO, 1
9D000828  0F40176E   JAL I2CReceiverEnable
9D00082C  00000000   NOP
217:                             MasterI2CPort.state = MI2CINT_RX_DATA;
9D000830  3C02A000   LUI V0, -24576
9D000834  244201E4   ADDIU V0, V0, 484
9D000838  24030005   ADDIU V1, ZERO, 5
9D00083C  AC430014   SW V1, 20(V0)
218:                             break;
9D000840  0B40024E   J 0x9D000938
9D000844  00000000   NOP
219:                         }
220:                         case MI2CINT_RX_DATA_NAK:
221:                         {
222:                             /* No more to send, or an error case- send the Stop condition     */
223:                             I2CStop(I2C_PORT);
9D000848  24040001   ADDIU A0, ZERO, 1
9D00084C  0F4017F3   JAL I2CStop
9D000850  00000000   NOP
224:                             MasterI2CPort.state = MI2CINT_STOP;
9D000854  3C02A000   LUI V0, -24576
9D000858  244201E4   ADDIU V0, V0, 484
9D00085C  24030008   ADDIU V1, ZERO, 8
9D000860  AC430014   SW V1, 20(V0)
225:                             break;
9D000864  0B40024E   J 0x9D000938
9D000868  00000000   NOP
226:                         }
227:                         case MI2CINT_STOP:
228:                         {
229:                             MasterI2CPort.status.flags.I2C_action_complete = TRUE;
9D00086C  3C03A000   LUI V1, -24576
9D000870  8C6201E4   LW V0, 484(V1)
9D000874  24040001   ADDIU A0, ZERO, 1
9D000878  7C825284   INS V0, A0, 10, 1
9D00087C  AC6201E4   SW V0, 484(V1)
230:                             MasterI2CPort.status.flags.I2C_busy = FALSE;
9D000880  3C03A000   LUI V1, -24576
9D000884  8C6201E4   LW V0, 484(V1)
9D000888  7C0218C4   INS V0, ZERO, 3, 1
9D00088C  AC6201E4   SW V0, 484(V1)
231:                             INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000890  2404003D   ADDIU A0, ZERO, 61
9D000894  00002821   ADDU A1, ZERO, ZERO
9D000898  0F4016DC   JAL INTEnable
9D00089C  00000000   NOP
232:                             #ifdef I2C_USE_TIMEOUT
233:                                 mMasterI2CTimeoutStopTimer();
9D0008A0  3C03BF80   LUI V1, -16512
9D0008A4  8C620E00   LW V0, 3584(V1)
9D0008A8  7C027BC4   INS V0, ZERO, 15, 1
9D0008AC  AC620E00   SW V0, 3584(V1)
234:                                 INTEnable(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER),INT_DISABLED);
9D0008B0  2404000C   ADDIU A0, ZERO, 12
9D0008B4  00002821   ADDU A1, ZERO, ZERO
9D0008B8  0F4016DC   JAL INTEnable
9D0008BC  00000000   NOP
235:                                 INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D0008C0  2404000C   ADDIU A0, ZERO, 12
9D0008C4  0F4017B7   JAL INTClearFlag
9D0008C8  00000000   NOP
236:                             #endif
237:                             /* prepare the state machine for next round                       */
238:                             MasterI2CPort.state = MI2CINT_START;
9D0008CC  3C02A000   LUI V0, -24576
9D0008D0  244201E4   ADDIU V0, V0, 484
9D0008D4  AC400014   SW ZERO, 20(V0)
239:                             break;
9D0008D8  0B40024E   J 0x9D000938
9D0008DC  00000000   NOP
240:                         }
241:                         default:
242:                         {
243:                             mMasterI2CClearRBF();
9D0008E0  3C02BF80   LUI V0, -16512
9D0008E4  8C425460   LW V0, 21600(V0)
9D0008E8  304200FF   ANDI V0, V0, 255
9D0008EC  A3828014   SB V0, -32748(GP)
244:                             /* Start a 'STOP' cycle                                           */
245:                             I2CStop(I2C_PORT);
9D0008F0  24040001   ADDIU A0, ZERO, 1
9D0008F4  0F4017F3   JAL I2CStop
9D0008F8  00000000   NOP
246:                             MasterI2CPort.status.flags.I2C_error = TRUE;
9D0008FC  3C03A000   LUI V1, -24576
9D000900  8C6201E4   LW V0, 484(V1)
9D000904  24040001   ADDIU A0, ZERO, 1
9D000908  7C823184   INS V0, A0, 6, 1
9D00090C  AC6201E4   SW V0, 484(V1)
247:                             /* set a flag for debugging                                       */
248:                             MasterI2CPort.status.flags.I2C_error_default_state = TRUE;
9D000910  3C03A000   LUI V1, -24576
9D000914  8C6201E4   LW V0, 484(V1)
9D000918  24040001   ADDIU A0, ZERO, 1
9D00091C  7C824204   INS V0, A0, 8, 1
9D000920  AC6201E4   SW V0, 484(V1)
249:                             MasterI2CPort.state = MI2CINT_STOP;
9D000924  3C02A000   LUI V0, -24576
9D000928  244201E4   ADDIU V0, V0, 484
9D00092C  24030008   ADDIU V1, ZERO, 8
9D000930  AC430014   SW V1, 20(V0)
250:                             break;
9D000934  00000000   NOP
251:                         }
252:                     }
253:                 }
9D000938  03C0E821   ADDU SP, S8, ZERO
9D00093C  8FA20064   LW V0, 100(SP)
9D000940  00400013   MTLO V0, 0
9D000944  8FA30060   LW V1, 96(SP)
9D000948  00600011   MTHI V1, 0
9D00094C  8FBF005C   LW RA, 92(SP)
9D000950  8FBE0058   LW S8, 88(SP)
9D000954  8FB90054   LW T9, 84(SP)
9D000958  8FB80050   LW T8, 80(SP)
9D00095C  8FAF004C   LW T7, 76(SP)
9D000960  8FAE0048   LW T6, 72(SP)
9D000964  8FAD0044   LW T5, 68(SP)
9D000968  8FAC0040   LW T4, 64(SP)
9D00096C  8FAB003C   LW T3, 60(SP)
9D000970  8FAA0038   LW T2, 56(SP)
9D000974  8FA90034   LW T1, 52(SP)
9D000978  8FA80030   LW T0, 48(SP)
9D00097C  8FA7002C   LW A3, 44(SP)
9D000980  8FA60028   LW A2, 40(SP)
9D000984  8FA50024   LW A1, 36(SP)
9D000988  8FA40020   LW A0, 32(SP)
9D00098C  8FA3001C   LW V1, 28(SP)
9D000990  8FA20018   LW V0, 24(SP)
9D000994  8FA10014   LW AT, 20(SP)
9D000998  41606000   DI ZERO
9D00099C  000000C0   EHB
9D0009A0  8FBA0074   LW K0, 116(SP)
9D0009A4  8FBB0070   LW K1, 112(SP)
9D0009A8  409A7000   MTC0 K0, EPC
9D0009AC  8FBA006C   LW K0, 108(SP)
9D0009B0  27BD0078   ADDIU SP, SP, 120
9D0009B4  409A6002   MTC0 K0, SRSCtl
9D0009B8  41DDE800   WRPGPR SP, SP
9D0009BC  409B6000   MTC0 K1, Status
9D0009C0  42000018   ERET
254:                 
255:                 /******************************************************************************/
256:                 /* BOOL MasterI2CQueueCommand(I2CBUS_COMMAND_TYPE *command)                   */
257:                 /* kicks off an I2C transaction as specified by the *command structure        */
258:                 /******************************************************************************/
259:                 
260:                 BOOL MasterI2CQueueCommand(I2CBUS_COMMAND_TYPE *command)
261:                 {
9D0009C4  27BDFFE8   ADDIU SP, SP, -24
9D0009C8  AFBF0014   SW RA, 20(SP)
9D0009CC  AFBE0010   SW S8, 16(SP)
9D0009D0  03A0F021   ADDU S8, SP, ZERO
9D0009D4  AFC40018   SW A0, 24(S8)
262:                     if(!MasterI2CPort.status.flags.I2C_busy)
9D0009D8  3C02A000   LUI V0, -24576
9D0009DC  8C4201E4   LW V0, 484(V0)
9D0009E0  30420008   ANDI V0, V0, 8
9D0009E4  14400075   BNE V0, ZERO, 0x9D000BBC
9D0009E8  00000000   NOP
263:                     {
264:                         /* this port is not already doing something                           */
265:                         /* just in case, disable interrupts                                   */
266:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D0009EC  2404003D   ADDIU A0, ZERO, 61
9D0009F0  00002821   ADDU A1, ZERO, ZERO
9D0009F4  0F4016DC   JAL INTEnable
9D0009F8  00000000   NOP
267:                         #ifdef I2C_USE_TIMEOUT
268:                             mMasterI2CTimeoutStopTimer();
9D0009FC  3C03BF80   LUI V1, -16512
9D000A00  8C620E00   LW V0, 3584(V1)
9D000A04  7C027BC4   INS V0, ZERO, 15, 1
9D000A08  AC620E00   SW V0, 3584(V1)
269:                             INTEnable(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER),INT_DISABLED);
9D000A0C  2404000C   ADDIU A0, ZERO, 12
9D000A10  00002821   ADDU A1, ZERO, ZERO
9D000A14  0F4016DC   JAL INTEnable
9D000A18  00000000   NOP
270:                         #endif
271:                         /* clear out the status                                               */
272:                         MasterI2CPort.status.all = 0;
9D000A1C  3C02A000   LUI V0, -24576
9D000A20  AC4001E4   SW ZERO, 484(V0)
273:                         /* copy the relevant portions to the port's status register           */
274:                         MasterI2CPort.status.flags.I2C_action_complete = FALSE;
9D000A24  3C03A000   LUI V1, -24576
9D000A28  8C6201E4   LW V0, 484(V1)
9D000A2C  7C025284   INS V0, ZERO, 10, 1
9D000A30  AC6201E4   SW V0, 484(V1)
275:                         MasterI2CPort.status.flags.I2C_busy = TRUE;
9D000A34  3C03A000   LUI V1, -24576
9D000A38  8C6201E4   LW V0, 484(V1)
9D000A3C  24040001   ADDIU A0, ZERO, 1
9D000A40  7C8218C4   INS V0, A0, 3, 1
9D000A44  AC6201E4   SW V0, 484(V1)
276:                         MasterI2CPort.status.flags.I2C_receive = command->status.flags.I2C_receive;
9D000A48  8FC20018   LW V0, 24(S8)
9D000A4C  8C420000   LW V0, 0(V0)
9D000A50  7C420000   EXT V0, V0, 0, 1
9D000A54  304400FF   ANDI A0, V0, 255
9D000A58  3C03A000   LUI V1, -24576
9D000A5C  8C6201E4   LW V0, 484(V1)
9D000A60  7C820004   INS V0, A0, 0, 1
9D000A64  AC6201E4   SW V0, 484(V1)
277:                         MasterI2CPort.status.flags.I2C_write = command->status.flags.I2C_write;
9D000A68  8FC20018   LW V0, 24(S8)
9D000A6C  8C420000   LW V0, 0(V0)
9D000A70  7C420040   EXT V0, V0, 1, 1
9D000A74  304400FF   ANDI A0, V0, 255
9D000A78  3C03A000   LUI V1, -24576
9D000A7C  8C6201E4   LW V0, 484(V1)
9D000A80  7C820844   INS V0, A0, 1, 1
9D000A84  AC6201E4   SW V0, 484(V1)
278:                         MasterI2CPort.status.flags.I2C_read = command->status.flags.I2C_read;
9D000A88  8FC20018   LW V0, 24(S8)
9D000A8C  8C420000   LW V0, 0(V0)
9D000A90  7C420080   EXT V0, V0, 2, 1
9D000A94  304400FF   ANDI A0, V0, 255
9D000A98  3C03A000   LUI V1, -24576
9D000A9C  8C6201E4   LW V0, 484(V1)
9D000AA0  7C821084   INS V0, A0, 2, 1
9D000AA4  AC6201E4   SW V0, 484(V1)
279:                         MasterI2CPort.target_address = command->target_address;
9D000AA8  8FC20018   LW V0, 24(S8)
9D000AAC  90430004   LBU V1, 4(V0)
9D000AB0  3C02A000   LUI V0, -24576
9D000AB4  244201E4   ADDIU V0, V0, 484
9D000AB8  A0430005   SB V1, 5(V0)
280:                         MasterI2CPort.DataSize = command->DataSize;
9D000ABC  8FC20018   LW V0, 24(S8)
9D000AC0  90430019   LBU V1, 25(V0)
9D000AC4  3C02A000   LUI V0, -24576
9D000AC8  244201E4   ADDIU V0, V0, 484
9D000ACC  A0430010   SB V1, 16(V0)
281:                         MasterI2CPort.WordSize = command->WordSize;
9D000AD0  8FC20018   LW V0, 24(S8)
9D000AD4  9043001A   LBU V1, 26(V0)
9D000AD8  3C02A000   LUI V0, -24576
9D000ADC  244201E4   ADDIU V0, V0, 484
9D000AE0  A0430011   SB V1, 17(V0)
282:                         MasterI2CPort.Word = command->Word; /* just make these pointers to the  */
9D000AE4  8FC20018   LW V0, 24(S8)
9D000AE8  24430005   ADDIU V1, V0, 5
9D000AEC  3C02A000   LUI V0, -24576
9D000AF0  244201E4   ADDIU V0, V0, 484
9D000AF4  AC430008   SW V1, 8(V0)
283:                         MasterI2CPort.Data = command->Data; /* data in the structure that was   */
9D000AF8  8FC20018   LW V0, 24(S8)
9D000AFC  2443000F   ADDIU V1, V0, 15
9D000B00  3C02A000   LUI V0, -24576
9D000B04  244201E4   ADDIU V0, V0, 484
9D000B08  AC43000C   SW V1, 12(V0)
284:                         /* sent here                        */
285:                         MasterI2CPort.data_index = 0;
9D000B0C  3C02A000   LUI V0, -24576
9D000B10  244201E4   ADDIU V0, V0, 484
9D000B14  A0400004   SB ZERO, 4(V0)
286:                         #ifdef I2C_USE_TIMEOUT
287:                             mMasterI2CTimeoutClearTimer();
9D000B18  3C03BF80   LUI V1, -16512
9D000B1C  8C620E00   LW V0, 3584(V1)
9D000B20  7C027BC4   INS V0, ZERO, 15, 1
9D000B24  AC620E00   SW V0, 3584(V1)
9D000B28  3C02BF80   LUI V0, -16512
9D000B2C  AC400E10   SW ZERO, 3600(V0)
9D000B30  3C03BF80   LUI V1, -16512
9D000B34  8C620E00   LW V0, 3584(V1)
9D000B38  24040001   ADDIU A0, ZERO, 1
9D000B3C  7C827BC4   INS V0, A0, 15, 1
9D000B40  AC620E00   SW V0, 3584(V1)
288:                             mMasterI2CTimeoutStartTimer();
9D000B44  3C03BF80   LUI V1, -16512
9D000B48  8C620E00   LW V0, 3584(V1)
9D000B4C  24040001   ADDIU A0, ZERO, 1
9D000B50  7C827BC4   INS V0, A0, 15, 1
9D000B54  AC620E00   SW V0, 3584(V1)
289:                             INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D000B58  2404000C   ADDIU A0, ZERO, 12
9D000B5C  0F4017B7   JAL INTClearFlag
9D000B60  00000000   NOP
290:                             //mMasterI2CTimeoutClearInterruptFlag();
291:                             //mMasterI2CTimeoutEnableInterrupt();
292:                             INTEnable(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER),INT_ENABLED);
9D000B64  2404000C   ADDIU A0, ZERO, 12
9D000B68  24050001   ADDIU A1, ZERO, 1
9D000B6C  0F4016DC   JAL INTEnable
9D000B70  00000000   NOP
293:                         #endif
294:                 
295:                         INTClearFlag(INT_SOURCE_I2C_MASTER(I2C_PORT));
9D000B74  2404003D   ADDIU A0, ZERO, 61
9D000B78  0F4017B7   JAL INTClearFlag
9D000B7C  00000000   NOP
296:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_ENABLED);
9D000B80  2404003D   ADDIU A0, ZERO, 61
9D000B84  24050001   ADDIU A1, ZERO, 1
9D000B88  0F4016DC   JAL INTEnable
9D000B8C  00000000   NOP
297:                         if (I2CBusIsIdle(I2C_PORT))
9D000B90  24040001   ADDIU A0, ZERO, 1
9D000B94  0F4016C7   JAL I2CBusIsIdle
9D000B98  00000000   NOP
9D000B9C  10400007   BEQ V0, ZERO, 0x9D000BBC
9D000BA0  00000000   NOP
298:                         {
299:                             I2CStart(I2C_PORT);
9D000BA4  24040001   ADDIU A0, ZERO, 1
9D000BA8  0F40177C   JAL I2CStart
9D000BAC  00000000   NOP
300:                             return SUCCESS;
9D000BB0  24020001   ADDIU V0, ZERO, 1
9D000BB4  0B4002F0   J 0x9D000BC0
9D000BB8  00000000   NOP
301:                         }
302:                     }
303:                     return FAIL;
9D000BBC  00001021   ADDU V0, ZERO, ZERO
304:                 }
9D000BC0  03C0E821   ADDU SP, S8, ZERO
9D000BC4  8FBF0014   LW RA, 20(SP)
9D000BC8  8FBE0010   LW S8, 16(SP)
9D000BCC  27BD0018   ADDIU SP, SP, 24
9D000BD0  03E00008   JR RA
9D000BD4  00000000   NOP
305:                 
306:                 /******************************************************************************/
307:                 /* BOOL MasterI2CUpdateQueuedCommand(I2CBUS_COMMAND_TYPE *command)            */
308:                 /* if the I2C transaction is complete, copies the status and the size of the  */
309:                 /* data read into the *command structure. The *command structure was already  */
310:                 /* where the interrupt had written the data to.                               */
311:                 /******************************************************************************/
312:                 
313:                 BOOL MasterI2CUpdateQueuedCommand(I2CBUS_COMMAND_TYPE *command)
314:                 {
9D000BD8  27BDFFF0   ADDIU SP, SP, -16
9D000BDC  AFBE000C   SW S8, 12(SP)
9D000BE0  03A0F021   ADDU S8, SP, ZERO
9D000BE4  AFC40010   SW A0, 16(S8)
315:                     BOOL returnValue=FAIL;
9D000BE8  AFC00000   SW ZERO, 0(S8)
316:                     if(MasterI2CPort.status.flags.I2C_action_complete)
9D000BEC  3C02A000   LUI V0, -24576
9D000BF0  8C4201E4   LW V0, 484(V0)
9D000BF4  30420400   ANDI V0, V0, 1024
9D000BF8  10400013   BEQ V0, ZERO, 0x9D000C48
9D000BFC  00000000   NOP
317:                     {
318:                         /* just in case */
319:                         #ifdef I2C_USE_TIMEOUT
320:                         mMasterI2CTimeoutStopTimer();
9D000C00  3C03BF80   LUI V1, -16512
9D000C04  8C620E00   LW V0, 3584(V1)
9D000C08  7C027BC4   INS V0, ZERO, 15, 1
9D000C0C  AC620E00   SW V0, 3584(V1)
321:                         #endif
322:                         command->status=MasterI2CPort.status;
9D000C10  8FC20010   LW V0, 16(S8)
9D000C14  3C03A000   LUI V1, -24576
9D000C18  8C6301E4   LW V1, 484(V1)
9D000C1C  AC430000   SW V1, 0(V0)
323:                         command->DataSize=MasterI2CPort.data_index;
9D000C20  3C02A000   LUI V0, -24576
9D000C24  244201E4   ADDIU V0, V0, 484
9D000C28  90430004   LBU V1, 4(V0)
9D000C2C  8FC20010   LW V0, 16(S8)
9D000C30  A0430019   SB V1, 25(V0)
324:                         returnValue= !MasterI2CPort.status.flags.I2C_error;
9D000C34  3C02A000   LUI V0, -24576
9D000C38  8C4201E4   LW V0, 484(V0)
9D000C3C  30420040   ANDI V0, V0, 64
9D000C40  2C420001   SLTIU V0, V0, 1
9D000C44  AFC20000   SW V0, 0(S8)
325:                         
326:                     }
327:                 //    else
328:                 //    {
329:                 //            /* this port has not gone through a full I2C transaction cycle */
330:                 //    }
331:                     return returnValue;
9D000C48  8FC20000   LW V0, 0(S8)
332:                 }
9D000C4C  03C0E821   ADDU SP, S8, ZERO
9D000C50  8FBE000C   LW S8, 12(SP)
9D000C54  27BD0010   ADDIU SP, SP, 16
9D000C58  03E00008   JR RA
9D000C5C  00000000   NOP
333:                 
334:                 #ifdef I2C_PARANOID_INIT
335:                 /******************************************************************************/
336:                 /* void I2CInitCommand(I2CBUS_COMMAND_TYPE *command)                          */
337:                 /* initializes and clears out the I2C command structure passed by *command    */
338:                 /* could be simplified, but is useful to clear out the structure in the       */
339:                 /* development process to be absolutely sure of what data is being written    */
340:                 /* into the structure by the I2C engine                                       */
341:                 /******************************************************************************/
342:                 
343:                 void I2CInitCommand(I2CBUS_COMMAND_TYPE *command)
344:                 {
345:                     int index;
346:                     command->status.all=0;
347:                     for(index=0;index<I2CBUS_WORD_LENGTH;index++)
348:                     {
349:                         command->Word[index]=0;
350:                     }
351:                     for(index=0;index<I2CBUS_DATA_LENGTH;index++)
352:                     {
353:                         command->Data[index]=0;
354:                     }
355:                     command->DataSize=0;
356:                     command->WordSize=0;
357:                     command->target_address=0;
358:                 }
359:                 #endif
360:                 /******************************************************************************/
361:                 /* BOOL MasterI2CStartup(BOOL repairIO)                                       */
362:                 /* configures I2C port and timeout timer. if repairIO is TRUE, check to see   */
363:                 /* if the I2C pins are high- if they are not, attempt to fix it. Returns      */
364:                 /* FALSE if there was a recovery attempt that was unsuccessful                */
365:                 /******************************************************************************/
366:                 
367:                 BOOL MasterI2CStartup(void)
368:                 {
9D000C60  27BDFFE8   ADDIU SP, SP, -24
9D000C64  AFBF0014   SW RA, 20(SP)
9D000C68  AFBE0010   SW S8, 16(SP)
9D000C6C  03A0F021   ADDU S8, SP, ZERO
369:                     I2CEnable(I2C_PORT,FALSE);
9D000C70  24040001   ADDIU A0, ZERO, 1
9D000C74  00002821   ADDU A1, ZERO, ZERO
9D000C78  0F4017E9   JAL I2CEnable
9D000C7C  00000000   NOP
370:                     //I2C2CONbits.ON=FALSE;
371:                     INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000C80  2404003D   ADDIU A0, ZERO, 61
9D000C84  00002821   ADDU A1, ZERO, ZERO
9D000C88  0F4016DC   JAL INTEnable
9D000C8C  00000000   NOP
372:                     if(!MasterI2CIOCheck())
9D000C90  0F40036A   JAL MasterI2CIOCheck
9D000C94  00000000   NOP
9D000C98  14400004   BNE V0, ZERO, 0x9D000CAC
9D000C9C  00000000   NOP
373:                     {
374:                         return FALSE;
9D000CA0  00001021   ADDU V0, ZERO, ZERO
9D000CA4  0B400364   J 0x9D000D90
9D000CA8  00000000   NOP
375:                     }
376:                     MasterI2CPort.status.all=0;
9D000CAC  3C02A000   LUI V0, -24576
9D000CB0  AC4001E4   SW ZERO, 484(V0)
377:                     #ifdef I2C_USE_TIMEOUT
378:                     OpenTimer5(
9D000CB4  3C02BF80   LUI V0, -16512
9D000CB8  24030070   ADDIU V1, ZERO, 112
9D000CBC  AC430E00   SW V1, 3584(V0)
9D000CC0  3C02BF80   LUI V0, -16512
9D000CC4  AC400E10   SW ZERO, 3600(V0)
9D000CC8  3C02BF80   LUI V0, -16512
9D000CCC  24033888   ADDIU V1, ZERO, 14472
9D000CD0  AC430E20   SW V1, 3616(V0)
9D000CD4  3C02BF80   LUI V0, -16512
9D000CD8  AC400E08   SW ZERO, 3592(V0)
379:                         T5_OFF|
380:                         T5_IDLE_CON|
381:                         T5_GATE_OFF|
382:                         I2C_TIMEOUT_PRESCALER|
383:                         T5_SOURCE_INT,
384:                         I2C_TIMEOUT_INTERVAL);
385:                     INTClearFlag(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER));
9D000CDC  2404000C   ADDIU A0, ZERO, 12
9D000CE0  0F4017B7   JAL INTClearFlag
9D000CE4  00000000   NOP
386:                     INTSetVectorPriority(INT_VECTOR_TIMER(I2C_TIMEOUT_TIMER),I2C_TIMEOUT_TIMER_INT_PRIORITY);
9D000CE8  2404000C   ADDIU A0, ZERO, 12
9D000CEC  24050004   ADDIU A1, ZERO, 4
9D000CF0  0F401752   JAL INTSetVectorPriority
9D000CF4  00000000   NOP
387:                     INTSetVectorSubPriority(INT_VECTOR_I2C(I2C_TIMEOUT_TIMER),I2C_TIMEOUT_TIMER_INT_SUB_PRIORITY);
9D000CF8  24040025   ADDIU A0, ZERO, 37
9D000CFC  24050001   ADDIU A1, ZERO, 1
9D000D00  0F401760   JAL INTSetVectorSubPriority
9D000D04  00000000   NOP
388:                     INTEnable(INT_SOURCE_TIMER(I2C_TIMEOUT_TIMER),INT_DISABLED);
9D000D08  2404000C   ADDIU A0, ZERO, 12
9D000D0C  00002821   ADDU A1, ZERO, ZERO
9D000D10  0F4016DC   JAL INTEnable
9D000D14  00000000   NOP
389:                     //SetPriorityIntT5(T5_INT_OFF|TIMEOUT_INT_PRIORITY|T5_INT_SUB_PRIOR_1);
390:                     #endif
391:                     MasterI2CPort.state=MI2CINT_START;
9D000D18  3C02A000   LUI V0, -24576
9D000D1C  244201E4   ADDIU V0, V0, 484
9D000D20  AC400014   SW ZERO, 20(V0)
392:                     //I2C2CON=0; /* clear to a known state */
393:                     //DelayMs(10);
394:                     //I2C2BRG=BRG_VAL;
395:                     //I2C2STAT=0;
396:                     //I2C2CONbits.SIDL=TRUE;   /* stop when in idle mode */
397:                     //I2C2CONbits.SCLREL=TRUE; /* SCL release (doesn't really matter as master) */
398:                     //I2C2CONbits.STRICT=FALSE;/* do not strictly interpret I2C addresses*/
399:                     //I2C2CONbits.A10M=FALSE;  /* use 7 bit addressing */
400:                     //I2C2CONbits.DISSLW=TRUE; /* disable slew rate control */
401:                     //I2C2CONbits.SMEN=FALSE;  /* do not use SMBUS levels */
402:                     I2CConfigure(I2C_PORT,0);
9D000D24  24040001   ADDIU A0, ZERO, 1
9D000D28  00002821   ADDU A1, ZERO, ZERO
9D000D2C  0F4017FC   JAL I2CConfigure
9D000D30  00000000   NOP
403:                     I2CSetFrequency(I2C_PORT, GetPeripheralClock(), Fsck);
9D000D34  24040001   ADDIU A0, ZERO, 1
9D000D38  3C0204C4   LUI V0, 1220
9D000D3C  3445B400   ORI A1, V0, -19456
9D000D40  3C020001   LUI V0, 1
9D000D44  344686A0   ORI A2, V0, -31072
9D000D48  0F401703   JAL I2CSetFrequency
9D000D4C  00000000   NOP
404:                     I2CEnable(I2C_PORT, TRUE);
9D000D50  24040001   ADDIU A0, ZERO, 1
9D000D54  24050001   ADDIU A1, ZERO, 1
9D000D58  0F4017E9   JAL I2CEnable
9D000D5C  00000000   NOP
405:                     //I2C2CONbits.ON=TRUE;     /* turn I2C module on */
406:                     INTClearFlag(INT_SOURCE_I2C_MASTER(I2C_PORT));
9D000D60  2404003D   ADDIU A0, ZERO, 61
9D000D64  0F4017B7   JAL INTClearFlag
9D000D68  00000000   NOP
407:                     INTSetVectorPriority(INT_VECTOR_I2C(I2C_PORT),MI2C_INT_PRIORITY);
9D000D6C  24040022   ADDIU A0, ZERO, 34
9D000D70  24050006   ADDIU A1, ZERO, 6
9D000D74  0F401752   JAL INTSetVectorPriority
9D000D78  00000000   NOP
408:                     INTSetVectorSubPriority(INT_VECTOR_I2C(I2C_PORT),MI2C_INT_SUB_PRIORITY);
9D000D7C  24040022   ADDIU A0, ZERO, 34
9D000D80  24050001   ADDIU A1, ZERO, 1
9D000D84  0F401760   JAL INTSetVectorSubPriority
9D000D88  00000000   NOP
409:                     //SetPriorityIntI2C2(I2C_INT_OFF|MI2C_INT_PRIORITY|I2C_INT_SUB_PRI_1);
410:                     return TRUE;
9D000D8C  24020001   ADDIU V0, ZERO, 1
411:                 }
9D000D90  03C0E821   ADDU SP, S8, ZERO
9D000D94  8FBF0014   LW RA, 20(SP)
9D000D98  8FBE0010   LW S8, 16(SP)
9D000D9C  27BD0018   ADDIU SP, SP, 24
9D000DA0  03E00008   JR RA
9D000DA4  00000000   NOP
412:                 
413:                 /******************************************************************************/
414:                 /* MasterI2CIOCheck()                                                         */
415:                 /******************************************************************************/
416:                 
417:                 BOOL MasterI2CIOCheck(void)
418:                 {
9D000DA8  27BDFFE0   ADDIU SP, SP, -32
9D000DAC  AFBF001C   SW RA, 28(SP)
9D000DB0  AFBE0018   SW S8, 24(SP)
9D000DB4  03A0F021   ADDU S8, SP, ZERO
419:                     BOOL returnValue=FALSE;
9D000DB8  AFC00010   SW ZERO, 16(S8)
420:                     /* make sure I2C port is off */
421:                     I2CEnable(I2C_PORT,FALSE);
9D000DBC  24040001   ADDIU A0, ZERO, 1
9D000DC0  00002821   ADDU A1, ZERO, ZERO
9D000DC4  0F4017E9   JAL I2CEnable
9D000DC8  00000000   NOP
422:                     //I2C2CONbits.ON=FALSE;
423:                     I2C2_SCL_DIRECTION=TRIS_IN;
9D000DCC  3C03BF88   LUI V1, -16504
9D000DD0  8C626000   LW V0, 24576(V1)
9D000DD4  24040001   ADDIU A0, ZERO, 1
9D000DD8  7C821084   INS V0, A0, 2, 1
9D000DDC  AC626000   SW V0, 24576(V1)
424:                     I2C2_SDA_DIRECTION=TRIS_IN;
9D000DE0  3C03BF88   LUI V1, -16504
9D000DE4  8C626000   LW V0, 24576(V1)
9D000DE8  24040001   ADDIU A0, ZERO, 1
9D000DEC  7C8218C4   INS V0, A0, 3, 1
9D000DF0  AC626000   SW V0, 24576(V1)
425:                     /* wait a little while */
426:                     DelayMs(10);
9D000DF4  2404000A   ADDIU A0, ZERO, 10
9D000DF8  0F4015E5   JAL DelayMs
9D000DFC  00000000   NOP
427:                     returnValue=((I2C2_SCL_IN==1)&&(I2C2_SDA_IN==1));
9D000E00  3C02BF88   LUI V0, -16504
9D000E04  8C426010   LW V0, 24592(V0)
9D000E08  30420004   ANDI V0, V0, 4
9D000E0C  10400009   BEQ V0, ZERO, 0x9D000E34
9D000E10  00000000   NOP
9D000E14  3C02BF88   LUI V0, -16504
9D000E18  8C426010   LW V0, 24592(V0)
9D000E1C  30420008   ANDI V0, V0, 8
9D000E20  10400004   BEQ V0, ZERO, 0x9D000E34
9D000E24  00000000   NOP
9D000E28  24020001   ADDIU V0, ZERO, 1
9D000E2C  0B40038E   J 0x9D000E38
9D000E30  00000000   NOP
9D000E34  00001021   ADDU V0, ZERO, ZERO
9D000E38  AFC20010   SW V0, 16(S8)
428:                     return returnValue;
9D000E3C  8FC20010   LW V0, 16(S8)
429:                 }
9D000E40  03C0E821   ADDU SP, S8, ZERO
9D000E44  8FBF001C   LW RA, 28(SP)
9D000E48  8FBE0018   LW S8, 24(SP)
9D000E4C  27BD0020   ADDIU SP, SP, 32
9D000E50  03E00008   JR RA
9D000E54  00000000   NOP
430:                 
431:                 /******************************************************************************/
432:                 /* accessor function for I2C_busy                                             */
433:                 /*   attempting to be interrupt safe                                          */
434:                 /******************************************************************************/
435:                 
436:                 inline BOOL MasterI2CIsBusy(void)
437:                 {
9D000E58  27BDFFE0   ADDIU SP, SP, -32
9D000E5C  AFBF001C   SW RA, 28(SP)
9D000E60  AFBE0018   SW S8, 24(SP)
9D000E64  03A0F021   ADDU S8, SP, ZERO
438:                     BOOL returnValue;
439:                     if(INTGetEnable(INT_SOURCE_I2C_MASTER(I2C_PORT)))
9D000E68  2404003D   ADDIU A0, ZERO, 61
9D000E6C  0F4017D5   JAL INTGetEnable
9D000E70  00000000   NOP
9D000E74  10400010   BEQ V0, ZERO, 0x9D000EB8
9D000E78  00000000   NOP
440:                     {
441:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000E7C  2404003D   ADDIU A0, ZERO, 61
9D000E80  00002821   ADDU A1, ZERO, ZERO
9D000E84  0F4016DC   JAL INTEnable
9D000E88  00000000   NOP
442:                         returnValue=MasterI2CPort.status.flags.I2C_busy;
9D000E8C  3C02A000   LUI V0, -24576
9D000E90  8C4201E4   LW V0, 484(V0)
9D000E94  7C4200C0   EXT V0, V0, 3, 1
9D000E98  304200FF   ANDI V0, V0, 255
9D000E9C  AFC20010   SW V0, 16(S8)
443:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_ENABLED);
9D000EA0  2404003D   ADDIU A0, ZERO, 61
9D000EA4  24050001   ADDIU A1, ZERO, 1
9D000EA8  0F4016DC   JAL INTEnable
9D000EAC  00000000   NOP
9D000EB0  0B4003B3   J 0x9D000ECC
9D000EB4  00000000   NOP
444:                     }
445:                     else
446:                     {
447:                         returnValue=MasterI2CPort.status.flags.I2C_busy;
9D000EB8  3C02A000   LUI V0, -24576
9D000EBC  8C4201E4   LW V0, 484(V0)
9D000EC0  7C4200C0   EXT V0, V0, 3, 1
9D000EC4  304200FF   ANDI V0, V0, 255
9D000EC8  AFC20010   SW V0, 16(S8)
448:                     }
449:                     return returnValue;
9D000ECC  8FC20010   LW V0, 16(S8)
450:                 }
9D000ED0  03C0E821   ADDU SP, S8, ZERO
9D000ED4  8FBF001C   LW RA, 28(SP)
9D000ED8  8FBE0018   LW S8, 24(SP)
9D000EDC  27BD0020   ADDIU SP, SP, 32
9D000EE0  03E00008   JR RA
9D000EE4  00000000   NOP
451:                 
452:                 /******************************************************************************/
453:                 /* accessor function for I2C_action_complete                                  */
454:                 /******************************************************************************/
455:                 
456:                 inline BOOL MasterI2CIsQueuedCommandDone(void)
457:                 {
9D000EE8  27BDFFE0   ADDIU SP, SP, -32
9D000EEC  AFBF001C   SW RA, 28(SP)
9D000EF0  AFBE0018   SW S8, 24(SP)
9D000EF4  03A0F021   ADDU S8, SP, ZERO
458:                     BOOL returnValue;
459:                     if(INTGetEnable(INT_SOURCE_I2C_MASTER(I2C_PORT)))
9D000EF8  2404003D   ADDIU A0, ZERO, 61
9D000EFC  0F4017D5   JAL INTGetEnable
9D000F00  00000000   NOP
9D000F04  10400010   BEQ V0, ZERO, 0x9D000F48
9D000F08  00000000   NOP
460:                     {
461:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_DISABLED);
9D000F0C  2404003D   ADDIU A0, ZERO, 61
9D000F10  00002821   ADDU A1, ZERO, ZERO
9D000F14  0F4016DC   JAL INTEnable
9D000F18  00000000   NOP
462:                         returnValue=MasterI2CPort.status.flags.I2C_action_complete;
9D000F1C  3C02A000   LUI V0, -24576
9D000F20  8C4201E4   LW V0, 484(V0)
9D000F24  7C420280   EXT V0, V0, 10, 1
9D000F28  304200FF   ANDI V0, V0, 255
9D000F2C  AFC20010   SW V0, 16(S8)
463:                         INTEnable(INT_SOURCE_I2C_MASTER(I2C_PORT),INT_ENABLED);
9D000F30  2404003D   ADDIU A0, ZERO, 61
9D000F34  24050001   ADDIU A1, ZERO, 1
9D000F38  0F4016DC   JAL INTEnable
9D000F3C  00000000   NOP
9D000F40  0B4003D7   J 0x9D000F5C
9D000F44  00000000   NOP
464:                     }
465:                     else
466:                     {
467:                         returnValue = MasterI2CPort.status.flags.I2C_action_complete;
9D000F48  3C02A000   LUI V0, -24576
9D000F4C  8C4201E4   LW V0, 484(V0)
9D000F50  7C420280   EXT V0, V0, 10, 1
9D000F54  304200FF   ANDI V0, V0, 255
9D000F58  AFC20010   SW V0, 16(S8)
468:                     }
469:                     return returnValue;
9D000F5C  8FC20010   LW V0, 16(S8)
470:                 }
9D000F60  03C0E821   ADDU SP, S8, ZERO
9D000F64  8FBF001C   LW RA, 28(SP)
9D000F68  8FBE0018   LW S8, 24(SP)
9D000F6C  27BD0020   ADDIU SP, SP, 32
9D000F70  03E00008   JR RA
9D000F74  00000000   NOP
471:                 
472:                 BOOL MasterI2CReadByte(UINT8 address, UINT8 toReadRegister, UINT8 *dataRead)
473:                 {
9D000F78  27BDFFC8   ADDIU SP, SP, -56
9D000F7C  AFBF0034   SW RA, 52(SP)
9D000F80  AFBE0030   SW S8, 48(SP)
9D000F84  03A0F021   ADDU S8, SP, ZERO
9D000F88  00801821   ADDU V1, A0, ZERO
9D000F8C  00A01021   ADDU V0, A1, ZERO
9D000F90  AFC60040   SW A2, 64(S8)
9D000F94  A3C30038   SB V1, 56(S8)
9D000F98  A3C2003C   SB V0, 60(S8)
474:                     I2CBUS_COMMAND_TYPE RI2CCommand;
475:                     #ifdef I2C_PARANOID_INIT
476:                         I2CInitCommand(&RI2CCommand);
477:                     #else
478:                         RI2CCommand.status.all=0;
9D000F9C  AFC00010   SW ZERO, 16(S8)
479:                     #endif
480:                     RI2CCommand.status.flags.I2C_read=TRUE;
9D000FA0  8FC20010   LW V0, 16(S8)
9D000FA4  24030001   ADDIU V1, ZERO, 1
9D000FA8  7C621084   INS V0, V1, 2, 1
9D000FAC  AFC20010   SW V0, 16(S8)
481:                     RI2CCommand.target_address=address;
9D000FB0  93C20038   LBU V0, 56(S8)
9D000FB4  A3C20014   SB V0, 20(S8)
482:                     RI2CCommand.Word[0]=toReadRegister;
9D000FB8  93C2003C   LBU V0, 60(S8)
9D000FBC  A3C20015   SB V0, 21(S8)
483:                     RI2CCommand.WordSize=1;
9D000FC0  24020001   ADDIU V0, ZERO, 1
9D000FC4  A3C2002A   SB V0, 42(S8)
484:                     RI2CCommand.DataSize=1;
9D000FC8  24020001   ADDIU V0, ZERO, 1
9D000FCC  A3C20029   SB V0, 41(S8)
485:                     if(MasterI2CQueueCommand(&RI2CCommand))
9D000FD0  27C20010   ADDIU V0, S8, 16
9D000FD4  00402021   ADDU A0, V0, ZERO
9D000FD8  0F400271   JAL MasterI2CQueueCommand
9D000FDC  00000000   NOP
9D000FE0  10400016   BEQ V0, ZERO, 0x9D00103C
9D000FE4  00000000   NOP
486:                     {
487:                         while (MasterI2CIsBusy());
9D000FE8  00000000   NOP
9D000FEC  0F400396   JAL MasterI2CIsBusy
9D000FF0  00000000   NOP
9D000FF4  1440FFFD   BNE V0, ZERO, 0x9D000FEC
9D000FF8  00000000   NOP
488:                         if (MasterI2CUpdateQueuedCommand(&RI2CCommand))
9D000FFC  27C20010   ADDIU V0, S8, 16
9D001000  00402021   ADDU A0, V0, ZERO
9D001004  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D001008  00000000   NOP
9D00100C  1040000B   BEQ V0, ZERO, 0x9D00103C
9D001010  00000000   NOP
489:                         {
490:                             /* was there an error? */
491:                             if (!RI2CCommand.status.flags.I2C_error)
9D001014  8FC20010   LW V0, 16(S8)
9D001018  30420040   ANDI V0, V0, 64
9D00101C  14400007   BNE V0, ZERO, 0x9D00103C
9D001020  00000000   NOP
492:                             {
493:                                 *dataRead = RI2CCommand.Data[0];
9D001024  93C3001F   LBU V1, 31(S8)
9D001028  8FC20040   LW V0, 64(S8)
9D00102C  A0430000   SB V1, 0(V0)
494:                                 return TRUE;
9D001030  24020001   ADDIU V0, ZERO, 1
9D001034  0B400410   J 0x9D001040
9D001038  00000000   NOP
495:                             }
496:                         }
497:                     }
498:                     return FALSE;
9D00103C  00001021   ADDU V0, ZERO, ZERO
499:                 }
9D001040  03C0E821   ADDU SP, S8, ZERO
9D001044  8FBF0034   LW RA, 52(SP)
9D001048  8FBE0030   LW S8, 48(SP)
9D00104C  27BD0038   ADDIU SP, SP, 56
9D001050  03E00008   JR RA
9D001054  00000000   NOP
500:                 
501:                 BOOL MasterI2CReadWord(UINT8 address, UINT8 toReadRegister, UINT16 *dataRead)
502:                 {
9D001058  27BDFFC8   ADDIU SP, SP, -56
9D00105C  AFBF0034   SW RA, 52(SP)
9D001060  AFBE0030   SW S8, 48(SP)
9D001064  03A0F021   ADDU S8, SP, ZERO
9D001068  00801821   ADDU V1, A0, ZERO
9D00106C  00A01021   ADDU V0, A1, ZERO
9D001070  AFC60040   SW A2, 64(S8)
9D001074  A3C30038   SB V1, 56(S8)
9D001078  A3C2003C   SB V0, 60(S8)
503:                     I2CBUS_COMMAND_TYPE RI2CCommand;
504:                     UINT16_VAL tempDataRead;
505:                     #ifdef I2C_PARANOID_INIT
506:                         I2CInitCommand(&RI2CCommand);
507:                     #else
508:                         RI2CCommand.status.all=0;
9D00107C  AFC00010   SW ZERO, 16(S8)
509:                     #endif
510:                     RI2CCommand.status.flags.I2C_read=TRUE;
9D001080  8FC20010   LW V0, 16(S8)
9D001084  24030001   ADDIU V1, ZERO, 1
9D001088  7C621084   INS V0, V1, 2, 1
9D00108C  AFC20010   SW V0, 16(S8)
511:                     RI2CCommand.target_address=address;
9D001090  93C20038   LBU V0, 56(S8)
9D001094  A3C20014   SB V0, 20(S8)
512:                     RI2CCommand.Word[0]=toReadRegister;
9D001098  93C2003C   LBU V0, 60(S8)
9D00109C  A3C20015   SB V0, 21(S8)
513:                     RI2CCommand.WordSize=1;
9D0010A0  24020001   ADDIU V0, ZERO, 1
9D0010A4  A3C2002A   SB V0, 42(S8)
514:                     RI2CCommand.DataSize=2;
9D0010A8  24020002   ADDIU V0, ZERO, 2
9D0010AC  A3C20029   SB V0, 41(S8)
515:                     if(MasterI2CQueueCommand(&RI2CCommand))
9D0010B0  27C20010   ADDIU V0, S8, 16
9D0010B4  00402021   ADDU A0, V0, ZERO
9D0010B8  0F400271   JAL MasterI2CQueueCommand
9D0010BC  00000000   NOP
9D0010C0  1040001A   BEQ V0, ZERO, 0x9D00112C
9D0010C4  00000000   NOP
516:                     {
517:                         while(MasterI2CIsBusy());
9D0010C8  00000000   NOP
9D0010CC  0F400396   JAL MasterI2CIsBusy
9D0010D0  00000000   NOP
9D0010D4  1440FFFD   BNE V0, ZERO, 0x9D0010CC
9D0010D8  00000000   NOP
518:                         if(MasterI2CUpdateQueuedCommand(&RI2CCommand))
9D0010DC  27C20010   ADDIU V0, S8, 16
9D0010E0  00402021   ADDU A0, V0, ZERO
9D0010E4  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D0010E8  00000000   NOP
9D0010EC  1040000F   BEQ V0, ZERO, 0x9D00112C
9D0010F0  00000000   NOP
519:                         {
520:                             /* was there an error? */
521:                             if(!RI2CCommand.status.flags.I2C_error)
9D0010F4  8FC20010   LW V0, 16(S8)
9D0010F8  30420040   ANDI V0, V0, 64
9D0010FC  1440000B   BNE V0, ZERO, 0x9D00112C
9D001100  00000000   NOP
522:                             {
523:                                 tempDataRead.byte.LB=RI2CCommand.Data[0];
9D001104  93C2001F   LBU V0, 31(S8)
9D001108  A3C2002C   SB V0, 44(S8)
524:                                 tempDataRead.byte.HB=RI2CCommand.Data[1];
9D00110C  93C20020   LBU V0, 32(S8)
9D001110  A3C2002D   SB V0, 45(S8)
525:                                 *dataRead=tempDataRead.Val;
9D001114  97C3002C   LHU V1, 44(S8)
9D001118  8FC20040   LW V0, 64(S8)
9D00111C  A4430000   SH V1, 0(V0)
526:                                 return TRUE;
9D001120  24020001   ADDIU V0, ZERO, 1
9D001124  0B40044C   J 0x9D001130
9D001128  00000000   NOP
527:                             }
528:                         }
529:                     }
530:                     return FALSE;
9D00112C  00001021   ADDU V0, ZERO, ZERO
531:                 }
9D001130  03C0E821   ADDU SP, S8, ZERO
9D001134  8FBF0034   LW RA, 52(SP)
9D001138  8FBE0030   LW S8, 48(SP)
9D00113C  27BD0038   ADDIU SP, SP, 56
9D001140  03E00008   JR RA
9D001144  00000000   NOP
532:                 
533:                 BOOL  MasterI2CWriteVerifyByteNoRetry(UINT8 address, UINT8 toWriteRegister, UINT8 toWriteData)
534:                 {
9D001148  27BDFFC8   ADDIU SP, SP, -56
9D00114C  AFBF0034   SW RA, 52(SP)
9D001150  AFBE0030   SW S8, 48(SP)
9D001154  03A0F021   ADDU S8, SP, ZERO
9D001158  00A01821   ADDU V1, A1, ZERO
9D00115C  00C01021   ADDU V0, A2, ZERO
9D001160  A3C40038   SB A0, 56(S8)
9D001164  A3C3003C   SB V1, 60(S8)
9D001168  A3C20040   SB V0, 64(S8)
535:                     I2CBUS_COMMAND_TYPE WVI2CCommand;
536:                     UINT8 dataRead;
537:                     #ifdef I2C_PARANOID_INIT
538:                         I2CInitCommand(&WVI2CCommand);
539:                     #else
540:                         WVI2CCommand.status.all=0;
9D00116C  AFC00010   SW ZERO, 16(S8)
541:                     #endif
542:                     WVI2CCommand.status.flags.I2C_write=TRUE;
9D001170  8FC20010   LW V0, 16(S8)
9D001174  24030001   ADDIU V1, ZERO, 1
9D001178  7C620844   INS V0, V1, 1, 1
9D00117C  AFC20010   SW V0, 16(S8)
543:                     WVI2CCommand.target_address=address;
9D001180  93C20038   LBU V0, 56(S8)
9D001184  A3C20014   SB V0, 20(S8)
544:                     WVI2CCommand.Word[0]=toWriteRegister;
9D001188  93C2003C   LBU V0, 60(S8)
9D00118C  A3C20015   SB V0, 21(S8)
545:                     WVI2CCommand.Word[1]=toWriteData;
9D001190  93C20040   LBU V0, 64(S8)
9D001194  A3C20016   SB V0, 22(S8)
546:                     WVI2CCommand.WordSize=2;
9D001198  24020002   ADDIU V0, ZERO, 2
9D00119C  A3C2002A   SB V0, 42(S8)
547:                     if(MasterI2CQueueCommand(&WVI2CCommand))
9D0011A0  27C20010   ADDIU V0, S8, 16
9D0011A4  00402021   ADDU A0, V0, ZERO
9D0011A8  0F400271   JAL MasterI2CQueueCommand
9D0011AC  00000000   NOP
9D0011B0  10400020   BEQ V0, ZERO, 0x9D001234
9D0011B4  00000000   NOP
548:                     {
549:                         /* wait for the transaction to be done */
550:                         while(MasterI2CIsBusy());
9D0011B8  00000000   NOP
9D0011BC  0F400396   JAL MasterI2CIsBusy
9D0011C0  00000000   NOP
9D0011C4  1440FFFD   BNE V0, ZERO, 0x9D0011BC
9D0011C8  00000000   NOP
551:                         if(MasterI2CUpdateQueuedCommand(&WVI2CCommand))
9D0011CC  27C20010   ADDIU V0, S8, 16
9D0011D0  00402021   ADDU A0, V0, ZERO
9D0011D4  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D0011D8  00000000   NOP
9D0011DC  10400015   BEQ V0, ZERO, 0x9D001234
9D0011E0  00000000   NOP
552:                         {
553:                             /* was there an error? */
554:                             if(!WVI2CCommand.status.flags.I2C_error)
9D0011E4  8FC20010   LW V0, 16(S8)
9D0011E8  30420040   ANDI V0, V0, 64
9D0011EC  14400011   BNE V0, ZERO, 0x9D001234
9D0011F0  00000000   NOP
555:                             {
556:                                 /* no error, now verify */
557:                                 if(MasterI2CReadByte(address,toWriteRegister,&dataRead))
9D0011F4  93C40038   LBU A0, 56(S8)
9D0011F8  93C3003C   LBU V1, 60(S8)
9D0011FC  27C2002C   ADDIU V0, S8, 44
9D001200  00602821   ADDU A1, V1, ZERO
9D001204  00403021   ADDU A2, V0, ZERO
9D001208  0F4003DE   JAL MasterI2CReadByte
9D00120C  00000000   NOP
9D001210  10400008   BEQ V0, ZERO, 0x9D001234
9D001214  00000000   NOP
558:                                 {
559:                                     if(dataRead==toWriteData)
9D001218  93C2002C   LBU V0, 44(S8)
9D00121C  93C30040   LBU V1, 64(S8)
9D001220  14620004   BNE V1, V0, 0x9D001234
9D001224  00000000   NOP
560:                                     {
561:                                         return TRUE;
9D001228  24020001   ADDIU V0, ZERO, 1
9D00122C  0B40048E   J 0x9D001238
9D001230  00000000   NOP
562:                                     }
563:                                 }
564:                             }
565:                         }
566:                     }
567:                     return FALSE;
9D001234  00001021   ADDU V0, ZERO, ZERO
568:                 }
9D001238  03C0E821   ADDU SP, S8, ZERO
9D00123C  8FBF0034   LW RA, 52(SP)
9D001240  8FBE0030   LW S8, 48(SP)
9D001244  27BD0038   ADDIU SP, SP, 56
9D001248  03E00008   JR RA
9D00124C  00000000   NOP
569:                 
570:                 BOOL  MasterI2CWriteVerifyWordNoRetry(UINT8 address, UINT8 toWriteRegister, UINT16 toWriteData)
571:                 {
9D001250  27BDFFC8   ADDIU SP, SP, -56
9D001254  AFBF0034   SW RA, 52(SP)
9D001258  AFBE0030   SW S8, 48(SP)
9D00125C  03A0F021   ADDU S8, SP, ZERO
9D001260  00A01821   ADDU V1, A1, ZERO
9D001264  00C01021   ADDU V0, A2, ZERO
9D001268  A3C40038   SB A0, 56(S8)
9D00126C  A3C3003C   SB V1, 60(S8)
9D001270  A7C20040   SH V0, 64(S8)
572:                     I2CBUS_COMMAND_TYPE WVI2CCommand;
573:                     UINT16_VAL tempWord;
574:                     tempWord.Val=toWriteData;
9D001274  97C20040   LHU V0, 64(S8)
9D001278  A7C2002C   SH V0, 44(S8)
575:                     #ifdef I2C_PARANOID_INIT
576:                         I2CInitCommand(&WVI2CCommand);
577:                     #else
578:                         WVI2CCommand.status.all=0;
9D00127C  AFC00010   SW ZERO, 16(S8)
579:                     #endif
580:                     WVI2CCommand.status.flags.I2C_write=TRUE;
9D001280  8FC20010   LW V0, 16(S8)
9D001284  24030001   ADDIU V1, ZERO, 1
9D001288  7C620844   INS V0, V1, 1, 1
9D00128C  AFC20010   SW V0, 16(S8)
581:                     WVI2CCommand.target_address=address;
9D001290  93C20038   LBU V0, 56(S8)
9D001294  A3C20014   SB V0, 20(S8)
582:                     WVI2CCommand.Word[0]=toWriteRegister;
9D001298  93C2003C   LBU V0, 60(S8)
9D00129C  A3C20015   SB V0, 21(S8)
583:                     WVI2CCommand.Word[1]=tempWord.byte.LB;
9D0012A0  93C2002C   LBU V0, 44(S8)
9D0012A4  A3C20016   SB V0, 22(S8)
584:                     WVI2CCommand.Word[2]=tempWord.byte.HB;
9D0012A8  93C2002D   LBU V0, 45(S8)
9D0012AC  A3C20017   SB V0, 23(S8)
585:                     WVI2CCommand.WordSize=3;
9D0012B0  24020003   ADDIU V0, ZERO, 3
9D0012B4  A3C2002A   SB V0, 42(S8)
586:                     if(MasterI2CQueueCommand(&WVI2CCommand))
9D0012B8  27C20010   ADDIU V0, S8, 16
9D0012BC  00402021   ADDU A0, V0, ZERO
9D0012C0  0F400271   JAL MasterI2CQueueCommand
9D0012C4  00000000   NOP
9D0012C8  10400020   BEQ V0, ZERO, 0x9D00134C
9D0012CC  00000000   NOP
587:                     {
588:                         /* wait for the transaction to be done */
589:                         while(MasterI2CIsBusy());
9D0012D0  00000000   NOP
9D0012D4  0F400396   JAL MasterI2CIsBusy
9D0012D8  00000000   NOP
9D0012DC  1440FFFD   BNE V0, ZERO, 0x9D0012D4
9D0012E0  00000000   NOP
590:                         if(MasterI2CUpdateQueuedCommand(&WVI2CCommand))
9D0012E4  27C20010   ADDIU V0, S8, 16
9D0012E8  00402021   ADDU A0, V0, ZERO
9D0012EC  0F4002F6   JAL MasterI2CUpdateQueuedCommand
9D0012F0  00000000   NOP
9D0012F4  10400015   BEQ V0, ZERO, 0x9D00134C
9D0012F8  00000000   NOP
591:                         {
592:                             /* was there an error? */
593:                             if(!WVI2CCommand.status.flags.I2C_error)
9D0012FC  8FC20010   LW V0, 16(S8)
9D001300  30420040   ANDI V0, V0, 64
9D001304  14400011   BNE V0, ZERO, 0x9D00134C
9D001308  00000000   NOP
594:                             {
595:                                 /* no error, now verify */
596:                                 if(MasterI2CReadWord(address,toWriteRegister,&tempWord.Val))
9D00130C  93C40038   LBU A0, 56(S8)
9D001310  93C3003C   LBU V1, 60(S8)
9D001314  27C2002C   ADDIU V0, S8, 44
9D001318  00602821   ADDU A1, V1, ZERO
9D00131C  00403021   ADDU A2, V0, ZERO
9D001320  0F400416   JAL MasterI2CReadWord
9D001324  00000000   NOP
9D001328  10400008   BEQ V0, ZERO, 0x9D00134C
9D00132C  00000000   NOP
597:                                 {
598:                                     if(tempWord.Val==toWriteData)
9D001330  97C2002C   LHU V0, 44(S8)
9D001334  97C30040   LHU V1, 64(S8)
9D001338  14620004   BNE V1, V0, 0x9D00134C
9D00133C  00000000   NOP
599:                                     {
600:                                         return TRUE;
9D001340  24020001   ADDIU V0, ZERO, 1
9D001344  0B4004D4   J 0x9D001350
9D001348  00000000   NOP
601:                                     }
602:                                 }
603:                             }
604:                         }
605:                     }
606:                     return FALSE;
9D00134C  00001021   ADDU V0, ZERO, ZERO
607:                 }
9D001350  03C0E821   ADDU SP, S8, ZERO
9D001354  8FBF0034   LW RA, 52(SP)
9D001358  8FBE0030   LW S8, 48(SP)
9D00135C  27BD0038   ADDIU SP, SP, 56
9D001360  03E00008   JR RA
9D001364  00000000   NOP
608:                 
609:                 enum MASTER_I2C_OWNER_TYPE currentOwner=NONE;
610:                 
611:                 BOOL MasterI2CClaimPort(enum MASTER_I2C_OWNER_TYPE owner)
612:                 {
9D001368  27BDFFF0   ADDIU SP, SP, -16
9D00136C  AFBE000C   SW S8, 12(SP)
9D001370  03A0F021   ADDU S8, SP, ZERO
9D001374  AFC40010   SW A0, 16(S8)
613:                     BOOL returnValue=FALSE;
9D001378  AFC00000   SW ZERO, 0(S8)
614:                     if(currentOwner==NONE)
9D00137C  8F828010   LW V0, -32752(GP)
9D001380  1440000F   BNE V0, ZERO, 0x9D0013C0
9D001384  00000000   NOP
615:                     {
616:                         switch(owner)
9D001388  8FC20010   LW V0, 16(S8)
9D00138C  2442FFFF   ADDIU V0, V0, -1
9D001390  2C420002   SLTIU V0, V0, 2
9D001394  10400007   BEQ V0, ZERO, 0x9D0013B4
9D001398  00000000   NOP
617:                         {
618:                             case DIGIPOT:
619:                             case POWER_MONITOR:
620:                             {
621:                                 currentOwner = owner;
9D00139C  8FC20010   LW V0, 16(S8)
9D0013A0  AF828010   SW V0, -32752(GP)
622:                                 returnValue = TRUE;
9D0013A4  24020001   ADDIU V0, ZERO, 1
9D0013A8  AFC20000   SW V0, 0(S8)
623:                                 break;
9D0013AC  0B4004F0   J 0x9D0013C0
9D0013B0  00000000   NOP
624:                             }
625:                             case NONE:
626:                             default:
627:                             {
628:                                 returnValue = TRUE;
9D0013B4  24020001   ADDIU V0, ZERO, 1
9D0013B8  AFC20000   SW V0, 0(S8)
629:                                 break;
9D0013BC  00000000   NOP
630:                             }
631:                         }
632:                     }
633:                     return returnValue;
9D0013C0  8FC20000   LW V0, 0(S8)
634:                 }
9D0013C4  03C0E821   ADDU SP, S8, ZERO
9D0013C8  8FBE000C   LW S8, 12(SP)
9D0013CC  27BD0010   ADDIU SP, SP, 16
9D0013D0  03E00008   JR RA
9D0013D4  00000000   NOP
635:                 
636:                 void MasterI2CReleasePort(void)
637:                 {
9D0013D8  27BDFFF8   ADDIU SP, SP, -8
9D0013DC  AFBE0004   SW S8, 4(SP)
9D0013E0  03A0F021   ADDU S8, SP, ZERO
638:                     /* maybe check to see if the Master I2C is busy? */
639:                     currentOwner=NONE;
9D0013E4  AF808010   SW ZERO, -32752(GP)
640:                 }
9D0013E8  03C0E821   ADDU SP, S8, ZERO
9D0013EC  8FBE0004   LW S8, 4(SP)
9D0013F0  27BD0008   ADDIU SP, SP, 8
9D0013F4  03E00008   JR RA
9D0013F8  00000000   NOP
641:                 
642:                 BOOL MasterI2CAvailable(void)
643:                 {
9D0013FC  27BDFFF0   ADDIU SP, SP, -16
9D001400  AFBE000C   SW S8, 12(SP)
9D001404  03A0F021   ADDU S8, SP, ZERO
644:                     BOOL returnValue=FALSE;
9D001408  AFC00000   SW ZERO, 0(S8)
645:                     if(currentOwner==NONE)
9D00140C  8F828010   LW V0, -32752(GP)
9D001410  14400003   BNE V0, ZERO, 0x9D001420
9D001414  00000000   NOP
646:                     {
647:                         returnValue=TRUE;
9D001418  24020001   ADDIU V0, ZERO, 1
9D00141C  AFC20000   SW V0, 0(S8)
648:                     }
649:                     return returnValue;
9D001420  8FC20000   LW V0, 0(S8)
650:                 }
9D001424  03C0E821   ADDU SP, S8, ZERO
9D001428  8FBE000C   LW S8, 12(SP)
9D00142C  27BD0010   ADDIU SP, SP, 16
9D001430  03E00008   JR RA
9D001434  00000000   NOP
651:                 
652:                 BOOL MasterI2CHasPort(enum MASTER_I2C_OWNER_TYPE owner)
653:                 {
9D001438  27BDFFF8   ADDIU SP, SP, -8
9D00143C  AFBE0004   SW S8, 4(SP)
9D001440  03A0F021   ADDU S8, SP, ZERO
9D001444  AFC40008   SW A0, 8(S8)
654:                     if(owner==currentOwner)
9D001448  8F828010   LW V0, -32752(GP)
9D00144C  8FC30008   LW V1, 8(S8)
9D001450  14620004   BNE V1, V0, 0x9D001464
9D001454  00000000   NOP
655:                     {
656:                         return TRUE;
9D001458  24020001   ADDIU V0, ZERO, 1
9D00145C  0B40051A   J 0x9D001468
9D001460  00000000   NOP
657:                     }
658:                     return FALSE;
9D001464  00001021   ADDU V0, ZERO, ZERO
659:                 }
9D001468  03C0E821   ADDU SP, S8, ZERO
9D00146C  8FBE0004   LW S8, 4(SP)
9D001470  27BD0008   ADDIU SP, SP, 8
9D001474  03E00008   JR RA
9D001478  00000000   NOP
